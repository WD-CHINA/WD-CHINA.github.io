var se=(n,e,t)=>new Promise((r,s)=>{var a=u=>{try{i(t.next(u))}catch(l){s(l)}},o=u=>{try{i(t.throw(u))}catch(l){s(l)}},i=u=>u.done?r(u.value):Promise.resolve(u.value).then(a,o);i((t=t.apply(n,e)).next())});import{$ as wn,a0 as On,a1 as kh}from"./h5-ai-sport.v0.0.0.index.95bda2e2.1684318478178.js";function bc(n,e){for(var t=0;t<e.length;t++){const r=e[t];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in n)){const a=Object.getOwnPropertyDescriptor(r,s);a&&Object.defineProperty(n,s,a.get?a:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eb=1e-7,Rb=1e-4;class Nh{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class wc{refCount(e){return on("refCount")}incRef(e){return on("incRef")}timerAvailable(){return!0}time(e){return on("time")}read(e){return on("read")}readSync(e){return on("readSync")}readToGPU(e,t){return on("readToGPU")}numDataIds(){return on("numDataIds")}disposeData(e,t){return on("disposeData")}write(e,t,r){return on("write")}move(e,t,r,s,a){return on("move")}memory(){return on("memory")}floatPrecision(){return on("floatPrecision")}epsilon(){return this.floatPrecision()===32?Eb:Rb}dispose(){return on("dispose")}}function on(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function to(n,e,t){return Math.max(n,Math.min(e,t))}function vc(n){return n%2===0?n:n+1}function Bs(n,e,t){const r=n[e];n[e]=n[t],n[t]=r}function Ab(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function I(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Zt(n,e,t=""){I(pt(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function Ts(n){I(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ms(n,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(n)||Mn(n)&&!t)for(let r=0;r<n.length;++r)ms(n[r],e,t);else e.push(n);return e}function V(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function pt(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function gs(n){return n%1===0}function fu(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function ls(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function zp(n,e=s=>0,t,r=setTimeout){return new Promise((s,a)=>{let o=0;const i=()=>{if(n()){s();return}o++;const u=e(o);if(t!=null&&o>=t){a();return}r(i,u)};i()})}function Eh(n,e){let t=1,r=-1;for(let a=0;a<n.length;++a)if(n[a]>=0)t*=n[a];else if(n[a]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(n[a]<0)throw Error(`Shapes can not be < 0. Found ${n[a]} at dim ${a}`);if(r===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const s=n.slice();return s[r]=e/t,s}function ct(n,e){const t=e.length;return n=n==null?e.map((r,s)=>s):[].concat(n),I(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),I(n.every(r=>gs(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function yr(n,e){const t=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,a=e==null||s?null:ct(e,n).sort();let o=0;for(let i=0;i<n.length;++i){if(a!=null){if(a[o]===i&&n[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${n[i]}' is not 1`);(a[o]==null||a[o]>i)&&n[i]===1&&(t.push(n[i]),r.push(i)),a[o]<=i&&o++}n[i]!==1&&(t.push(n[i]),r.push(i))}return{newShape:t,keptDims:r}}function Zn(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${n}`);return t}function zt(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function Ob(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function Fb(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function Db(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function Mn(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}function Qs(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function Pb(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function $o(n){return typeof n=="string"||n instanceof String}function Lb(n){return typeof n=="boolean"}function Mb(n){return typeof n=="number"}function Io(n){return Array.isArray(n)?Io(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":Mb(n)?"float32":$o(n)?"string":Lb(n)?"bool":"float32"}function Gp(n){return!!(n&&n.constructor&&n.call&&n.apply)}function mu(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function Ve(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function Rh(n,e,t,r=!1){const s=new Array;if(e.length===1){const a=e[0]*(r?2:1);for(let o=0;o<a;o++)s[o]=t[n+o]}else{const a=e[0],o=e.slice(1),i=o.reduce((u,l)=>u*l)*(r?2:1);for(let u=0;u<a;u++)s[u]=Rh(n+u*i,o,t,r)}return s}function gu(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((s,a)=>s*a)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return Rh(0,n,e,t)}function Ah(n,e){const t=dr(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function dr(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function Oh(n){n.forEach(e=>{I(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function yu(n,e,t){if(e===0)return 0;if(e===1)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=t[s]*n[s];return r}function Sc(n,e,t){if(e===0)return[];if(e===1)return[n];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/t[s]),n-=r[s]*t[s];return r[r.length-1]=n,r}function ys(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hp="tfjsflags";class Bb{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Vb,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(L().getBool("IS_TEST")||L().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];L().getBool("IS_TEST")||L().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}getAsync(e){return se(this,null,function*(){return e in this.flags?this.flags[e]:(this.flags[e]=yield this.evaluateFlag(e),this.flags[e])})}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(ys(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;const e=this.getQueryParams(this.global.location.search);Hp in e&&e[Hp].split(",").forEach(r=>{const[s,a]=r.split(":");this.urlFlags[s]=Ub(s,a)})}}function Vb(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(Wb(e,r[0],r[1]),r.join("="))),e}function Wb(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function Ub(n,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${n}.`)}function L(){return Fh}let Fh=null;function zb(n){Fh=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Hi;function Dh(){if(Hi==null){let n;if(typeof window!="undefined")n=window;else if(typeof global!="undefined")n=global;else if(typeof process!="undefined")n=process;else if(typeof self!="undefined")n=self;else throw new Error("Could not find a global object");Hi=n}return Hi}function Gb(){const n=Dh();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function $c(n,e){const t=Gb();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const Ic="Abs",Ph="Acos",Lh="Acosh",To="Add",Co="AddN",_o="All",ko="Any",No="ArgMax",Mh="ArgMin",Bh="Asin",Vh="Asinh",Wh="Atan",Uh="Atanh",zh="Atan2",Eo="AvgPool",Hb="AvgPoolGrad",Gh="AvgPool3D",jb="AvgPool3DGrad",Ro="BatchMatMul",Tc="BatchToSpaceND",Hh="Bincount",jh="BroadcastArgs",Ao="Cast",Cc="Ceil",Oo="ClipByValue",qh="Complex",Kh="ComplexAbs",_c="Concat",Fo="Conv2D",Xh="Conv2DBackpropFilter",Do="Conv2DBackpropInput",Yh="Conv3D",qb="Conv3DBackpropFilterV2",Qh="Conv3DBackpropInputV2",kc="Cos",Nc="Cosh",Po="Cumprod",Lo="Cumsum",Mo="CropAndResize",Zh="DenseBincount",Bo="DepthToSpace",Vo="DepthwiseConv2dNative",Jh="DepthwiseConv2dNativeBackpropFilter",ef="DepthwiseConv2dNativeBackpropInput",tf="Diag",nf="Dilation2D",Ec="RealDiv",rf="Einsum",Rc="Elu",Kb="EluGrad",sf="Erf",Ac="Equal",Oc="Exp",Fc="ExpandDims",af="Expm1",of="FFT",Dc="Fill",Wo="FlipLeftRight",Pc="Floor",Lc="FloorDiv",Uo="FusedBatchNorm",Mc="GatherV2",zo="GatherNd",Bc="Greater",Vc="GreaterEqual",Go="Identity",uf="IFFT",cf="Imag",lf="IsFinite",pf="IsInf",df="IsNan",Ho="LeakyRelu",Wc="Less",Uc="LessEqual",hf="LinSpace",zc="Log",ff="Log1p",Gc="LogicalAnd",Hc="LogicalNot",jc="LogicalOr",Xb="LogicalXor",mf="LRN",Yb="LRNGrad",jo="Max",qc="Maximum",qo="MaxPool",Qb="MaxPoolGrad",gf="MaxPool3D",Zb="MaxPool3DGrad",yf="MaxPoolWithArgmax",Ko="Mean",Xo="Min",Kc="Minimum",Yo="MirrorPad",xf="Mod",bf="Multinomial",Xc="Multiply",Yc="Neg",Qc="NotEqual",Qo="NonMaxSuppressionV3",Zo="NonMaxSuppressionV4",Jo="NonMaxSuppressionV5",Zc="OnesLike",ei="OneHot",Jc="Pack",ti="PadV2",el="Pow",ni="Prelu",ri="Prod",wf="RaggedGather",vf="RaggedTensorToTensor",tl="Range",Sf="Real",$f="Reciprocal",nl="Relu",rl="Reshape",si="ResizeNearestNeighbor",Jb="ResizeNearestNeighborGrad",ai="ResizeBilinear",e0="ResizeBilinearGrad",sl="Relu6",oi="Reverse",al="Round",ol="Rsqrt",ii="ScatterNd",If="SearchSorted",il="Select",Tf="Selu",ul="Slice",cl="Sin",Cf="Sinh",_f="Sign",ll="Sigmoid",kf="Softplus",pl="Sqrt",ui="Sum",dl="SpaceToBatchND",hl="SplitV",ci="Softmax",fl="SparseFillEmptyRows",li="SparseReshape",ml="SparseSegmentMean",gl="SparseSegmentSum",Nf="SparseToDense",yl="SquaredDifference",Ef="Square",pi="StridedSlice",xl="StringNGrams",bl="StringSplit",wl="StringToHashBucketFast",vl="Sub",Sl="Tan",$l="Tanh",ga="Tile",di="TopK",hi="Transform",ps="Transpose",Rf="Unique",Il="Unpack",Af="UnsortedSegmentSum",Tl="ZerosLike",fi="Step",xu="FromPixels",mi="RotateWithOffset",Zs="_FusedMatMul",Js="FusedConv2D",ea="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cn(...n){L().getBool("IS_TEST")||L().getBool("PROD")||console.warn(...n)}function t0(...n){L().getBool("IS_TEST")||L().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const no=$c("kernelRegistry",()=>new Map),n0=$c("gradRegistry",()=>new Map);function bu(n,e){const t=Ff(n,e);return no.get(t)}function jp(n){return n0.get(n)}function qp(n){const e=no.entries(),t=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[a,o]=s,[i]=a.split("_");i===n&&t.push(o)}return t}function Of(n){const{kernelName:e,backendName:t}=n,r=Ff(e,t);no.has(r)&&Cn(`The kernel '${e}' for backend '${t}' is already registered`),no.set(r,n)}function Ff(n,e){return`${e}_${n}`}var wu=Qe,gn=null;try{gn=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(n){}function Qe(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}Qe.prototype.__isLong__;Object.defineProperty(Qe.prototype,"__isLong__",{value:!0});function Jt(n){return(n&&n.__isLong__)===!0}Qe.isLong=Jt;var Kp={},Xp={};function Kr(n,e){var t,r,s;return e?(n>>>=0,(s=0<=n&&n<256)&&(r=Xp[n],r)?r:(t=Ze(n,(n|0)<0?-1:0,!0),s&&(Xp[n]=t),t)):(n|=0,(s=-128<=n&&n<128)&&(r=Kp[n],r)?r:(t=Ze(n,n<0?-1:0,!1),s&&(Kp[n]=t),t))}Qe.fromInt=Kr;function yn(n,e){if(isNaN(n))return e?Or:xn;if(e){if(n<0)return Or;if(n>=Df)return Mf}else{if(n<=-Qp)return Xt;if(n+1>=Qp)return Lf}return n<0?yn(-n,e).neg():Ze(n%xs|0,n/xs|0,e)}Qe.fromNumber=yn;function Ze(n,e,t){return new Qe(n,e,t)}Qe.fromBits=Ze;var ro=Math.pow;function Cl(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return xn;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var r;if((r=n.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return Cl(n.substring(1),e,t).neg();for(var s=yn(ro(t,8)),a=xn,o=0;o<n.length;o+=8){var i=Math.min(8,n.length-o),u=parseInt(n.substring(o,o+i),t);if(i<8){var l=yn(ro(t,i));a=a.mul(l).add(yn(u))}else a=a.mul(s),a=a.add(yn(u))}return a.unsigned=e,a}Qe.fromString=Cl;function kn(n,e){return typeof n=="number"?yn(n,e):typeof n=="string"?Cl(n,e):Ze(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}Qe.fromValue=kn;var Yp=1<<16,r0=1<<24,xs=Yp*Yp,Df=xs*xs,Qp=Df/2,Zp=Kr(r0),xn=Kr(0);Qe.ZERO=xn;var Or=Kr(0,!0);Qe.UZERO=Or;var cs=Kr(1);Qe.ONE=cs;var Pf=Kr(1,!0);Qe.UONE=Pf;var vu=Kr(-1);Qe.NEG_ONE=vu;var Lf=Ze(-1,2147483647,!1);Qe.MAX_VALUE=Lf;var Mf=Ze(-1,-1,!0);Qe.MAX_UNSIGNED_VALUE=Mf;var Xt=Ze(0,-2147483648,!1);Qe.MIN_VALUE=Xt;var Z=Qe.prototype;Z.toInt=function(){return this.unsigned?this.low>>>0:this.low};Z.toNumber=function(){return this.unsigned?(this.high>>>0)*xs+(this.low>>>0):this.high*xs+(this.low>>>0)};Z.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Xt)){var t=yn(e),r=this.div(t),s=r.mul(t).sub(this);return r.toString(e)+s.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var a=yn(ro(e,6),this.unsigned),o=this,i="";;){var u=o.div(a),l=o.sub(u.mul(a)).toInt()>>>0,c=l.toString(e);if(o=u,o.isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}};Z.getHighBits=function(){return this.high};Z.getHighBitsUnsigned=function(){return this.high>>>0};Z.getLowBits=function(){return this.low};Z.getLowBitsUnsigned=function(){return this.low>>>0};Z.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Xt)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return this.high!=0?t+33:t+1};Z.isZero=function(){return this.high===0&&this.low===0};Z.eqz=Z.isZero;Z.isNegative=function(){return!this.unsigned&&this.high<0};Z.isPositive=function(){return this.unsigned||this.high>=0};Z.isOdd=function(){return(this.low&1)===1};Z.isEven=function(){return(this.low&1)===0};Z.equals=function(e){return Jt(e)||(e=kn(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};Z.eq=Z.equals;Z.notEquals=function(e){return!this.eq(e)};Z.neq=Z.notEquals;Z.ne=Z.notEquals;Z.lessThan=function(e){return this.comp(e)<0};Z.lt=Z.lessThan;Z.lessThanOrEqual=function(e){return this.comp(e)<=0};Z.lte=Z.lessThanOrEqual;Z.le=Z.lessThanOrEqual;Z.greaterThan=function(e){return this.comp(e)>0};Z.gt=Z.greaterThan;Z.greaterThanOrEqual=function(e){return this.comp(e)>=0};Z.gte=Z.greaterThanOrEqual;Z.ge=Z.greaterThanOrEqual;Z.compare=function(e){if(Jt(e)||(e=kn(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};Z.comp=Z.compare;Z.negate=function(){return!this.unsigned&&this.eq(Xt)?Xt:this.not().add(cs)};Z.neg=Z.negate;Z.add=function(e){Jt(e)||(e=kn(e));var t=this.high>>>16,r=this.high&65535,s=this.low>>>16,a=this.low&65535,o=e.high>>>16,i=e.high&65535,u=e.low>>>16,l=e.low&65535,c=0,p=0,d=0,h=0;return h+=a+l,d+=h>>>16,h&=65535,d+=s+u,p+=d>>>16,d&=65535,p+=r+i,c+=p>>>16,p&=65535,c+=t+o,c&=65535,Ze(d<<16|h,c<<16|p,this.unsigned)};Z.subtract=function(e){return Jt(e)||(e=kn(e)),this.add(e.neg())};Z.sub=Z.subtract;Z.multiply=function(e){if(this.isZero())return xn;if(Jt(e)||(e=kn(e)),gn){var t=gn.mul(this.low,this.high,e.low,e.high);return Ze(t,gn.get_high(),this.unsigned)}if(e.isZero())return xn;if(this.eq(Xt))return e.isOdd()?Xt:xn;if(e.eq(Xt))return this.isOdd()?Xt:xn;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(Zp)&&e.lt(Zp))return yn(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,s=this.high&65535,a=this.low>>>16,o=this.low&65535,i=e.high>>>16,u=e.high&65535,l=e.low>>>16,c=e.low&65535,p=0,d=0,h=0,f=0;return f+=o*c,h+=f>>>16,f&=65535,h+=a*c,d+=h>>>16,h&=65535,h+=o*l,d+=h>>>16,h&=65535,d+=s*c,p+=d>>>16,d&=65535,d+=a*l,p+=d>>>16,d&=65535,d+=o*u,p+=d>>>16,d&=65535,p+=r*c+s*l+a*u+o*i,p&=65535,Ze(h<<16|f,p<<16|d,this.unsigned)};Z.mul=Z.multiply;Z.divide=function(e){if(Jt(e)||(e=kn(e)),e.isZero())throw Error("division by zero");if(gn){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?gn.div_u:gn.div_s)(this.low,this.high,e.low,e.high);return Ze(t,gn.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Or:xn;var r,s,a;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Or;if(e.gt(this.shru(1)))return Pf;a=Or}else{if(this.eq(Xt)){if(e.eq(cs)||e.eq(vu))return Xt;if(e.eq(Xt))return cs;var o=this.shr(1);return r=o.div(e).shl(1),r.eq(xn)?e.isNegative()?cs:vu:(s=this.sub(e.mul(r)),a=r.add(s.div(e)),a)}else if(e.eq(Xt))return this.unsigned?Or:xn;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=xn}for(s=this;s.gte(e);){r=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(r)/Math.LN2),u=i<=48?1:ro(2,i-48),l=yn(r),c=l.mul(e);c.isNegative()||c.gt(s);)r-=u,l=yn(r,this.unsigned),c=l.mul(e);l.isZero()&&(l=cs),a=a.add(l),s=s.sub(c)}return a};Z.div=Z.divide;Z.modulo=function(e){if(Jt(e)||(e=kn(e)),gn){var t=(this.unsigned?gn.rem_u:gn.rem_s)(this.low,this.high,e.low,e.high);return Ze(t,gn.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};Z.mod=Z.modulo;Z.rem=Z.modulo;Z.not=function(){return Ze(~this.low,~this.high,this.unsigned)};Z.and=function(e){return Jt(e)||(e=kn(e)),Ze(this.low&e.low,this.high&e.high,this.unsigned)};Z.or=function(e){return Jt(e)||(e=kn(e)),Ze(this.low|e.low,this.high|e.high,this.unsigned)};Z.xor=function(e){return Jt(e)||(e=kn(e)),Ze(this.low^e.low,this.high^e.high,this.unsigned)};Z.shiftLeft=function(e){return Jt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Ze(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Ze(0,this.low<<e-32,this.unsigned)};Z.shl=Z.shiftLeft;Z.shiftRight=function(e){return Jt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Ze(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Ze(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};Z.shr=Z.shiftRight;Z.shiftRightUnsigned=function(e){if(Jt(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var r=this.low;return Ze(r>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?Ze(t,0,this.unsigned):Ze(t>>>e-32,0,this.unsigned)};Z.shru=Z.shiftRightUnsigned;Z.shr_u=Z.shiftRightUnsigned;Z.toSigned=function(){return this.unsigned?Ze(this.low,this.high,!1):this};Z.toUnsigned=function(){return this.unsigned?this:Ze(this.low,this.high,!0)};Z.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};Z.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};Z.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};Qe.fromBytes=function(e,t,r){return r?Qe.fromBytesLE(e,t):Qe.fromBytesBE(e,t)};Qe.fromBytesLE=function(e,t){return new Qe(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};Qe.fromBytesBE=function(e,t){return new Qe(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};const s0=bc({__proto__:null,default:wu},[wu]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nr=wu||s0;function gi(n){return Nr.fromString(n,!0,16)}const Bf=gi("c3a5c85c97cb3127"),kr=gi("b492b66fbe98f273"),Dt=gi("9ae16a3b2f90404f");function Su(n){return n.xor(n.shru(47))}function Vf(n,e,t){const r=n.slice(e,e+t);return Nr.fromBytes(Array.from(r),!0,!0)}function qe(n,e){return Vf(n,e,8)}function Jp(n,e){return Vf(n,e,4)}function yt(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function lr(n,e,t=gi("9ddfea08eb382d69")){let r=n.xor(e).mul(t);r=r.xor(r.shru(47));let s=e.xor(r).mul(t);return s=s.xor(s.shru(47)),s=s.mul(t),s}function a0(n,e,t,r,s,a){s=s.add(n),a=yt(a.add(s).add(r),21);const o=s;return s=s.add(e),s=s.add(t),a=a.add(yt(s,44)),[s.add(r),a.add(o)]}function Va(n,e,t,r){return a0(qe(n,e),qe(n,e+8),qe(n,e+16),qe(n,e+24),t,r)}function o0(n,e=n.length){if(e>=8){const t=Dt.add(e*2),r=qe(n,0).add(Dt),s=qe(n,e-8),a=yt(s,37).mul(t).add(r),o=yt(r,25).add(s).mul(t);return lr(a,o,t)}if(e>=4){const t=Dt.add(e*2),r=Jp(n,0);return lr(r.shl(3).add(e),Jp(n,e-4),t)}if(e>0){const t=n[0],r=n[e>>1],s=n[e-1],a=t+(r<<8),o=e+(s<<2);return Su(Dt.mul(a).xor(Bf.mul(o))).mul(Dt)}return Dt}function i0(n,e=n.length){const t=Dt.add(e*2),r=qe(n,0).mul(kr),s=qe(n,8),a=qe(n,e-8).mul(t),o=qe(n,e-16).mul(Dt);return lr(yt(r.add(s),43).add(yt(a,30)).add(o),r.add(yt(s.add(Dt),18)).add(a),t)}function u0(n,e=n.length){const t=Dt.add(e*2),r=qe(n,0).mul(Dt),s=qe(n,8),a=qe(n,e-8).mul(t),o=qe(n,e-16).mul(Dt),i=yt(r.add(s),43).add(yt(a,30)).add(o),u=lr(i,r.add(yt(s.add(Dt),18)).add(a),t),l=qe(n,16).mul(t),c=qe(n,24),p=i.add(qe(n,e-32)).mul(t),d=u.add(qe(n,e-24)).mul(t);return lr(yt(l.add(c),43).add(yt(p,30)).add(d),l.add(yt(c.add(r),18)).add(p),t)}function c0(n,e=n.length){const t=Nr.fromNumber(81,!0);if(e<=32)return e<=16?o0(n,e):i0(n,e);if(e<=64)return u0(n,e);let r=t,s=t.mul(kr).add(113),a=Su(s.mul(Dt).add(113)).mul(Dt),o=[Nr.UZERO,Nr.UZERO],i=[Nr.UZERO,Nr.UZERO];r=r.mul(Dt).add(qe(n,0));let u=0;const l=(e-1>>6)*64,c=l+(e-1&63)-63;do r=yt(r.add(s).add(o[0]).add(qe(n,u+8)),37).mul(kr),s=yt(s.add(o[1]).add(qe(n,u+48)),42).mul(kr),r=r.xor(i[1]),s=s.add(o[0]).add(qe(n,u+40)),a=yt(a.add(i[0]),33).mul(kr),o=Va(n,u,o[1].mul(kr),r.add(i[0])),i=Va(n,u+32,a.add(i[1]),s.add(qe(n,u+16))),[a,r]=[r,a],u+=64;while(u!==l);const p=kr.add(a.and(255).shl(1));return u=c,i[0]=i[0].add(e-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),r=yt(r.add(s).add(o[0]).add(qe(n,u+8)),37).mul(p),s=yt(s.add(o[1]).add(qe(n,u+48)),42).mul(p),r=r.xor(i[1].mul(9)),s=s.add(o[0].mul(9).add(qe(n,u+40))),a=yt(a.add(i[0]),33).mul(p),o=Va(n,u,o[1].mul(p),r.add(i[0])),i=Va(n,u+32,a.add(i[1]),s.add(qe(n,u+16))),[a,r]=[r,a],lr(lr(o[0],i[0],p).add(Su(s).mul(Bf)).add(a),lr(o[1],i[1],p).add(r),p)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cs(n,e){return e==="string"?Mr(n):yi([n],e)}function l0(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function yi(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=ms(n)),L().getBool("DEBUG")&&Ob(n,e),l0(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function un(){return L().platform.now()}function p0(n,e){return L().platform.fetch(n,e)}function Mr(n,e="utf-8"){return e=e||"utf-8",L().platform.encode(n,e)}function bs(n,e="utf-8"){return e=e||"utf-8",L().platform.decode(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d0{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new f0)}profileKernel(e,t,r){let s;const a=()=>{s=r()};let o;const i=un();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(a);else{a();for(const l of s)l.dataSync();o=Promise.resolve({kernelMs:un()-i})}if(L().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<s.length;l++){const c=s[l];c.data().then(p=>{h0(p,c.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:o.then(l=>l.kernelMs),extraInfo:o.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:s,inputs:a,extraInfo:o}=e;r.forEach(i=>{Promise.all([i.data(),s,o]).then(u=>{this.logger.logKernelProfile(t,i,u[0],u[1],a,u[2])})})}}function h0(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}class f0{logKernelProfile(e,t,r,s,a,o){const i=typeof s=="number"?ls(`${s}ms`,9):s.error,u=ls(e,25),l=t.rank,c=t.size,p=ls(t.shape.toString(),14);let d="";for(const h in a){const f=a[h];if(f!=null){const m=f.shape||t.shape,g=m.length;d+=`${h}: ${g}D ${g>0?m:""} `}}console.log(`%c${u}	%c${i}	%c${l}D ${p}	%c${c}	%c${d}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m0(n,e,t){const r={},s={};for(let u=0;u<e.length;u++)r[e[u].id]=!0;for(let u=0;u<n.length;u++){const l=n[u],c=l.inputs;for(const p in c){const d=c[p];let h=!1;for(let f=0;f<e.length;f++)if(r[d.id]){l.outputs.forEach(m=>r[m.id]=!0),h=!0,s[l.id]=!0;break}if(h)break}}const a={};a[t.id]=!0;const o={};for(let u=n.length-1;u>=0;u--){const l=n[u],c=l.inputs;for(let p=0;p<l.outputs.length;p++)if(a[l.outputs[p].id]){for(const d in c)a[c[d].id]=!0,o[l.id]=!0;break}}const i=[];for(let u=0;u<n.length;u++){const l=n[u];if(s[l.id]&&o[l.id]){const c={};for(const d in l.inputs){const h=l.inputs[d];r[h.id]&&(c[d]=h)}const p=Object.assign({},l);p.inputs=c,p.outputs=l.outputs,i.push(p)}}return i}function g0(n,e,t,r){for(let s=e.length-1;s>=0;s--){const a=e[s],o=[];if(a.outputs.forEach(u=>{const l=n[u.id];l!=null?o.push(l):o.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const i=a.gradient(o);for(const u in a.inputs){if(!(u in i))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(i)}.`);const l=t(()=>i[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);const c=a.inputs[u];if(!pt(l.shape,c.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${c.shape}'`);if(n[c.id]==null)n[c.id]=l;else{const p=n[c.id];n[c.id]=r(p,l),p.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ed=20,Vs=3,ji=7;function y0(n,e,t,r){const s=Ve(e),a=x0(n,e,t,s),o=e.length,i=Ya(n,e,t,s,a),u=["Tensor"];return r&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${o}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(i.map(l=>"    "+l).join(`
`)),u.join(`
`)}function x0(n,e,t,r){const s=V(e),a=r[r.length-1],o=new Array(a).fill(0),i=e.length,u=t==="complex64"?Gs(n):n;if(i>1)for(let l=0;l<s/a;l++){const c=l*a;for(let p=0;p<a;p++)o[p]=Math.max(o[p],zs(u[c+p],0,t).length)}return o}function zs(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(ji))} + ${parseFloat(n[1].toFixed(ji))}j`:$o(n)?r=`'${n}'`:t==="bool"?r=Wf(n):r=parseFloat(n.toFixed(ji)).toString(),ls(r,e)}function Wf(n){return n===0?"false":"true"}function Ya(n,e,t,r,s,a=!0){const o=t==="complex64"?2:1,i=e[0],u=e.length;if(u===0){if(t==="complex64"){const m=Gs(n);return[zs(m[0],0,t)]}return t==="bool"?[Wf(n[0])]:[n[0].toString()]}if(u===1){if(i>ed){const g=Vs*o;let y=Array.from(n.slice(0,g)),x=Array.from(n.slice((i-Vs)*o,i*o));return t==="complex64"&&(y=Gs(y),x=Gs(x)),["["+y.map((w,v)=>zs(w,s[v],t)).join(", ")+", ..., "+x.map((w,v)=>zs(w,s[i-Vs+v],t)).join(", ")+"]"]}return["["+(t==="complex64"?Gs(n):Array.from(n)).map((g,y)=>zs(g,s[y],t)).join(", ")+"]"]}const l=e.slice(1),c=r.slice(1),p=r[0]*o,d=[];if(i>ed){for(let m=0;m<Vs;m++){const g=m*p,y=g+p;d.push(...Ya(n.slice(g,y),l,t,c,s,!1))}d.push("...");for(let m=i-Vs;m<i;m++){const g=m*p,y=g+p;d.push(...Ya(n.slice(g,y),l,t,c,s,m===i-1))}}else for(let m=0;m<i;m++){const g=m*p,y=g+p;d.push(...Ya(n.slice(g,y),l,t,c,s,m===i-1))}const h=u===2?",":"";d[0]="["+d[0]+h;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+h;let f=`,
`;for(let m=2;m<u;m++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(a?"":f),d}function Gs(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ta{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=V(e),r!=null){const s=r.length;I(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||zt(t,this.size),this.strides=Ve(e)}set(e,...t){t.length===0&&(t=[0]),I(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const s of e){if(s<0||s>=this.shape[t]){const a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}t++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return In().makeTensor(this.values,this.shape,this.dtype)}}let In=null,is=null;function b0(n){In=n}function w0(n){is=n}class ot{constructor(e,t,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=V(e),this.strides=Ve(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){return se(this,null,function*(){const e=yield this.data();return is.buffer(this.shape,this.dtype,e)})}bufferSync(){return is.buffer(this.shape,this.dtype,this.dataSync())}array(){return se(this,null,function*(){const e=yield this.data();return gu(this.shape,e,this.dtype==="complex64")})}arraySync(){return gu(this.shape,this.dataSync(),this.dtype==="complex64")}data(){return se(this,null,function*(){this.throwIfDisposed();const e=In().read(this.dataId);if(this.dtype==="string"){const t=yield e;try{return t.map(r=>bs(r))}catch(r){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})}dataToGPU(e){return this.throwIfDisposed(),In().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=In().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>bs(t))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}bytes(){return se(this,null,function*(){this.throwIfDisposed();const e=yield In().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)})}dispose(){this.isDisposed||(In().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return is.print(this,e)}clone(){return this.throwIfDisposed(),is.clone(this)}toString(e=!1){const t=this.dataSync();return y0(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),is.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),In().makeVariable(this,e,t,r)}}Object.defineProperty(ot,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function v0(){return $c("Tensor",()=>ot)}v0();class $u extends ot{constructor(e,t,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!pt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);In().disposeTensor(this),this.dataId=e.dataId,In().incRef(this,null)}dispose(){In().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty($u,Symbol.hasInstance,{value:n=>n instanceof ot&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var td;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(td||(td={}));var Iu;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(Iu||(Iu={}));var Tu;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(Tu||(Tu={}));var Cu;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(Cu||(Cu={}));var _u;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(_u||(_u={}));const S0={float32:Cu,int32:Iu,bool:Tu,complex64:_u};function Bn(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return S0[n][e]}function _l(n){return Bn(n,"int32")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dt(n,e){if(n.dtype===e.dtype)return[n,e];const t=Bn(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function $0(n,e){I(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function Uf(n){const e=[];return zf(n,e,new Set),e}function zf(n,e,t){if(n==null)return;if(n instanceof ot){e.push(n);return}if(!I0(n))return;const r=n;for(const s in r){const a=r[s];t.has(a)||(t.add(a),zf(a,e,t))}}function I0(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qi(n){return n.kernelName!=null}class nd{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class ws{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new nd}ready(){return se(this,null,function*(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(yield this.initializeBackend(r).success){yield this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")})}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(Cn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}setBackend(e){return se(this,null,function*(){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?yield t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new d0(this.backendInstance),!0})}setupRegisteredKernels(){qp(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){qp(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof wc)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,a=r.then(o=>s<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Cn(`Initialization of backend ${e} failed`),Cn(o.stack||o.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return Cn(`Initialization of backend ${e} failed`),Cn(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:s,asyncInit:a}=this.initializeBackend(r);if(a||s)return{name:r,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),s=r.backend,a=this.readSync(t),o=s.refCount(t);s.disposeData(t,!0),r.backend=e,e.move(t,a,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=t(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,t,r){e();try{const s=r();return t(),s}catch(s){throw t(),s}}nextTensorId(){return ws.nextTensorId++}nextVariableId(){return ws.nextVariableId++}clone(e){const t=O.runKernel(Go,{x:e}),r={x:e},s=o=>({x:()=>{const i="float32",u={x:o},l={dtype:i};return O.runKernel(Ao,u,l)}}),a=[];return this.addTapeNode(this.state.activeScope.name,r,[t],s,a,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!(bu(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const s=this.backend.numDataIds();let a=0;r.forEach(u=>{a+=u.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=s-t-a-o;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const s=this.isTapeOn(),a=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let u;const l=qi(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(qi(e)){const{kernelName:f,inputs:m,attrs:g}=e;this.backendName==null&&this.backend;const y=bu(f,this.backendName);I(y!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),i=()=>{const x=this.backend.numDataIds();u=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const w=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,x,w);const v=w.map($=>$.rank!=null?$:this.makeTensorFromTensorInfo($));if(s){const $=this.getTensorsForGradient(f,m,v);r=this.saveTensorsForBackwardMode($)}return v}}else{const{forwardFunc:f}=e,m=g=>{s&&(r=g.map(y=>this.keep(this.clone(y))))};i=()=>{const g=this.backend.numDataIds();u=this.tidy(()=>f(this.backend,m));const y=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,g,y),y}}const{inputs:c,attrs:p}=e,d=qi(e)?null:e.backwardsFunc;let h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=i():(h=this.profiler.profileKernel(l,c,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs)}),s&&this.addTapeNode(l,c,t,d,r,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(f=>c[f]!=null?c[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const s=jp(e);if(s!=null){const a=s.inputsToSave||[],o=s.outputsToSave||[];let i;s.saveAllInputs?(I(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(t).map(l=>t[l])):i=a.map(l=>t[l]);const u=r.filter((l,c)=>o[c]);return i.concat(u)}return[]}makeTensor(e,t,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let a=e;r==="string"&&$o(e[0])&&(a=e.map(u=>Mr(u)));const o=s.write(a,t,r),i=new ot(t,r,o,this.nextTensorId());if(this.trackTensor(i,s),r==="string"){const u=this.state.tensorInfo.get(o),l=Pb(a);this.state.numBytes+=l-u.bytes,u.bytes=l}return i}makeTensorFromDataId(e,t,r,s){r=r||"float32";const a={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(a,s)}makeTensorFromTensorInfo(e,t){const{dataId:r,shape:s,dtype:a}=e,o=new ot(s,a,r,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const a=new $u(e,t,r,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*Qs(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof $u||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*Qs(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){return se(this,null,function*(){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=yield e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=yield s.kernelTimeMs,s.extraInfo=yield s.extraInfo;return this.state.activeProfile})}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,s,a,o){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:a},u=jp(e);u!=null&&(s=u.gradFunc),s!=null&&(i.gradient=l=>(l=l.map((c,p)=>{if(c==null){const d=r[p],h=dr(d.size,d.dtype);return this.makeTensor(h,d.shape,d.dtype)}return c}),s(l.length>1?l:l[0],a,o))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Uf(e),r=new Set(t.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const o=this.state.activeScope.track[a];!o.kept&&!r.has(o.id)&&o.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(a=>{!a.kept&&a.scopeId===s.id&&this.track(a)})}gradients(e,t,r,s=!1){if(I(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));I(a instanceof ot,()=>"The result y returned by f() must be a tensor.");const o=m0(this.state.activeTape,t,a);if(!s&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const i={};i[a.id]=r==null?T0(a.shape):r,g0(i,o,l=>this.tidy(l),C0);const u=t.map(l=>i[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const c of l.saved)c.dispose()}),this.state.activeTape=null),{value:a,grads:u}})}customGrad(e){return I(Gp(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{I(t.every(i=>i instanceof ot),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};t.forEach((i,u)=>{s[u]=i});const a=(i,u)=>(r=e(...t,u),I(r.value instanceof ot,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),I(Gp(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(i,u)=>{const l=r.gradFunc(i,u),c=Array.isArray(l)?l:[l];I(c.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),I(c.every(d=>d instanceof ot),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const p={};return c.forEach((d,h)=>{p[h]=()=>d}),p};return this.runKernelFunc({forwardFunc:a,backwardsFunc:o,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}time(e){return se(this,null,function*(){const t=un(),r=yield this.backend.time(e);return r.wallMs=un()-t,r})}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new nd;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}ws.nextTensorId=0;ws.nextVariableId=0;function T0(n){const e=Ah(V(n),"float32");return O.makeTensor(e,n,"float32")}function Gf(){const n=Dh();if(n._tfengine==null){const e=new Bb(n);n._tfengine=new ws(e)}return zb(n._tfengine.ENV),b0(()=>n._tfengine),n._tfengine}const O=Gf();function C0(n,e){const t={a:n,b:e};return O.runKernel(To,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _0(){return typeof navigator!="undefined"&&navigator!=null}function Hf(n){if(n||_0()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window!="undefined"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function jf(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yt=L();Yt.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Yt.registerFlag("IS_BROWSER",()=>jf());Yt.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");Yt.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Yt.registerFlag("PROD",()=>!1);Yt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Yt.getBool("DEBUG"));Yt.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Yt.registerFlag("IS_TEST",()=>!1);Yt.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);Yt.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Yt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);Yt.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Yt.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xr(n,e){let t=n;if(Mn(n))return e==="string"?[]:[n.length];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||Mn(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&L().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&qf(n,r,[]),r}function qf(n,e,t){if(t=t||[],!Array.isArray(n)&&!Mn(n)){I(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}I(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),I(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let s=0;s<n.length;++s)qf(n[s],r,t.concat(s))}function rd(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function S(n,e,t,r="numeric"){if(n instanceof ot)return rd(r,n.dtype,e,t),n;let s=Io(n);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),rd(r,s,e,t),n==null||!Mn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const u=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}const a=xr(n,s);!Mn(n)&&!Array.isArray(n)&&(n=[n]);const i=s!=="string"?yi(n,s):ms(n,[],!0);return O.makeTensor(i,a,s)}function so(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((a,o)=>S(a,`${e}[${o}]`,t,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kf="__op";function E(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+Kf;const s=(...a)=>{O.startScope(t);try{const o=r(...a);return ys(o)&&console.error("Cannot return a Promise inside of tidy."),O.endScope(o),o}catch(o){throw O.endScope(null),o}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k0(n,e){const t=S(n,"real","complex"),r=S(e,"imag","complex");Zt(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:t,imag:r};return O.runKernel(qh,s)}const hr=E({complex_:k0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function br(n,e,t,r){if(r==null&&(r=Io(n)),r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Mn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Oh(e);const s=V(e),a=V(t);I(s===a,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${a}`);for(let o=0;o<t.length;++o){const i=t[o],u=o===t.length-1?i!==V(e.slice(o)):!0;I(t[o]===e[o]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Mn(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?yi(n,r):ms(n,[],!0),O.makeTensor(n,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dn(n,e,t){const r=xr(n,t);return br(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ku={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ao=4;function N0(n,e){return se(this,null,function*(){const t=[],r=[],s=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<s.length;++o){const i=s[o],u=Array.isArray(n)?n[o].tensor:n[i];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${u.dtype}`);const l={name:i,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const c=new Promise(p=>se(this,null,function*(){const d=yield u.bytes(),h=d.reduce((g,y)=>g+y.length,0)+ao*d.length,f=new Uint8Array(h);let m=0;for(let g=0;g<d.length;g++){const y=d[g],x=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(x,m),m+=ao,f.set(y,m),m+=y.length}p(f)}));r.push(c)}else r.push(u.data());e!=null&&(l.group=e),t.push(l)}const a=yield Promise.all(r);return{data:E0(a),specs:t}})}function Xf(n,e){const t={};let r,s=0;for(const a of e){const o=a.name,i=a.dtype,u=a.shape,l=V(u);let c;if("quantization"in a){const p=a.quantization;if(p.dtype==="uint8"||p.dtype==="uint16"){if(!("min"in p&&"scale"in p))throw new Error(`Weight ${a.name} with quantization ${p.dtype} doesn't have corresponding metadata min and scale.`)}else if(p.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${a.name} is quantized with ${p.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${a.name} has unknown quantization dtype ${p.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const d=ku[p.dtype],h=n.slice(s,s+l*d),f=p.dtype==="uint8"?new Uint8Array(h):new Uint16Array(h);if(i==="float32")if(p.dtype==="uint8"||p.dtype==="uint16"){c=new Float32Array(f.length);for(let m=0;m<f.length;m++){const g=f[m];c[m]=g*p.scale+p.min}}else if(p.dtype==="float16")r===void 0&&(r=P0()),c=r(f);else throw new Error(`Unsupported quantization type ${p.dtype} for weight type float32.`);else if(i==="int32"){if(p.dtype!=="uint8"&&p.dtype!=="uint16")throw new Error(`Unsupported quantization type ${p.dtype} for weight type int32.`);c=new Int32Array(f.length);for(let m=0;m<f.length;m++){const g=f[m];c[m]=Math.round(g*p.scale+p.min)}}else throw new Error(`Unsupported dtype in weight '${o}': ${i}`);s+=l*d}else if(i==="string"){const p=V(a.shape);c=[];for(let d=0;d<p;d++){const h=new Uint32Array(n.slice(s,s+ao))[0];s+=ao;const f=new Uint8Array(n.slice(s,s+h));c.push(f),s+=h}}else{const p=ku[i],d=n.slice(s,s+l*p);if(i==="float32")c=new Float32Array(d);else if(i==="int32")c=new Int32Array(d);else if(i==="bool")c=new Uint8Array(d);else if(i==="complex64"){c=new Float32Array(d);const h=new Float32Array(c.length/2),f=new Float32Array(c.length/2);for(let y=0;y<h.length;y++)h[y]=c[y*2],f[y]=c[y*2+1];const m=Dn(h,u,"float32"),g=Dn(f,u,"float32");t[o]=hr(m,g),m.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${o}': ${i}`);s+=l*p}i!=="complex64"&&(t[o]=Dn(c,u,i))}return t}function E0(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(a=>{if(e+=a.byteLength,t.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const r=new Uint8Array(e);let s=0;return t.forEach(a=>{r.set(new Uint8Array(a.buffer),s),s+=a.byteLength}),r.buffer}const kl=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function sd(n){return kl?Buffer.byteLength(n):new Blob([n]).size}function R0(n){if(kl)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let r=0,s=e.length;r<s;r++)t+=String.fromCharCode(e[r]);return btoa(t)}function A0(n){if(kl){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t.set([e.charCodeAt(r)],r);return t.buffer}function Nl(n){if(n.length===1)return n[0];let e=0;n.forEach(s=>{e+=s.byteLength});const t=new Uint8Array(e);let r=0;return n.forEach(s=>{t.set(new Uint8Array(s),r),r+=s.byteLength}),t.buffer}function ad(n){const e="/";for(n=n.trim();n.endsWith(e);)n=n.slice(0,n.length-1);const t=n.split(e);return t[t.length-1]}function Yf(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function Qf(n,e,t){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(r.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=t}return n.signature!=null&&(r.signature=n.signature),n.userDefinedMetadata!=null&&(r.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(r.modelInitializer=n.modelInitializer),r}function El(n,e){return se(this,null,function*(){let t,r;return n.weightsManifest!=null&&([t,r]=yield e(n.weightsManifest)),Qf(n,t,r)})}function ya(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:sd(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:sd(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:n.weightData.byteLength}}function Zf(n){const e=[];for(const t of n)e.push(...t.weights);return e}function O0(){const n=t=>{let r=t<<13,s=0;for(;!(r&8388608);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function F0(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function D0(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function P0(){const n=O0(),e=F0(),t=D0();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let o=0;o<r.length;o++){const i=r[o],u=n[t[i>>10]+(i&1023)]+e[i>>10];a[o]=u}return new Float32Array(s)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class at{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return at.instance==null&&(at.instance=new at),at.instance}static registerSaveRouter(e){at.getInstance().saveRouters.push(e)}static registerLoadRouter(e){at.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return at.getHandlers(e,"save")}static getLoadHandlers(e,t){return at.getHandlers(e,"load",t)}static getHandlers(e,t,r){const s=[];return(t==="load"?at.getInstance().loadRouters:at.getInstance().saveRouters).forEach(o=>{const i=o(e,r);i!==null&&s.push(i)}),s}}const L0=n=>at.registerSaveRouter(n),M0=n=>at.registerLoadRouter(n),B0=n=>at.getSaveHandlers(n),V0=(n,e)=>at.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nu="tensorflowjs",Eu=1,Fr="models_store",ir="model_info_store";function Jf(){if(!L().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window=="undefined"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Ru(n){const e=n.result;e.createObjectStore(Fr,{keyPath:"modelPath"}),e.createObjectStore(ir,{keyPath:"modelPath"})}class Wr{constructor(e){if(this.indexedDB=Jf(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){return se(this,null,function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)})}load(){return se(this,null,function*(){return this.databaseAction(this.modelPath)})}databaseAction(e,t){return new Promise((r,s)=>{const a=this.indexedDB.open(Nu,Eu);a.onupgradeneeded=()=>Ru(a),a.onsuccess=()=>{const o=a.result;if(t==null){const i=o.transaction(Fr,"readonly"),l=i.objectStore(Fr).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return o.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(l.result.modelArtifacts)},l.onerror=c=>(o.close(),s(l.error)),i.oncomplete=()=>o.close()}else{const i=ya(t),u=o.transaction(ir,"readwrite");let l=u.objectStore(ir);const c=l.put({modelPath:this.modelPath,modelArtifactsInfo:i});let p;c.onsuccess=()=>{p=o.transaction(Fr,"readwrite");const h=p.objectStore(Fr).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i});h.onsuccess=()=>r({modelArtifactsInfo:i}),h.onerror=f=>{l=u.objectStore(ir);const m=l.delete(this.modelPath);m.onsuccess=()=>(o.close(),s(h.error)),m.onerror=g=>(o.close(),s(h.error))}},c.onerror=d=>(o.close(),s(c.error)),u.oncomplete=()=>{p==null?o.close():p.oncomplete=()=>o.close()}}},a.onerror=o=>s(a.error)})}}Wr.URL_SCHEME="indexeddb://";const em=n=>L().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Wr.URL_SCHEME)?W0(n.slice(Wr.URL_SCHEME.length)):null;at.registerSaveRouter(em);at.registerLoadRouter(em);function W0(n){return new Wr(n)}function U0(n){return n.startsWith(Wr.URL_SCHEME)?n.slice(Wr.URL_SCHEME.length):n}class z0{constructor(){this.indexedDB=Jf()}listModels(){return se(this,null,function*(){return new Promise((e,t)=>{const r=this.indexedDB.open(Nu,Eu);r.onupgradeneeded=()=>Ru(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(ir,"readonly"),i=a.objectStore(ir).getAll();i.onsuccess=()=>{const u={};for(const l of i.result)u[l.modelPath]=l.modelArtifactsInfo;e(u)},i.onerror=u=>(s.close(),t(i.error)),a.oncomplete=()=>s.close()},r.onerror=s=>t(r.error)})})}removeModel(e){return se(this,null,function*(){return e=U0(e),new Promise((t,r)=>{const s=this.indexedDB.open(Nu,Eu);s.onupgradeneeded=()=>Ru(s),s.onsuccess=()=>{const a=s.result,o=a.transaction(ir,"readwrite"),i=o.objectStore(ir),u=i.get(e);let l;u.onsuccess=()=>{if(u.result==null)return a.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=i.delete(e),p=()=>{l=a.transaction(Fr,"readwrite");const h=l.objectStore(Fr).delete(e);h.onsuccess=()=>t(u.result.modelArtifactsInfo),h.onerror=f=>r(u.error)};c.onsuccess=p,c.onerror=d=>(p(),a.close(),r(u.error))}},u.onerror=c=>(a.close(),r(u.error)),o.oncomplete=()=>{l==null?a.close():l.oncomplete=()=>a.close()}},s.onerror=a=>r(s.error)})})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qn="/",us="tensorflowjs_models",tm="info",G0="model_topology",H0="weight_specs",j0="weight_data",q0="model_metadata";function nm(n){return{info:[us,n,tm].join(qn),topology:[us,n,G0].join(qn),weightSpecs:[us,n,H0].join(qn),weightData:[us,n,j0].join(qn),modelMetadata:[us,n,q0].join(qn)}}function rm(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function K0(n){const e=n.split(qn);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(qn)}function X0(n){return n.startsWith(Ur.URL_SCHEME)?n.slice(Ur.URL_SCHEME.length):n}class Ur{constructor(e){if(!L().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=nm(this.modelPath)}save(e){return se(this,null,function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=ya(e);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,R0(e.weightData));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:s}}catch(a){throw rm(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}})}load(){return se(this,null,function*(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=s;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const i=JSON.parse(a);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=A0(o),t})}}Ur.URL_SCHEME="localstorage://";const sm=n=>L().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ur.URL_SCHEME)?Y0(n.slice(Ur.URL_SCHEME.length)):null;at.registerSaveRouter(sm);at.registerLoadRouter(sm);function Y0(n){return new Ur(n)}class Q0{constructor(){I(L().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),I(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){return se(this,null,function*(){const e={},t=us+qn,r=qn+tm;for(let s=0;s<this.LS.length;++s){const a=this.LS.key(s);if(a.startsWith(t)&&a.endsWith(r)){const o=K0(a);e[o]=JSON.parse(this.LS.getItem(a))}}return e})}removeModel(e){return se(this,null,function*(){e=X0(e);const t=nm(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(t.info));return rm(t),r})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ds="://";class Ft{constructor(){this.managers={}}static getInstance(){return Ft.instance==null&&(Ft.instance=new Ft),Ft.instance}static registerManager(e,t){I(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(ds)&&(e=e.slice(0,e.indexOf(ds))),I(e.length>0,()=>"scheme must not be an empty string.");const r=Ft.getInstance();I(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){const t=Ft.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Ft.getInstance().managers)}}function Qa(n){if(n.indexOf(ds)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ft.getSchemes().join(",")}`);return{scheme:n.split(ds)[0],path:n.split(ds)[1]}}function am(n,e,t=!1){return se(this,null,function*(){I(n!==e,()=>`Old path and new path are the same: '${n}'`);const r=at.getLoadHandlers(n);I(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),I(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const s=r[0],a=at.getSaveHandlers(e);I(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),I(a.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const o=a[0],i=Qa(n).scheme,u=Qa(n).path,l=i===Qa(n).scheme,c=yield s.load();t&&l&&(yield Ft.getManager(i).removeModel(u));const p=yield o.save(c);return t&&!l&&(yield Ft.getManager(i).removeModel(u)),p.modelArtifactsInfo})}function Z0(){return se(this,null,function*(){const n=Ft.getSchemes(),e={};for(const t of n){const r=yield Ft.getManager(t).listModels();for(const s in r){const a=t+ds+s;e[a]=r[s]}}return e})}function J0(n){return se(this,null,function*(){const e=Qa(n);return Ft.getManager(e.scheme).removeModel(e.path)})}function e1(n,e){return se(this,null,function*(){return am(n,e,!1)})}function t1(n,e){return se(this,null,function*(){return am(n,e,!0)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n1{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(!window||!L().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}}if(L().get("IS_BROWSER")){L().setPlatform("browser",new n1);try{Ft.registerManager(Ur.URL_SCHEME,new Q0)}catch(n){}try{Ft.registerManager(Wr.URL_SCHEME,new z0)}catch(n){}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r1={importFetch:()=>require("node-fetch")};let Ki;class s1{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return L().global.fetch!=null?L().global.fetch(e,t):(Ki==null&&(Ki=r1.importFetch()),Ki(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}}L().get("IS_NODE")&&!L().get("IS_BROWSER")&&L().setPlatform("node",new s1);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function it(n,e="float32",t){return e=e||"float32",Oh(n),new ta(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a1(n,e){const t=S(n,"x","cast");if(!Fb(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},s={dtype:e};return O.runKernel(Ao,r,s)}const tt=E({cast_:a1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o1(n){const t={x:S(n,"x","clone","string_or_numeric")};return O.runKernel(Go,t)}const pr=E({clone_:o1});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function om(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Gf();const i1={buffer:it,cast:tt,clone:pr,print:om};w0(i1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u1="model",c1=".json",l1=".weights.bin";function od(n){return new Promise(e=>setTimeout(e)).then(n)}class zr{constructor(e){if(!L().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(zr.URL_SCHEME)&&(e=e.slice(zr.URL_SCHEME.length)),(e==null||e.length===0)&&(e=u1),this.modelJsonFileName=e+c1,this.weightDataFileName=e+l1}save(e){return se(this,null,function*(){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],s=Yf(e,r),a=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=a,yield od(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=t,yield od(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:ya(e)}}})}}zr.URL_SCHEME="downloads://";class p1{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}load(){return se(this,null,function*(){return new Promise((e,t)=>{const r=new FileReader;r.onload=s=>{const a=JSON.parse(s.target.result),o=a.modelTopology;if(o==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const u=El(a,l=>this.loadWeights(l));e(u)},r.onerror=s=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})})}loadWeights(e){const t=[],r=[];for(const o of e)t.push(...o.weights),r.push(...o.paths);const s=this.checkManifestAndWeightFiles(e),a=r.map(o=>this.loadWeightsFile(o,s[o]));return Promise.all(a).then(o=>[t,Nl(o)])}loadWeightsFile(e,t){return new Promise((r,s)=>{const a=new FileReader;a.onload=o=>{const i=o.target.result;r(i)},a.onerror=o=>s(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],r=this.weightsFiles.map(a=>ad(a.name)),s={};for(const a of e)a.paths.forEach(o=>{const i=ad(o);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),r.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);s[o]=this.weightsFiles[r.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const d1=n=>L().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(zr.URL_SCHEME)?h1(n.slice(zr.URL_SCHEME.length)):null;at.registerSaveRouter(d1);function h1(n="model"){return new zr(n)}function f1(n){return new p1(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function id(n,e,t,r){o(n),t=t==null?0:t,r=r==null?1:r,i(t,r);let s=0;const a=u=>(u.then(l=>{const c=t+ ++s/n.length*(r-t);return e(c),l}),u);function o(u){I(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function i(u,l){I(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),I(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),I(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(n.map(a))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function im(n,e){return se(this,null,function*(){e==null&&(e={});const t=e.fetchFunc==null?L().platform.fetch:e.fetchFunc,r=n.map(p=>t(p,e.requestInit,{isBinary:!0})),s=0,a=.5,i=(e.onProgress==null?yield Promise.all(r):yield id(r,e.onProgress,s,a)).map(p=>p.arrayBuffer()),u=.5,l=1;return e.onProgress==null?yield Promise.all(i):yield id(i,e.onProgress,u,l)})}function m1(n,e="",t,r){return se(this,null,function*(){return um(o=>im(o,{requestInit:r}))(n,e,t)})}function um(n){return(e,t="",r)=>se(this,null,function*(){const s=e.map(()=>!1),a={},o=r!=null?r.map(()=>!1):[],i=[];if(e.forEach((h,f)=>{let m=0;h.weights.forEach(g=>{const y="quantization"in g?g.quantization.dtype:g.dtype,x=ku[y]*V(g.shape),w=()=>{s[f]=!0,a[f]==null&&(a[f]=[]),a[f].push({manifestEntry:g,groupOffset:m,sizeBytes:x})};r!=null?r.forEach((v,$)=>{v===g.name&&(w(),o[$]=!0)}):w(),i.push(g.name),m+=x})}),!o.every(h=>h)){const h=r.filter((f,m)=>!o[m]);throw new Error(`Could not find weights in manifest with names: ${h.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}const u=s.reduce((h,f,m)=>(f&&h.push(m),h),[]),l=[];u.forEach(h=>{e[h].paths.forEach(f=>{const m=t+(t.endsWith("/")?"":"/")+f;l.push(m)})});const c=yield n(l),p={};let d=0;return u.forEach(h=>{const f=e[h].paths.length;let m=0;for(let v=0;v<f;v++)m+=c[d+v].byteLength;const g=new ArrayBuffer(m),y=new Uint8Array(g);let x=0;for(let v=0;v<f;v++){const $=new Uint8Array(c[d+v]);y.set($,x),x+=$.byteLength}a[h].forEach(v=>{const $=g.slice(v.groupOffset,v.groupOffset+v.sizeBytes),C=Xf($,[v.manifestEntry]);for(const k in C)p[k]=C[k]}),d+=f}),p})}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g1="application/octet-stream",y1="application/json";class Rl{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(I(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=L().platform.fetch,I(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&I(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}save(e){return se(this,null,function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=Yf(e,r);t.body.append("model.json",new Blob([JSON.stringify(s)],{type:y1}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:g1}),"model.weights.bin");const a=yield this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:ya(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)})}load(){return se(this,null,function*(){const e=yield this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=yield e.json()}catch(a){let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const r=t.modelTopology,s=t.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return El(t,a=>this.loadWeights(a))})}loadWeights(e){return se(this,null,function*(){const t=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=x1(t),a=this.weightPathPrefix||r,o=Zf(e),i=[],u=[];for(const c of e)for(const p of c.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(p)):i.push(a+p+s);this.weightUrlConverter&&i.push(...yield Promise.all(u));const l=yield im(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,Nl(l)]})}}Rl.URL_SCHEME_REGEX=/^https?:\/\//;function x1(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),r=n.substring(0,e),s=t>e?n.substring(t):"";return[r+"/",s]}function Au(n){return n.match(Rl.URL_SCHEME_REGEX)!=null}const cm=(n,e)=>{if(typeof fetch=="undefined"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(r=>Au(r)):t=Au(n),t)return Al(n,e)}return null};at.registerSaveRouter(cm);at.registerLoadRouter(cm);function Al(n,e){return new Rl(n,e)}function b1(n,e){return Al(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xi{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class lm{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class w1{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function v1(n,e,t,r){const s=arguments;return new w1(pm(...s))}function pm(n,e,t,r){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new Xi(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Xi({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Xi({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:r}))}function S1(n){return new lm(n)}function $1(n){return new lm(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dm=Object.freeze(Object.defineProperty({__proto__:null,browserFiles:f1,browserHTTPRequest:b1,concatenateArrayBuffers:Nl,copyModel:e1,decodeWeights:Xf,encodeWeights:N0,fromMemory:v1,fromMemorySync:pm,getLoadHandlers:V0,getModelArtifactsForJSON:El,getModelArtifactsForJSONSync:Qf,getModelArtifactsInfoForJSON:ya,getSaveHandlers:B0,getWeightSpecs:Zf,http:Al,isHTTPScheme:Au,listModels:Z0,loadWeights:m1,moveModel:t1,registerLoadRouter:M0,registerSaveRouter:L0,removeModel:J0,weightsLoaderFactory:um,withSaveHandler:S1,withSaveHandlerSync:$1},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I1(n,e,t=!1,r=!1){let s=S(n,"a","matMul"),a=S(e,"b","matMul");[s,a]=dt(s,a);const o={a:s,b:a},i={transposeA:t,transposeB:r};return O.runKernel(Ro,o,i)}const Ge=E({matMul_:I1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T1(n,e,t=1,r=0,s="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:S(n,"indices","oneHot","int32")},i={dtype:s,depth:e,onValue:t,offValue:r};return O.runKernel(ei,o,i)}const C1=E({oneHot_:T1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _1(){L().set("PROD",!0)}function or(){return O}function Be(n,e){return O.tidy(n,e)}function St(n){Uf(n).forEach(t=>t.dispose())}function ur(n){return O.keep(n)}function k1(n){return O.setBackend(n)}function N1(){return O.ready()}function oo(){return O.backendName}function hm(n,e,t=1){return O.registerBackend(n,e,t)}function E1(){return O.backend}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R1(n){const t={input:S(n,"input","imag")};return O.runKernel(cf,t)}const xi=E({imag_:R1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A1(n){const t={x:S(n,"x","neg")};return O.runKernel(Yc,t)}const Xn=E({neg_:A1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O1(n){const t={input:S(n,"input","real")};return O.runKernel(Sf,t)}const na=E({real_:O1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F1(n,e,t){const r=S(n,"x","transpose");if(e==null&&(e=r.shape.map((o,i)=>i).reverse()),I(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(o=>{I(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},a={perm:e};return r.dtype==="complex64"?Be(()=>{let o=na(r),i=xi(r);return o=O.runKernel(ps,{x:o},a),i=O.runKernel(ps,{x:i},a),t&&(i=Xn(i)),hr(o,i)}):O.runKernel(ps,s,a)}const Ou=E({transpose_:F1});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function io(n,e){const t=n.length,r=[];for(let s=0;s<t;s++){const a=t-1-s,o=n[a]||1;(e[e.length-1-s]||1)>1&&o===1&&r.unshift(a)}return r}function fm(n,e){const t=[];for(let r=0;r<e.length;r++){const s=n[n.length-r-1],a=e.length-r-1,o=e[a];(s==null||s===1&&o>1)&&t.unshift(a)}return t}function Ne(n,e){const t=[],r=Math.max(n.length,e.length);for(let s=0;s<r;s++){let a=n[n.length-s-1];a==null&&(a=1);let o=e[e.length-s-1];if(o==null&&(o=1),a===1)t.unshift(o);else if(o===1)t.unshift(a);else if(a!==o){const i=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(i)}else t.unshift(a)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mm(n,e,t){if(Ts(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=xr(n,t);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return br(n,e,r,t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Cr;function D1(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,r=!1,s=!1,a=!1,o=!1,i=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData!="undefined"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement!="undefined"&&n instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement)a=!0;else if(n.getContext!=null)o=!0;else if(typeof ImageBitmap!="undefined"&&n instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(bu(xu,O.backendName)!=null){const f={pixels:n},m={numChannels:e};return O.runKernel(xu,f,m)}const[l,c]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let p;if(o)p=n.getContext("2d").getImageData(0,0,l,c).data;else if(r||t)p=n.data;else if(a||s||i){if(Cr==null)if(typeof document=="undefined")if(typeof OffscreenCanvas!="undefined"&&typeof OffscreenCanvasRenderingContext2D!="undefined")Cr=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Cr=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Cr.canvas.width=l,Cr.canvas.height=c,Cr.drawImage(n,0,0,l,c),p=Cr.getImageData(0,0,l,c).data}let d;if(e===4)d=new Int32Array(p);else{const f=l*c;d=new Int32Array(f*e);for(let m=0;m<f;m++)for(let g=0;g<e;++g)d[m*e+g]=p[m*4+g]}return mm(d,[c,l,e],"int32")}function Ol(n,e){return se(this,null,function*(){let t=S(n,"img","toPixels");if(!(n instanceof ot)){const l=t;t=tt(l,"int32"),l.dispose()}if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const[r,s]=t.shape.slice(0,2),a=t.rank===2?1:t.shape[2];if(a>4||a===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${a}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);const o=yield t.data(),i=t.dtype==="float32"?255:1,u=new Uint8ClampedArray(s*r*4);for(let l=0;l<r*s;++l){const c=[0,0,0,255];for(let d=0;d<a;d++){const h=o[l*a+d];if(t.dtype==="float32"){if(h<0||h>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${h}.`)}else if(t.dtype==="int32"&&(h<0||h>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${h}.`);a===1?(c[0]=h*i,c[1]=h*i,c[2]=h*i):c[d]=h*i}const p=l*4;u[p+0]=Math.round(c[0]),u[p+1]=Math.round(c[1]),u[p+2]=Math.round(c[2]),u[p+3]=Math.round(c[3])}if(e!=null){e.width=s,e.height=r;const l=e.getContext("2d"),c=new ImageData(u,s,r);l.putImageData(c,0,0)}return t!==n&&t.dispose(),u})}const Fl=E({fromPixels_:D1});function Dl(n,e){const t=n.shape.length,r=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${t}`);if(V(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=e.shape,a=s[s.length-1];let o=1;for(let p=0;p<s.length-1;++p)o*=s[p];const i=n.shape,u=s.slice();u.pop();let l=1;for(let p=a;p<t;++p)l*=i[p],u.push(i[p]);const c=[...Ve(n.shape).map(p=>p/l),1].slice(0,a);return[u,o,l,c]}function gm(n,e,t){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(t.rank<s)throw new Error(a+` update.rank < ${s}. `);if(n.length<r+(t.rank-s))throw new Error(a+` Output shape length < ${r+(t.rank-s)}`);if(t.rank!==s+n.length-r)throw new Error(a+` update.rank != ${s+n.length-r}`);for(let o=0;o<s;++o)if(t.shape[o]!==e.shape[o])throw new Error(a+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-s;++o)if(t.shape[o+s]!==n[o+r])throw new Error(a+` updates.shape[${o+s}] (${t.shape[o+s]}) != shape[${o+s}] (${n[o+s]})`)}function ym(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}gm(t,e,n)}function bi(n,e,t){const r=e.shape.length,s=r>1?e.shape[r-1]:1,a=t.length;let o=1;for(let p=s;p<a;++p)o*=t[p];const i=s<1?1:s,u=V(e.shape)/i,l=[...Ve(t.slice(0,s)),1],c=V(t);return{sliceRank:s,numUpdates:u,sliceSize:o,strides:l,outputSize:c}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fu=-2,P1=-1;function xm(n,e,t){const r=n.shape.length;I(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),I(r===t.length,()=>`Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)I(e[s]+t[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+t[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function L1(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function Pl(n,e,t){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((e[s]-n[s])/t[s]);return r}function bm(n,e,t,r){const s=[...n];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<t;a++)a===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function wm(n,e,t){return t<=n?t:t-(e-1)}function vm(n,e){const t=[];for(let r=0;r<n;r++)t.push(e+r);return t}function M1(n,e,t,r,s,a,o,i,u){const l=n.length;let c=new Array(l),p=new Array(l),d=new Array(l);if(e.length&&t>0){const h=e[0],f=t+1;c=Sm(o,h,f,r,n),p=$m(i,h,f,s,n),d=bm(a,h,f,n)}else for(let h=0;h<l;h++)c[h]=Tm(o,r,a,n,h,u),p[h]=Cm(i,s,a,n,h,u),d[h]=Im(a,h,u);return{begin:c,end:p,strides:d}}function Sm(n,e,t,r,s){const a=[...s],o=vm(t,e);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=0;else{const u=wm(e,t,i);let l=r[u];n&1<<u&&(l=0),a[i]=l}return a}function $m(n,e,t,r,s){const a=[...s],o=vm(t,e);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=Number.MAX_SAFE_INTEGER;else{const u=wm(e,t,i);let l=r[u];n&1<<u&&(l=Number.MAX_SAFE_INTEGER),a[i]=l}for(let i=0;i<a.length;i++){const u=s[i];a[i]<0&&(a[i]+=u),a[i]=to(0,a[i],s[i])}return a}function Im(n,e,t){let r=n[e];return(t&1<<e||r==null)&&(r=1),r}function Tm(n,e,t,r,s,a){let o=e[s];const i=t[s]||1;(n&1<<s||a&1<<s||o==null)&&(i>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const u=r[s];return o<0&&(o+=u),o=to(0,o,u-1),o}function Cm(n,e,t,r,s,a){let o=e[s];const i=t[s]||1;(n&1<<s||a&1<<s||o==null)&&(i>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const u=r[s];return o<0&&(o+=u),i>0?o=to(0,o,u):o=to(-1,o,u-1),o}function wi(n,e,t){let r=t.length;for(let s=0;s<t.length;s++)if(t[s]>1){r=s;break}for(let s=r+1;s<t.length;s++)if(e[s]>0||t[s]!==n[s])return!1;return!0}function vi(n,e){let t=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)t+=n[r]*e[r];return t}function Ll(n,e,t){let r;const s=n.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(o=>{I(o!==-1,()=>"slice() does not support negative begin indexing.")});let a;return t==null?a=new Array(s).fill(-1):typeof t=="number"?a=[t,...new Array(s-1).fill(-1)]:t.length<s?a=t.concat(new Array(s-t.length).fill(-1)):a=t,a=a.map((o,i)=>o>=0?o:(I(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${i}.`),n.shape[i]-r[i])),[r,a]}function Ml(n,e,t,r,s,a,o,i,u){let l;if(r==null?(l=new Array(e.length),l.fill(1)):l=r,o!=null&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const p={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:l.slice(),beginMask:s,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};for(let w=0;w<p.dims;w++)c&&1<<w&i&&p.numAddAxisAfterEllipsis++,1<<w&o&&(c=!0);c||(p.ellipsisMask|=1<<p.dims,p.dims++);const d={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};B1(p,d);let h=!0,f=!0,m=!0;const g=[],y=[];for(let w=0;w<n.length;++w){if(d.strides[w]===0)throw Error(`strides[${w}] must be non-zero`);const v=!!(d.shrinkAxisMask&1<<w),$=n[w];if($===-1){g.push(v?1:-1);continue}const C=[d.beginMask&1<<w,d.endMask&1<<w],k=[d.strides[w]>0?0:-1,d.strides[w]>0?$:$-1];if(v&&d.strides[w]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&d.strides[w]===1;const R=!!(d.beginMask&1<<w&&d.endMask&1<<w);if(d.beginValid&&d.endValid){if(v){const U=d.begin[w]<0?$+d.begin[w]:d.begin[w];if(d.begin[w]=U,d.end[w]=d.begin[w]+1,U<0||U>=$)throw Error(`slice index ${d.begin[w]} of dimension ${w} out of bounds.`)}else d.begin[w]=ud(d.begin[w],0,d.strides[w],$,C,k),d.end[w]=ud(d.end[w],1,d.strides[w],$,C,k);const M=d.strides[w]===1&&d.begin[w]===0&&d.end[w]===$;h=h&&M,f=f&&(w===0&&d.strides[w]===1||M)}else h=h&&d.strides[w]===1&&R,f=f&&(w===0&&d.strides[w]===1||R);let F,D=!1;if(d.beginValid&&d.endValid?(F=d.end[w]-d.begin[w],D=!0):v?(F=1,D=!0):R&&$>=0&&(d.strides[w]<0?F=-$:F=$,D=!0),D){let M;F===0||F<0!=d.strides[w]<0?M=0:M=Math.trunc(F/d.strides[w])+(F%d.strides[w]!==0?1:0),g.push(M)}else g.push(-1)}for(let w=0;w<d.finalShapeGatherIndices.length;++w){const v=d.finalShapeGatherIndices[w];v>=0?y.push(g[v]):v===Fu&&y.push(1)}return{finalShapeSparse:y.filter((w,v)=>d.finalShapeGatherIndices[v]!==Fu),finalShape:y,isIdentity:h,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function B1(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(e.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<s;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=r}else if(1<<r&n.newAxisMask)e.finalShapeGatherIndices.push(Fu),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[r]),n.end!=null&&(e.end[t]=n.end[r]),e.strides[t]=n.strides[r],n.beginMask&1<<r&&(e.beginMask|=1<<t),n.endMask&1<<r&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(P1),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[t]=r,t++}}function ud(n,e,t,r,s,a){if(s[e])return t>0?a[e]:a[e+1&1];{const o=n<0?r+n:n;return o<a[0]?a[0]:o>a[1]?a[1]:o}}const V1=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:xm,computeFlatOffset:vi,computeOutShape:Pl,getNormalizedAxes:M1,isSliceContinous:wi,maskToAxes:L1,parseSliceParams:Ll,sliceInfo:Ml,startForAxis:Tm,startIndicesWithElidedDims:Sm,stopForAxis:Cm,stopIndicesWithElidedDims:$m,stridesForAxis:Im,stridesWithElidedDims:bm},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W1(n,e){let t=S(n,"a","add"),r=S(e,"b","add");[t,r]=dt(t,r);const s={a:t,b:r};return O.runKernel(To,s)}const Pe=E({add_:W1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U1(n,e){let t=S(n,"a","floorDiv"),r=S(e,"b","floorDiv");[t,r]=dt(t,r);const s={a:t,b:r};return O.runKernel(Lc,s)}const _m=E({floorDiv_:U1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z1(n,e){let t=S(n,"a","div"),r=S(e,"b","div");if([t,r]=dt(t,r),t.dtype==="int32"&&r.dtype==="int32")return _m(t,r);const s={a:t,b:r},a={};return O.runKernel(Ec,s,a)}const Me=E({div_:z1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G1(n,e){let t=S(n,"a","mul"),r=S(e,"b","mul");[t,r]=dt(t,r);const s={a:t,b:r};return O.runKernel(Xc,s)}const pe=E({mul_:G1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H1(n){const e=S(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return O.runKernel(Kh,t)}else{const t={x:e};return O.runKernel(Ic,t)}}const hn=E({abs_:H1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j1(n){const t={x:S(n,"x","acos")};return O.runKernel(Ph,t)}const q1=E({acos_:j1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K1(n){const t={x:S(n,"x","acosh")};return O.runKernel(Lh,t)}const X1=E({acosh_:K1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y1(n){I(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),I(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((s,a)=>S(s,`tensors${a}`,"addN")),t=e[0];e.forEach(s=>{if(s.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!pt(s.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return O.runKernel(Co,r)}const Q1=E({addN_:Y1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z1(n,e=null,t=!1){const s={x:S(n,"x","all","bool")},a={axis:e,keepDims:t};return O.runKernel(_o,s,a)}const J1=E({all_:Z1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ew(n,e=null,t=!1){const s={x:S(n,"x","any","bool")},a={axis:e,keepDims:t};return O.runKernel(ko,s,a)}const tw=E({any_:ew});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nw(n,e=0){const r={x:S(n,"x","argMax")},s={axis:e};return O.runKernel(No,r,s)}const km=E({argMax_:nw});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rw(n,e=0){const r={x:S(n,"x","argMin")},s={axis:e};return O.runKernel(Mh,r,s)}const sw=E({argMin_:rw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aw(n){const t={x:S(n,"x","asin")};return O.runKernel(Bh,t)}const ow=E({asin_:aw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iw(n){const t={x:S(n,"x","asinh")};return O.runKernel(Vh,t)}const uw=E({asinh_:iw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cw(n){const t={x:S(n,"x","atan")};return O.runKernel(Wh,t)}const lw=E({atan_:cw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pw(n,e){let t=S(n,"a","atan2"),r=S(e,"b","atan2");[t,r]=dt(t,r);const s={a:t,b:r};return O.runKernel(zh,s)}const dw=E({atan2_:pw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hw(n){const t={x:S(n,"x","atanh")};return O.runKernel(Uh,t)}const fw=E({atanh_:hw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nm(n,e,t,r,s="NHWC",a){const o=n[3],i=[...e,o],u=wr(s);return It(n,i,t,a,r,null,null,u)}function nr(n,e,t,r,s,a,o="channelsLast"){const[i,u]=uo(e);let l;if(o==="channelsLast")l=[i,u,n[3],n[3]];else if(o==="channelsFirst")l=[i,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return It(n,l,t,r,s,a,!1,o)}function xa(n,e,t,r,s,a,o="NDHWC"){const[i,u,l]=Du(e);let c,p;if(o==="NDHWC")p="channelsLast",c=[i,u,l,n[4],n[4]];else if(o==="NCDHW")p="channelsFirst",c=[i,u,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return ba(n,c,t,r,s,!1,p,a)}function It(n,e,t,r,s,a,o=!1,i="channelsLast"){let[u,l,c,p]=[-1,-1,-1,-1];if(i==="channelsLast")[u,l,c,p]=n;else if(i==="channelsFirst")[u,p,l,c]=n;else throw new Error(`Unknown dataFormat ${i}`);const[d,h,,f]=e,[m,g]=uo(t),[y,x]=uo(r),w=hs(d,y),v=hs(h,x),{padInfo:$,outHeight:C,outWidth:k}=yw(s,l,c,m,g,w,v,a,i),R=o?f*p:f;let F;return i==="channelsFirst"?F=[u,R,C,k]:i==="channelsLast"&&(F=[u,C,k,R]),{batchSize:u,dataFormat:i,inHeight:l,inWidth:c,inChannels:p,outHeight:C,outWidth:k,outChannels:R,padInfo:$,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:h,effectiveFilterHeight:w,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:x,inShape:n,outShape:F,filterShape:e}}function ba(n,e,t,r,s,a=!1,o="channelsLast",i){let[u,l,c,p,d]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[u,l,c,p,d]=n;else if(o==="channelsFirst")[u,d,l,c,p]=n;else throw new Error(`Unknown dataFormat ${o}`);const[h,f,m,,g]=e,[y,x,w]=Du(t),[v,$,C]=Du(r),k=hs(h,v),R=hs(f,$),F=hs(m,C),{padInfo:D,outDepth:M,outHeight:U,outWidth:j}=xw(s,l,c,p,y,x,w,k,R,F,i),Y=a?g*d:g;let Q;return o==="channelsFirst"?Q=[u,Y,M,U,j]:o==="channelsLast"&&(Q=[u,M,U,j,Y]),{batchSize:u,dataFormat:o,inDepth:l,inHeight:c,inWidth:p,inChannels:d,outDepth:M,outHeight:U,outWidth:j,outChannels:Y,padInfo:D,strideDepth:y,strideHeight:x,strideWidth:w,filterDepth:h,filterHeight:f,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:R,effectiveFilterWidth:F,dilationDepth:v,dilationHeight:$,dilationWidth:C,inShape:n,outShape:Q,filterShape:e}}function mw(n,e,t,r,s){r==null&&(r=Bl(n,e,t));const a=n[0],o=n[1],i=Br((a-e+2*r)/t+1,s),u=Br((o-e+2*r)/t+1,s);return[i,u]}function gw(n,e,t,r,s,a){s==null&&(s=Bl(n,e,r));const o=n[0],i=n[1],u=n[2],l=Br((o-e+2*s)/r+1,a),c=Br((i-e+2*s)/r+1,a),p=Br((u-e+2*s)/r+1,a);return[l,c,p,t]}function Bl(n,e,t,r=1){const s=hs(e,r);return Math.floor((n[0]*(t-1)-t+s)/2)}function uo(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function Du(n){return typeof n=="number"?[n,n,n]:n}function hs(n,e){return e<=1?n:n+(n-1)*(e-1)}function yw(n,e,t,r,s,a,o,i,u){let l,c,p;if(typeof n=="number"){l={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const h=mw([e,t],a,r,n,i);c=h[0],p=h[1]}else if(n==="same"){c=Math.ceil(e/r),p=Math.ceil(t/s);const d=Math.max(0,(c-1)*r+a-e),h=Math.max(0,(p-1)*s+o-t),f=Math.floor(d/2),m=d-f,g=Math.floor(h/2),y=h-g;l={top:f,bottom:m,left:g,right:y,type:"SAME"}}else if(n==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-a+1)/r),p=Math.ceil((t-o+1)/s);else if(typeof n=="object"){const d=u==="channelsLast"?n[1][0]:n[2][0],h=u==="channelsLast"?n[1][1]:n[2][1],f=u==="channelsLast"?n[2][0]:n[3][0],m=u==="channelsLast"?n[2][1]:n[3][1];l={top:d,bottom:h,left:f,right:m,type:d===0&&h===0&&f===0&&m===0?"VALID":"EXPLICIT"},c=Br((e-a+d+h)/r+1,i),p=Br((t-o+f+m)/s+1,i)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:l,outHeight:c,outWidth:p}}function xw(n,e,t,r,s,a,o,i,u,l,c){let p,d,h,f;if(typeof n=="number"){p={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const g=gw([e,t,r,1],i,1,s,n,c);d=g[0],h=g[1],f=g[2]}else if(n==="same"){d=Math.ceil(e/s),h=Math.ceil(t/a),f=Math.ceil(r/o);const m=(d-1)*s+i-e,g=(h-1)*a+u-t,y=(f-1)*o+l-r,x=Math.floor(m/2),w=m-x,v=Math.floor(g/2),$=g-v,C=Math.floor(y/2),k=y-C;p={top:v,bottom:$,left:C,right:k,front:x,back:w,type:"SAME"}}else if(n==="valid")p={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-i+1)/s),h=Math.ceil((t-u+1)/a),f=Math.ceil((r-l+1)/o);else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:p,outDepth:d,outHeight:h,outWidth:f}}function Br(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function ra(n){const[e,t,r]=uo(n);return e===1&&t===1&&r===1}function en(n,e){return ra(n)||ra(e)}function wr(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Sn(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")I(gs(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{I(gs(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${s}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bw(n,e){const r={x:S(n,"x","reshape","string_or_numeric")},s={shape:e};return O.runKernel(rl,r,s)}const z=E({reshape_:bw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ww(n,e,t,r,s){const a=S(n,"x","avgPool","float32"),o=1;I(en(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let i=a,u=!1;a.rank===3&&(u=!0,i=z(a,[1,a.shape[0],a.shape[1],a.shape[2]])),I(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),Sn("avgPool",r,s);const l={x:i},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s};let p=O.runKernel(Eo,l,c);return p=tt(p,a.dtype),u?z(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Em=E({avgPool_:ww});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vw(n,e,t,r,s,a="NDHWC"){const o=S(n,"x","avgPool3d","float32");let i=o,u=!1;o.rank===4&&(u=!0,i=z(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),I(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),I(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Sn("avgPool3d",r,s);const l={x:i},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:a};let p=O.runKernel(Gh,l,c);return p=tt(p,i.dtype),u?z(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Sw=E({avgPool3d_:vw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $w(n,e=0){I(n.length>=1,()=>"Pass at least one tensor to concat");const t=so(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),t.length===1)return pr(t[0]);const r=t,s={axis:e};return O.runKernel(_c,r,s)}const xt=E({concat_:$w});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iw(n){const t={x:S(n,"x","sigmoid","float32")};return O.runKernel(ll,t)}const Yn=E({sigmoid_:Iw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tw(n,e,t){const r=S(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:e,size:t};return O.runKernel(ul,s,a)}const Ie=E({slice_:Tw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cw(n){const t={x:S(n,"x","tanh","float32")};return O.runKernel($l,t)}const Pu=E({tanh_:Cw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _w(n,e,t,r,s,a){const o=S(n,"forgetBias","basicLSTMCell"),i=S(e,"lstmKernel","basicLSTMCell"),u=S(t,"lstmBias","basicLSTMCell"),l=S(r,"data","basicLSTMCell"),c=S(s,"c","basicLSTMCell"),p=S(a,"h","basicLSTMCell"),d=xt([l,p],1),h=Ge(d,i),f=Pe(h,u),m=f.shape[0],g=f.shape[1]/4,y=[m,g],x=Ie(f,[0,0],y),w=Ie(f,[0,g],y),v=Ie(f,[0,g*2],y),$=Ie(f,[0,g*3],y),C=Pe(pe(Yn(x),Pu(w)),pe(c,Yn(Pe(o,v)))),k=pe(Pu(C),Yn($));return[C,k]}const kw=E({basicLSTMCell_:_w});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nw(n,e,t){const r=S(n,"x","batchToSpaceND"),s=e.reduce((i,u)=>i*u);I(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),I(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),I(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const a={x:r},o={blockShape:e,crops:t};return O.runKernel(Tc,a,o)}const Rm=E({batchToSpaceND_:Nw});function Ew(n){let e;return n.rank===0||n.rank===1?e=z(n,[1,1,1,n.size]):n.rank===2?e=z(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=z(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rw(n,e,t,r,s,a){a==null&&(a=.001);const o=S(n,"x","batchNorm"),i=S(e,"mean","batchNorm"),u=S(t,"variance","batchNorm");let l;s!=null&&(l=S(s,"scale","batchNorm"));let c;r!=null&&(c=S(r,"offset","batchNorm")),I(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I(l==null||i.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:Ew(o),scale:l,offset:c,mean:i,variance:u},h={varianceEpsilon:a},f=O.runKernel(Uo,d,h);return z(f,o.shape)}const Si=E({batchNorm_:Rw});function Aw(n,e,t,r,s,a){const o=S(n,"x","batchNorm"),i=S(e,"mean","batchNorm"),u=S(t,"variance","batchNorm");let l;s!=null&&(l=S(s,"scale","batchNorm"));let c;return r!=null&&(c=S(r,"offset","batchNorm")),I(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),I(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),I(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&I(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&I(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Si(o,i,u,c,l,a)}const Ow=E({batchNorm2d_:Aw});function Fw(n,e,t,r,s,a){const o=S(n,"x","batchNorm"),i=S(e,"mean","batchNorm"),u=S(t,"variance","batchNorm");let l;s!=null&&(l=S(s,"scale","batchNorm"));let c;return r!=null&&(c=S(r,"offset","batchNorm")),I(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),I(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),I(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&I(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&I(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Si(o,i,u,c,l,a)}const Dw=E({batchNorm3d_:Fw});function Pw(n,e,t,r,s,a){const o=S(n,"x","batchNorm"),i=S(e,"mean","batchNorm"),u=S(t,"variance","batchNorm");let l;s!=null&&(l=S(s,"scale","batchNorm"));let c;return r!=null&&(c=S(r,"offset","batchNorm")),I(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),I(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),I(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&I(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&I(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Si(o,i,u,c,l,a)}const Lw=E({batchNorm4d_:Pw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mw(n,e,t){const r=S(n,"x","bincount"),s=S(e,"weights","bincount");I(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),I(t>=0,()=>`size must be non-negative, but got ${t}.`),I(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const a={x:r,weights:s},o={size:t};return O.runKernel(Hh,a,o)}const Am=E({bincount_:Mw});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bw(n,e){const t=S(n,"s0","broadcastArgs","int32"),r=S(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:t,s1:r};return O.runKernel(jh,s)}const Vw=E({broadcastArgs_:Bw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ww(n,e){let t=S(n,"broadcastTo","x");const r=t.shape;if(e.some(l=>!(l>0)||l%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=z(t,l)}const s=t.shape,a=Array.from(e);for(let l=e.length-1;l>=0;l--)if(s[l]===e[l])a[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(a.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return pr(t);const i={x:t},u={reps:a};return O.runKernel(ga,i,u)}const Ks=E({broadcastTo_:Ww});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uw(n){const t={x:S(n,"x","ceil","float32")};return O.runKernel(Cc,t)}const zw=E({ceil_:Uw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $i(n,e,t){const r={shape:n,value:e,dtype:t};return O.runKernel(Dc,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gw(n,e,t){const r=S(n,"x","clipByValue");if(I(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return $i(r.shape,e,r.dtype);const s={x:r},a={clipValueMin:e,clipValueMax:t};return O.runKernel(Oo,s,a)}const Om=E({clipByValue_:Gw});function Hw(n){return xt(n,0)}const jw=E({concat1d_:Hw});function qw(n,e){return xt(n,e)}const Kw=E({concat2d_:qw});function Xw(n,e){return xt(n,e)}const Yw=E({concat3d_:Xw});function Qw(n,e){return xt(n,e)}const Zw=E({concat4d_:Qw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jw(n,e,t,r,s="NHWC",a=[1,1],o){const i=S(n,"x","conv2d","float32"),u=S(e,"filter","conv2d","float32");let l=i,c=!1;i.rank===3&&(c=!0,l=z(i,[1,i.shape[0],i.shape[1],i.shape[2]])),I(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),I(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Sn("conv2d",r,o);const p=s==="NHWC"?l.shape[3]:l.shape[1];I(p===u.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${u.shape[2]}.`),I(en(t,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);const d={x:l,filter:u},h={strides:t,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o},f=O.runKernel(Fo,d,h);return c?z(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Ii=E({conv2d_:Jw});function ev(n,e,t,r,s="NWC",a=1,o){const i=S(n,"x","conv1d"),u=S(e,"filter","conv1d");let l=i,c=!1;i.rank===2&&(c=!0,l=z(i,[1,i.shape[0],i.shape[1]])),I(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),I(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Sn("conv1d",r,o),I(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),I(en(t,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${a}'`),I(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const p=z(u,[1,u.shape[0],u.shape[1],u.shape[2]]),d=z(l,[l.shape[0],1,l.shape[1],l.shape[2]]),g=Ii(d,p,[1,t],r,"NHWC",[1,a],o);return c?z(g,[g.shape[2],g.shape[3]]):z(g,[g.shape[0],g.shape[2],g.shape[3]])}const tv=E({conv1d_:ev});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nv(n,e,t,r,s,a="NHWC",o){I(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,u=e,l=!1;e.rank===3&&(l=!0,u=z(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,n[0],n[1],n[2]]),I(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),I(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),I(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const c=a==="NHWC"?i[3]:i[1],p=a==="NHWC"?u.shape[3]:u.shape[1];I(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),I(p===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${t.shape[3]}.`),Sn("conv2dDerInput",s,o);const d={dy:u,filter:t},h={strides:r,pad:s,dataFormat:a,dimRoundingMode:o,inputShape:i},f=O.runKernel(Do,d,h);return l?z(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Fm=E({conv2DBackpropInput_:nv});function rv(n,e,t,r,s,a){const o=S(n,"x","conv2dTranspose"),i=S(e,"filter","conv2dTranspose");return Fm(t,o,i,r,s,"NHWC",a)}const sv=E({conv2dTranspose_:rv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function av(n,e,t,r,s="NDHWC",a=[1,1,1]){const o=S(n,"x","conv3d"),i=S(e,"filter","conv3d");let u=o,l=!1;o.rank===4&&(l=!0,u=z(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),I(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),I(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),I(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),I(en(t,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),I(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const c={x:u,filter:i},p={strides:t,pad:r,dataFormat:s,dilations:a},d=O.runKernel(Yh,c,p);return l?z(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const ov=E({conv3d_:av});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iv(n,e,t,r,s){I(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,o=e,i=!1;e.rank===4&&(i=!0,o=z(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),a=[1,n[0],n[1],n[2],n[3]]);const u=a[4],l=o.shape[4];I(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),I(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),I(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),I(u===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[3]}.`),I(l===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${t.shape[4]}.`);const c={dy:o,filter:t},p={pad:s,strides:r,inputShape:a},d=O.runKernel(Qh,c,p);return i?z(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const uv=E({conv3DBackpropInput_:iv});function cv(n,e,t,r,s){const a=S(n,"x","conv3dTranspose"),o=S(e,"filter","conv3dTranspose");return uv(t,a,o,r,s)}const lv=E({conv3dTranspose_:cv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pv(n){const t={x:S(n,"x","cos","float32")};return O.runKernel(kc,t)}const dv=E({cos_:pv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hv(n){const t={x:S(n,"x","cosh","float32")};return O.runKernel(Nc,t)}const fv=E({cosh_:hv});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mv(n,e=0,t=!1,r=!1){const a={x:S(n,"x","cumprod")},o={axis:e,exclusive:t,reverse:r};return O.runKernel(Po,a,o)}const gv=E({cumprod_:mv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yv(n,e=0,t=!1,r=!1){const a={x:S(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:r};return O.runKernel(Lo,a,o)}const xv=E({cumsum_:yv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bv(n,e,t,r=!1){const s=S(n,"x","denseBincount"),a=S(e,"weights","denseBincount");I(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),I(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),I(t>=0,()=>`size must be non-negative, but got ${t}.`),I(a.size===s.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);const o={x:s,weights:a},i={size:t,binaryOutput:r};return O.runKernel(Zh,o,i)}const wv=E({denseBincount_:bv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vv(n,e,t="NHWC"){const r=S(n,"x","depthToSpace","float32"),s=t==="NHWC"?r.shape[1]:r.shape[2],a=t==="NHWC"?r.shape[2]:r.shape[3],o=t==="NHWC"?r.shape[3]:r.shape[1];I(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),I(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),I(a*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${e} for depthToSpace with input shape
        ${r.shape}`),I(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${r.shape}`);const i={x:r},u={blockSize:e,dataFormat:t};return O.runKernel(Bo,i,u)}const Sv=E({depthToSpace_:vv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $v(n,e,t,r,s="NHWC",a=[1,1],o){const i=S(n,"x","depthwiseConv2d","float32"),u=S(e,"filter","depthwiseConv2d","float32");let l=i,c=!1;i.rank===3&&(c=!0,l=z(i,[1,i.shape[0],i.shape[1],i.shape[2]])),I(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),I(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const p=s==="NHWC"?l.shape[3]:l.shape[1];I(p===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${u.shape[2]}.`),Sn("depthwiseConv2d",r,o);const d={x:l,filter:u},h={strides:t,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o},f=O.runKernel(Vo,d,h);return c?z(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Vl=E({depthwiseConv2d_:$v});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iv(n){const t={x:S(n,"x","diag")};return O.runKernel(tf,t)}const Tv=E({diag_:Iv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cv(n,e,t,r,s=[1,1],a="NHWC"){const o=S(n,"x","dilation2d"),i=S(e,"filter","dilation2d");I(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),I(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),I(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let u=o,l=!1;o.rank===3&&(u=z(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=!0);const c={x:u,filter:i},p={strides:t,pad:r,dilations:s},d=O.runKernel(nf,c,p);return l?z(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const _v=E({dilation2d_:Cv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kv(n,e){let t=S(n,"a","equal","string_or_numeric"),r=S(e,"b","equal","string_or_numeric");[t,r]=dt(t,r),Ne(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(Ac,s)}const Dm=E({equal_:kv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nv(n,e,t){const r=S(e,"a","where"),s=S(t,"b","where"),a=S(n,"condition","where","bool"),o=Ne(Ne(a.shape,r.shape),s.shape),i=Ks(a,o),u=Ks(r,o),l=Ks(s,o),c={condition:i,t:u,e:l};return O.runKernel(il,c)}const vs=E({where_:Nv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ev(n){const t={x:S(n,"x","zerosLike")};return O.runKernel(Tl,t)}const Wl=E({zerosLike_:Ev});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rv(n,e){let t=S(n,"a","div"),r=S(e,"b","div");[t,r]=dt(t,r);const s=Me(t,r),a=Wl(s),o=Dm(r,a);return vs(o,a,s)}const Av=E({divNoNan_:Rv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ov(n,e){const t=S(n,"t1","dot"),r=S(e,"t2","dot");I((t.rank===1||t.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${r.rank}.`);const s=t.rank===1?t.size:t.shape[1],a=r.rank===1?r.size:r.shape[0];if(I(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),t.rank===1&&r.rank===1){const o=z(t,[1,-1]),i=z(r,[-1,1]),u=Ge(o,i);return z(u,[])}else if(t.rank===1&&r.rank===2){const o=z(t,[1,-1]),i=z(r,[r.shape[0],r.shape[1]]),u=Ge(o,i);return z(u,[u.size])}else if(t.rank===2&&r.rank===1){const o=z(r,[-1,1]),i=Ge(t,o);return z(i,[i.size])}else{const o=z(r,[r.shape[0],r.shape[1]]);return Ge(t,o)}}const Fv=E({dot_:Ov});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dv(n,...e){const t=e.map((s,a)=>S(s,`tensors${a}`,"einsum")),r={equation:n};return O.runKernel(rf,t,r)}const Pv=E({einsum_:Dv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lv(n){const t={x:S(n,"x","elu","float32")};return O.runKernel(Rc,t)}const Pm=E({elu_:Lv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mv(n){let e=S(n,"x","erf");I(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=tt(e,"float32"));const t={x:e};return O.runKernel(sf,t)}const Bv=E({erf_:Mv});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ul(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function Lm(n,e,t){const r=n.length+e.length,s=[];let a=0,o=0;for(let i=0;i<r;i++)t.indexOf(i)===-1?s.push(n[a++]):s.push(e[o++]);return s}function kt(n,e){const t=[],r=n.length;for(let a=0;a<r;a++)e.indexOf(a)===-1&&t.push(n[a]);const s=e.map(a=>n[a]);return[t,s]}function mt(n,e){const t=e.map(r=>1);return Lm(n,t,e)}function gt(n,e,t){I(Ul(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Ht(n,e){if(Ul(n,e))return null;const t=[];for(let r=0;r<e;++r)n.indexOf(r)===-1&&t.push(r);return n.forEach(r=>t.push(r)),t}function wa(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function Tt(n,e){const t=[];for(let r=e-n;r<e;++r)t.push(r);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vv(n,e=null,t=!1){const s={x:S(n,"x","max")},a={reductionIndices:e,keepDims:t};return O.runKernel(jo,s,a)}const fs=E({max_:Vv});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wv(n,e=null,t=!1){const s={x:S(n,"x","min")},a={axis:e,keepDims:t};return O.runKernel(Xo,s,a)}const Lu=E({min_:Wv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uv(n,e){let t=S(n,"base","pow"),r=S(e,"exp","pow");[t,r]=dt(t,r);const s={a:t,b:r};return O.runKernel(el,s)}const zl=E({pow_:Uv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Re(n,e){if((Mn(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Mn(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return br(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zv(n){const t={x:S(n,"x","sqrt","float32")};return O.runKernel(pl,t)}const Mu=E({sqrt_:zv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gv(n){const e=S(n,"x","square"),t={};return O.runKernel("Square",{x:e},t)}const va=E({square_:Gv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hv(n,e=null,t=!1){let r=S(n,"x","sum");r.dtype==="bool"&&(r=tt(r,"int32"));const s={x:r},a={axis:e,keepDims:t};return O.runKernel(ui,s,a)}const Ye=E({sum_:Hv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jv(n,e="euclidean",t=null,r=!1){n=S(n,"x","norm");const s=Mm(n,e,t);let a=s.shape;if(r){const o=ct(t,n.shape);a=mt(s.shape,o)}return z(s,a)}function Mm(n,e,t=null){if(n.rank===0)return hn(n);if(n.rank!==1&&t===null)return Mm(z(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Ye(hn(n),t);if(e===1/0)return fs(hn(n),t);if(e===-1/0)return Lu(hn(n),t);if(e==="euclidean"||e===2)return Mu(Ye(zl(hn(n),Re(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return fs(Ye(hn(n),t[0]),t[1]-1);if(e===1/0)return fs(Ye(hn(n),t[1]),t[0]);if(e===-1/0)return Lu(Ye(hn(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Mu(Ye(va(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Ti=E({norm_:jv});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qv(n,e=null,t=!1){return Ti(n,"euclidean",e,t)}const Kv=E({euclideanNorm_:qv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xv(n){const t={x:S(n,"x","exp")};return O.runKernel(Oc,t)}const Jn=E({exp_:Xv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yv(n,e=0){const t=S(n,"x","expandDims","string_or_numeric");I(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},s={dim:e};return O.runKernel(Fc,r,s)}const mn=E({expandDims_:Yv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qv(n){const t={x:S(n,"x","expm1")};return O.runKernel(af,t)}const Zv=E({expm1_:Qv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jv(n,e){const t=S(n,"x","tile","string_or_numeric");I(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const r={x:t},s={reps:e};return O.runKernel(ga,r,s)}const Xs=E({tile_:Jv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eS(n,e,t,r="float32"){e==null&&(e=n);const s=it([n,e],r),a=n<=e?n:e;for(let i=0;i<a;++i)s.set(1,i,i);const o=z(s.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return Xs(mn(o,0),[t[0],1,1]);if(t.length===2)return Xs(mn(mn(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return Xs(mn(mn(mn(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const Bm=E({eye_:eS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tS(n){const t={x:S(n,"x","floor","float32")};return O.runKernel(Pc,t)}const Vm=E({floor_:tS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nS(n,e,t=0,r=0){const s=S(n,"x","gather"),a=S(e,"indices","gather","int32"),o={x:s,indices:a},i={axis:t,batchDims:r};return O.runKernel(Mc,o,i)}const Wm=E({gather_:nS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rS(n,e){let t=S(n,"a","greater","string_or_numeric"),r=S(e,"b","greater","string_or_numeric");[t,r]=dt(t,r),Ne(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(Bc,s)}const Ci=E({greater_:rS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sS(n,e){let t=S(n,"a","greaterEqual","string_or_numeric"),r=S(e,"b","greaterEqual","string_or_numeric");[t,r]=dt(t,r),Ne(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(Vc,s)}const Um=E({greaterEqual_:sS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aS(n){const t={x:S(n,"x","isFinite")};return O.runKernel(lf,t)}const oS=E({isFinite_:aS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iS(n){const t={x:S(n,"x","isInf")};return O.runKernel(pf,t)}const uS=E({isInf_:iS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cS(n){const t={x:S(n,"x","isNaN")};return O.runKernel(df,t)}const lS=E({isNaN_:cS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pS(n,e=.2){const r={x:S(n,"x","leakyRelu")},s={alpha:e};return O.runKernel(Ho,r,s)}const zm=E({leakyRelu_:pS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dS(n,e){let t=S(n,"a","less","string_or_numeric"),r=S(e,"b","less","string_or_numeric");[t,r]=dt(t,r),Ne(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(Wc,s)}const hS=E({less_:dS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fS(n,e){let t=S(n,"a","lessEqual","string_or_numeric"),r=S(e,"b","lessEqual","string_or_numeric");[t,r]=dt(t,r),Ne(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(Uc,s)}const Gl=E({lessEqual_:fS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mS(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const r={start:n,stop:e,num:t};return O.runKernel(hf,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gS(n,e=5,t=1,r=1,s=.5){const a=S(n,"x","localResponseNormalization");I(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),I(gs(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=a,i=!1;a.rank===3&&(i=!0,o=z(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const u={x:o},l={depthRadius:e,bias:t,alpha:r,beta:s},c=O.runKernel(mf,u,l);return i?z(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const yS=E({localResponseNormalization_:gS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xS(n){const t={x:S(n,"x","log","float32")};return O.runKernel(zc,t)}const sa=E({log_:xS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bS(n){const t={x:S(n,"x","log1p")};return O.runKernel(ff,t)}const Gm=E({log1p_:bS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function er(n){return O.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wS(n){const t={x:S(n,"x","softplus")};return O.runKernel(kf,t)}const Hm=E({softplus_:wS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vS(n){const e=S(n,"x","logSigmoid");return er(r=>({value:Xn(Hm(Xn(r))),gradFunc:o=>pe(o,Yn(Xn(r)))}))(e)}const SS=E({logSigmoid_:vS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $S(n,e){let t=S(n,"a","sub"),r=S(e,"b","sub");[t,r]=dt(t,r);const s={a:t,b:r};return O.runKernel(vl,s)}const ke=E({sub_:$S});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IS(n,e=-1){const t=S(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return er((s,a)=>{const i=fs(s,e,!0),u=ke(s,i),l=ke(tt(u,"float32"),sa(Ye(Jn(u),e,!0)));return a([l]),{value:l,gradFunc:(p,d)=>{const[h]=d,f=!0,m=Jn(h);return ke(p,pe(Ye(p,e,f),m))}}})(t)}const TS=E({logSoftmax_:IS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CS(n,e=null,t=!1){const r=S(n,"x","logSumExp"),s=ct(e,r.shape),a=fs(r,s,!0),o=ke(r,a),i=Jn(o),u=Ye(i,s),l=sa(u),c=Pe(z(a,l.shape),l);if(t){const p=mt(c.shape,s);return z(c,p)}return c}const jm=E({logSumExp_:CS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _S(n,e){const t=S(n,"a","logicalAnd","bool"),r=S(e,"b","logicalAnd","bool");Ne(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(Gc,s)}const co=E({logicalAnd_:_S});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kS(n){const t={x:S(n,"x","logicalNot","bool")};return O.runKernel(Hc,t)}const qm=E({logicalNot_:kS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NS(n,e){const t=S(n,"a","logicalOr","bool"),r=S(e,"b","logicalOr","bool");Ne(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(jc,s)}const Km=E({logicalOr_:NS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ES(n,e){const t=S(n,"a","logicalXor","bool"),r=S(e,"b","logicalXor","bool");return Ne(t.shape,r.shape),co(Km(n,e),qm(co(n,e)))}const RS=E({logicalXor_:ES});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wa=2147483648;function AS(n,e,t="left"){const r=S(n,"sortedSequence","searchSorted"),s=S(e,"values","searchSorted"),a=r.shape[r.shape.length-1],o=s.shape[s.shape.length-1],i=z(r,[-1,a]),u=z(s,[-1,o]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(V(u.shape)>=Wa)throw new Error(`values tensor size must less than ${Wa}`);if(i.shape[1]>=Wa)throw new Error(`trailing dim_size must less than ${Wa} for int32 output type, was ${i.shape[1]}`);const l={sortedSequence:i,values:u},c={side:t};return O.runKernel(If,l,c)}const Hl=E({searchSorted_:AS});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OS(n,e){return Hl(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FS(n,e,t,r,s){const a=S(n,"x","maxPool"),o=1;let i=a,u=!1;a.rank===3&&(u=!0,i=z(a,[1,a.shape[0],a.shape[1],a.shape[2]])),I(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),I(en(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),Sn("maxPool",r,s);const l={x:i},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s},p=O.runKernel(qo,l,c);return u?z(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Xm=E({maxPool_:FS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DS(n,e=[1,1,1],t,r,s,a="NDHWC"){const o=S(n,"x","maxPool3d");let i=o,u=!1;o.rank===4&&(u=!0,i=z(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),I(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),I(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Sn("maxPool3d",r,s);const l={x:i},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:a},p=O.runKernel(gf,l,c);return u?z(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const PS=E({maxPool3d_:DS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LS(n,e,t,r,s=!1){const o={x:S(n,"x","maxPoolWithArgmax")},i={filterSize:e,strides:t,pad:r,includeBatchInIndex:s},u=O.runKernel(yf,o,i);return{result:u[0],indexes:u[1]}}const MS=E({maxPoolWithArgmax_:LS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BS(n,e){let t=S(n,"a","maximum"),r=S(e,"b","maximum");[t,r]=dt(t,r),t.dtype==="bool"&&(t=tt(t,"int32"),r=tt(r,"int32")),Ne(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(qc,s)}const VS=E({maximum_:BS});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WS(n,e=null,t=!1){const s={x:S(n,"x","mean")},a={axis:e,keepDims:t};return O.runKernel(Ko,s,a)}const lo=E({mean_:WS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fr(n,e="float32"){if(e==="complex64"){const r=fr(n,"float32"),s=fr(n,"float32");return hr(r,s)}const t=dr(V(n),e);return O.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dr(n,e="float32"){if(e==="complex64"){const r=Dr(n,"float32"),s=fr(n,"float32");return hr(r,s)}const t=Ah(V(n),e);return O.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function US(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let r=S(n,"x","meshgrid",n instanceof ot?n.dtype:"float32");if(e===void 0)return[r];let s=S(e,"y","meshgrid",e instanceof ot?e.dtype:"float32");const a=V(r.shape),o=V(s.shape);return t==="xy"?(r=z(r,[1,-1]),s=z(s,[-1,1]),[Ge(Dr([o,1],r.dtype),r),Ge(s,Dr([1,a],s.dtype))]):(r=z(r,[-1,1]),s=z(s,[1,-1]),[Ge(r,Dr([1,o],r.dtype)),Ge(Dr([a,1],s.dtype),s)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zS(n,e){let t=S(n,"a","minimum"),r=S(e,"b","minimum");[t,r]=dt(t,r),t.dtype==="bool"&&(t=tt(t,"int32"),r=tt(r,"int32")),Ne(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(Kc,s)}const jl=E({minimum_:zS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GS(n,e,t){I(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const r=S(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");I(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=t==="reflect"?1:0;for(let i=0;i<r.rank;i++)I(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),I(e[i][0]>=0&&e[i][0]<=r.shape[i]-s&&e[i][1]>=0&&e[i][1]<=r.shape[i]-s,()=>`Padding in dimension ${i} cannot be greater than or equal to ${r.shape[i]-s} or less than 0 for input of shape ${r.shape}`);const a={paddings:e,mode:t},o={x:r};return O.runKernel(Yo,o,a)}const Ym=E({mirrorPad_:GS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HS(n,e){let t=S(n,"a","mod"),r=S(e,"b","mod");[t,r]=dt(t,r);const s={a:t,b:r};return O.runKernel(xf,s)}const jS=E({mod_:HS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qS(n,e=null,t=!1){n=S(n,"x","moments");const r=ct(e,n.shape),s=lo(n,r,t);let a=s.shape;t||(a=mt(s.shape,r));const o=va(ke(tt(n,"float32"),z(s,a))),i=lo(o,r,t);return{mean:s,variance:i}}const KS=E({moments_:qS});function XS(n,e,t,r){const s=S(e,"data","multiRNNCell"),a=so(t,"c","multiRNNCell"),o=so(r,"h","multiRNNCell");let i=s;const u=[];for(let p=0;p<n.length;p++){const d=n[p](i,a[p],o[p]);u.push(d[0]),u.push(d[1]),i=d[1]}const l=[],c=[];for(let p=0;p<u.length;p+=2)l.push(u[p]),c.push(u[p+1]);return[l,c]}const YS=E({multiRNNCell_:XS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QS(n,e,t,r=!1){const s=S(n,"logits","multinomial"),a=s.size,o=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const u={logits:o===1?z(s,[1,-1]):s},l={numSamples:e,seed:t,normalized:r},c=O.runKernel(bf,u,l);return o===1?z(c,[c.size]):c}const ZS=E({multinomial_:QS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JS(n,e){let t=S(n,"a","notEqual","string_or_numeric"),r=S(e,"b","notEqual","string_or_numeric");[t,r]=dt(t,r),Ne(t.shape,r.shape);const s={a:t,b:r};return O.runKernel(Qc,s)}const Qm=E({notEqual_:JS});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e$(n){const t={x:S(n,"x","onesLike")};return O.runKernel(Zc,t)}const t$=E({onesLike_:e$});function n$(n,e){const t=S(n,"v1","outerProduct"),r=S(e,"v2","outerProduct");I(t.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${r.rank}.`);const s=z(t,[-1,1]),a=z(r,[1,-1]);return Ge(s,a)}const r$=E({outerProduct_:n$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s$(n,e,t=0){const r=S(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:t},a={x:r};return O.runKernel(ti,a,s)}const mr=E({pad_:s$});function a$(n,e,t=0){return I(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),mr(n,[e],t)}const o$=E({pad1d_:a$});function i$(n,e,t=0){return I(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),mr(n,e,t)}const u$=E({pad2d_:i$});function c$(n,e,t=0){return I(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),mr(n,e,t)}const l$=E({pad3d_:c$});function p$(n,e,t=0){return I(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),mr(n,e,t)}const d$=E({pad4d_:p$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h$(n,e,t){const r=S(n,"x","spaceToBatchND");I(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),I(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),I(r.shape.reduce((o,i,u)=>u>0&&u<=e.length?o&&(i+t[u-1][0]+t[u-1][1])%e[u-1]===0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},a={blockShape:e,paddings:t};return O.runKernel(dl,s,a)}const Zm=E({spaceToBatchND_:h$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f$(n,e,t,r,s,a,o){s==null&&(s=[1,1]),a==null&&(a=1),r===0&&(r="valid");const i=S(n,"x","maxPool");let u=i,l=!1;i.rank===3&&(l=!0,u=z(i,[1,i.shape[0],i.shape[1],i.shape[2]])),I(en(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);const c=nr(u.shape,e,a,s,r),p=[c.dilationHeight,c.dilationWidth];let d;r==="same"?d=g$([c.filterHeight,c.filterWidth],p):d=[[0,0],[0,0]];const h=p[0]===1&&p[1]===1,[f,m]=m$([c.inHeight,c.inWidth],p,d),g=h?r:"valid",y=h?u:Zm(u,p,f),w=(t==="avg"?()=>Em(y,e,a,g,o):()=>Xm(y,e,a,g,o))(),v=h?w:Rm(w,p,m);return l?z(v,[v.shape[1],v.shape[2],v.shape[3]]):v}function m$(n,e,t){const r=t.map(c=>c[0]),s=t.map(c=>c[1]),a=n.concat(r,s),o=e.map((c,p)=>(c-a[p]%c)%c),i=s.map((c,p)=>c+o[p]),u=e.map((c,p)=>[r[p],i[p]]),l=e.map((c,p)=>[0,o[p]]);return[u,l]}function g$(n,e){const r=n.map((o,i)=>o+(o-1)*(e[i]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),a=r.map((o,i)=>o-s[i]);return r.map((o,i)=>[s[i],a[i]])}const y$=E({pool_:f$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x$(n,e){const t=S(n,"x","prelu"),r=S(e,"alpha","prelu"),s={x:t,alpha:r};return O.runKernel(ni,s)}const Jm=E({prelu_:x$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b$(n,e=null,t=!1){let r=S(n,"x","prod");r.dtype==="bool"&&(r=tt(r,"int32"));const s={x:r},a={axis:e,keepDims:t};return O.runKernel(ri,s,a)}const w$=E({prod_:b$});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v$(n,e,t,r){const s=n.map((c,p)=>S(c,`tensors${p}`,"raggedGather","int32")),a=S(e,"paramsDenseValues","raggedGather"),o=S(t,"indices","raggedGather","int32"),i={paramsNestedSplits:s,paramsDenseValues:a,indices:o},u={outputRaggedRank:r},l=O.runKernel(wf,i,u);return{outputNestedSplits:l.slice(0,l.length-1),outputDenseValues:l[l.length-1]}}const S$=E({raggedGather_:v$});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $$(n,e,t,r,s){const a=S(n,"shape","raggedTensorToTensor","int32"),o=S(e,"values","raggedTensorToTensor"),i=S(t,"defaultValue","raggedTensorToTensor",o.dtype),u=r.map((p,d)=>S(p,`tensors${d}`,"raggedTensorToTensor","int32")),l={shape:a,values:o,defaultValue:i,rowPartitionTensors:u},c={rowPartitionTypes:s};return O.runKernel(vf,l,c)}const I$=E({raggedTensorToTensor_:$$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T$(n,e,t){const r=V(n);let s=null;if(t==null||t==="float32")s=new Float32Array(r);else if(t==="int32")s=new Int32Array(r);else if(t==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${t}`);for(let a=0;a<r;a++)s[a]=e();return O.makeTensor(s,n,t)}const C$=E({rand_:T$});var Bu={},_$={get exports(){return Bu},set exports(n){Bu=n}};(function(n){(function(e,t,r){function s(u){var l=this,c=i();l.next=function(){var p=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=p-(l.c=p|0)},l.c=1,l.s0=c(" "),l.s1=c(" "),l.s2=c(" "),l.s0-=c(u),l.s0<0&&(l.s0+=1),l.s1-=c(u),l.s1<0&&(l.s1+=1),l.s2-=c(u),l.s2<0&&(l.s2+=1),c=null}function a(u,l){return l.c=u.c,l.s0=u.s0,l.s1=u.s1,l.s2=u.s2,l}function o(u,l){var c=new s(u),p=l&&l.state,d=c.next;return d.int32=function(){return c.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,p&&(typeof p=="object"&&a(p,c),d.state=function(){return a(c,{})}),d}function i(){var u=4022871197,l=function(c){c=String(c);for(var p=0;p<c.length;p++){u+=c.charCodeAt(p);var d=.02519603282416938*u;u=d>>>0,d-=u,d*=u,u=d>>>0,d-=u,u+=d*4294967296}return(u>>>0)*23283064365386963e-26};return l}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.alea=o})(wn,n,!1)})(_$);var Vu={},k$={get exports(){return Vu},set exports(n){Vu=n}};(function(n){(function(e,t,r){function s(i){var u=this,l="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var p=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^p^p>>>8},i===(i|0)?u.x=i:l+=i;for(var c=0;c<l.length+64;c++)u.x^=l.charCodeAt(c)|0,u.next()}function a(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u}function o(i,u){var l=new s(i),c=u&&u.state,p=function(){return(l.next()>>>0)/4294967296};return p.double=function(){do var d=l.next()>>>11,h=(l.next()>>>0)/4294967296,f=(d+h)/(1<<21);while(f===0);return f},p.int32=l.next,p.quick=p,c&&(typeof c=="object"&&a(c,l),p.state=function(){return a(l,{})}),p}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o})(wn,n,!1)})(k$);var Wu={},N$={get exports(){return Wu},set exports(n){Wu=n}};(function(n){(function(e,t,r){function s(i){var u=this,l="";u.next=function(){var p=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(p^p<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,i===(i|0)?u.x=i:l+=i;for(var c=0;c<l.length+64;c++)u.x^=l.charCodeAt(c)|0,c==l.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function a(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u.v=i.v,u.d=i.d,u}function o(i,u){var l=new s(i),c=u&&u.state,p=function(){return(l.next()>>>0)/4294967296};return p.double=function(){do var d=l.next()>>>11,h=(l.next()>>>0)/4294967296,f=(d+h)/(1<<21);while(f===0);return f},p.int32=l.next,p.quick=p,c&&(typeof c=="object"&&a(c,l),p.state=function(){return a(l,{})}),p}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o})(wn,n,!1)})(N$);var Uu={},E$={get exports(){return Uu},set exports(n){Uu=n}};(function(n){(function(e,t,r){function s(i){var u=this;u.next=function(){var c=u.x,p=u.i,d,h;return d=c[p],d^=d>>>7,h=d^d<<24,d=c[p+1&7],h^=d^d>>>10,d=c[p+3&7],h^=d^d>>>3,d=c[p+4&7],h^=d^d<<7,d=c[p+7&7],d=d^d<<13,h^=d^d<<9,c[p]=h,u.i=p+1&7,h};function l(c,p){var d,h=[];if(p===(p|0))h[0]=p;else for(p=""+p,d=0;d<p.length;++d)h[d&7]=h[d&7]<<15^p.charCodeAt(d)+h[d+1&7]<<13;for(;h.length<8;)h.push(0);for(d=0;d<8&&h[d]===0;++d);for(d==8?h[7]=-1:h[d],c.x=h,c.i=0,d=256;d>0;--d)c.next()}l(u,i)}function a(i,u){return u.x=i.x.slice(),u.i=i.i,u}function o(i,u){i==null&&(i=+new Date);var l=new s(i),c=u&&u.state,p=function(){return(l.next()>>>0)/4294967296};return p.double=function(){do var d=l.next()>>>11,h=(l.next()>>>0)/4294967296,f=(d+h)/(1<<21);while(f===0);return f},p.int32=l.next,p.quick=p,c&&(c.x&&a(c,l),p.state=function(){return a(l,{})}),p}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o})(wn,n,!1)})(E$);var zu={},R$={get exports(){return zu},set exports(n){zu=n}};(function(n){(function(e,t,r){function s(i){var u=this;u.next=function(){var c=u.w,p=u.X,d=u.i,h,f;return u.w=c=c+1640531527|0,f=p[d+34&127],h=p[d=d+1&127],f^=f<<13,h^=h<<17,f^=f>>>15,h^=h>>>12,f=p[d]=f^h,u.i=d,f+(c^c>>>16)|0};function l(c,p){var d,h,f,m,g,y=[],x=128;for(p===(p|0)?(h=p,p=null):(p=p+"\0",h=0,x=Math.max(x,p.length)),f=0,m=-32;m<x;++m)p&&(h^=p.charCodeAt((m+32)%p.length)),m===0&&(g=h),h^=h<<10,h^=h>>>15,h^=h<<4,h^=h>>>13,m>=0&&(g=g+1640531527|0,d=y[m&127]^=h+g,f=d==0?f+1:0);for(f>=128&&(y[(p&&p.length||0)&127]=-1),f=127,m=4*128;m>0;--m)h=y[f+34&127],d=y[f=f+1&127],h^=h<<13,d^=d<<17,h^=h>>>15,d^=d>>>12,y[f]=h^d;c.w=g,c.X=y,c.i=f}l(u,i)}function a(i,u){return u.i=i.i,u.w=i.w,u.X=i.X.slice(),u}function o(i,u){i==null&&(i=+new Date);var l=new s(i),c=u&&u.state,p=function(){return(l.next()>>>0)/4294967296};return p.double=function(){do var d=l.next()>>>11,h=(l.next()>>>0)/4294967296,f=(d+h)/(1<<21);while(f===0);return f},p.int32=l.next,p.quick=p,c&&(c.X&&a(c,l),p.state=function(){return a(l,{})}),p}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o})(wn,n,!1)})(R$);var Gu={},A$={get exports(){return Gu},set exports(n){Gu=n}};(function(n){(function(e,t,r){function s(i){var u=this,l="";u.next=function(){var p=u.b,d=u.c,h=u.d,f=u.a;return p=p<<25^p>>>7^d,d=d-h|0,h=h<<24^h>>>8^f,f=f-p|0,u.b=p=p<<20^p>>>12^d,u.c=d=d-h|0,u.d=h<<16^d>>>16^f,u.a=f-p|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,i===Math.floor(i)?(u.a=i/4294967296|0,u.b=i|0):l+=i;for(var c=0;c<l.length+20;c++)u.b^=l.charCodeAt(c)|0,u.next()}function a(i,u){return u.a=i.a,u.b=i.b,u.c=i.c,u.d=i.d,u}function o(i,u){var l=new s(i),c=u&&u.state,p=function(){return(l.next()>>>0)/4294967296};return p.double=function(){do var d=l.next()>>>11,h=(l.next()>>>0)/4294967296,f=(d+h)/(1<<21);while(f===0);return f},p.int32=l.next,p.quick=p,c&&(typeof c=="object"&&a(c,l),p.state=function(){return a(l,{})}),p}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o})(wn,n,!1)})(A$);var Hu={},O$={get exports(){return Hu},set exports(n){Hu=n}};(function(n){(function(e,t,r){var s=256,a=6,o=52,i="random",u=r.pow(s,a),l=r.pow(2,o),c=l*2,p=s-1,d;function h(v,$,C){var k=[];$=$==!0?{entropy:!0}:$||{};var R=y(g($.entropy?[v,w(t)]:v==null?x():v,3),k),F=new f(k),D=function(){for(var M=F.g(a),U=u,j=0;M<l;)M=(M+j)*s,U*=s,j=F.g(1);for(;M>=c;)M/=2,U/=2,j>>>=1;return(M+j)/U};return D.int32=function(){return F.g(4)|0},D.quick=function(){return F.g(4)/4294967296},D.double=D,y(w(F.S),t),($.pass||C||function(M,U,j,Y){return Y&&(Y.S&&m(Y,F),M.state=function(){return m(F,{})}),j?(r[i]=M,U):M})(D,R,"global"in $?$.global:this==r,$.state)}function f(v){var $,C=v.length,k=this,R=0,F=k.i=k.j=0,D=k.S=[];for(C||(v=[C++]);R<s;)D[R]=R++;for(R=0;R<s;R++)D[R]=D[F=p&F+v[R%C]+($=D[R])],D[F]=$;(k.g=function(M){for(var U,j=0,Y=k.i,Q=k.j,ae=k.S;M--;)U=ae[Y=p&Y+1],j=j*s+ae[p&(ae[Y]=ae[Q=p&Q+U])+(ae[Q]=U)];return k.i=Y,k.j=Q,j})(s)}function m(v,$){return $.i=v.i,$.j=v.j,$.S=v.S.slice(),$}function g(v,$){var C=[],k=typeof v,R;if($&&k=="object")for(R in v)try{C.push(g(v[R],$-1))}catch(F){}return C.length?C:k=="string"?v:v+"\0"}function y(v,$){for(var C=v+"",k,R=0;R<C.length;)$[p&R]=p&(k^=$[p&R]*19)+C.charCodeAt(R++);return w($)}function x(){try{var v;return d&&(v=d.randomBytes)?v=v(s):(v=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues(v)),w(v)}catch(k){var $=e.navigator,C=$&&$.plugins;return[+new Date,e,C,e.screen,w(t)]}}function w(v){return String.fromCharCode.apply(0,v)}if(y(r.random(),t),n.exports){n.exports=h;try{d=On}catch(v){}}else r["seed"+i]=h})(typeof self!="undefined"?self:wn,[],Math)})(O$);var F$=Bu,D$=Vu,P$=Wu,L$=Uu,M$=zu,B$=Gu,Xr=Hu;Xr.alea=F$;Xr.xor128=D$;Xr.xorwow=P$;Xr.xorshift7=L$;Xr.xor4096=M$;Xr.tychei=B$;var ql=Xr;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kl{constructor(e,t,r,s,a){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=a||Math.random();this.random=ql.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,t,r=!1;for(;!r;){let s,a,o;do s=2*this.random()-1,a=2*this.random()-1,o=s*s+a*a;while(o>=1||o===0);const i=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*s*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class V${constructor(e,t,r,s){this.alpha=e,this.beta=1/t,this.dtype=r;const a=s||Math.random();this.randu=ql.alea(a.toString()),this.randn=new Kl(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,r,s,a,o;for(;;){do s=this.randn.nextValue(),o=1+this.c*s;while(o<=0);if(o*=o*o,e=s*s,t=1-.331*e*e,r=.5*e+this.d*(1-o+Math.log(o)),a=this.randu(),a<t||Math.log(a)<r)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class W${constructor(e=0,t=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=ql.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U$(n,e,t=1,r="float32",s){if(t==null&&(t=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const a=new V$(e,t,r,s),o=it(n,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const z$=E({randomGamma_:U$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G$(n,e=0,t=1,r,s){if(r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const a=new Kl(e,t,r,!1,s),o=it(n,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const eg=E({randomNormal_:G$});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H$(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return eg(n,0,1,e,t)}const j$=E({randomStandardNormal_:H$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q$(n,e=0,t=1,r="float32",s){const a=it(n,r),o=new W$(e,t,null,s);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const tg=E({randomUniform_:q$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aa(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");const s={start:n,stop:e,step:t,dtype:r};return O.runKernel(tl,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K$(n){const t={x:S(n,"x","reciprocal")};return O.runKernel($f,t)}const X$=E({reciprocal_:K$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y$(n){const t={x:S(n,"x","relu")};return O.runKernel(nl,t)}const _i=E({relu_:Y$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q$(n){const t={x:S(n,"x","relu6")};return O.runKernel(sl,t)}const ng=E({relu6_:Q$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z$(n,e){const r={x:S(n,"x","reverse")},s={dims:e};return O.runKernel(oi,r,s)}const Gr=E({reverse_:Z$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J$(n){const e=S(n,"x","reverse");return I(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Gr(e,0)}const eI=E({reverse1d_:J$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tI(n,e){const t=S(n,"x","reverse");return I(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Gr(t,e)}const nI=E({reverse2d_:tI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rI(n,e){const t=S(n,"x","reverse");return I(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Gr(t,e)}const sI=E({reverse3d_:rI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aI(n,e){const t=S(n,"x","reverse");return I(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Gr(t,e)}const oI=E({reverse4d_:aI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iI(n){const t={x:S(n,"x","round")};return O.runKernel(al,t)}const rg=E({round_:iI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uI(n){const t={x:S(n,"x","rsqrt","float32")};return O.runKernel(ol,t)}const cI=E({rsqrt_:uI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lI(n){const t={x:S(n,"x","selu")};return O.runKernel(Tf,t)}const pI=E({selu_:lI});function dI(n,e,t,r,s,a=[1,1],o="NHWC"){const i=S(n,"x","separableConv2d"),u=S(e,"depthwiseFilter","separableConv2d"),l=S(t,"pointwiseFilter","separableConv2d");let c=i,p=!1;if(i.rank===3&&(p=!0,c=z(i,[1,i.shape[0],i.shape[1],i.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");I(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),I(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),I(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),I(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),I(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const d=u.shape[2],h=u.shape[3];I(l.shape[2]===d*h,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*h}, but got ${l.shape[2]}.`);const f=Vl(c,u,r,s,o,a),g=Ii(f,l,1,"valid",o);return p?z(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const hI=E({separableConv2d_:dI});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fI(n,e){return se(this,null,function*(){const t=S(n,"x","setdiff1d"),r=S(e,"y","setdiff1d");I(t.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${r.dtype}).`),I(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),I(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=yield t.data(),a=yield r.data(),o=new Set(a);let i=0;for(let c=0;c<s.length;c++)o.has(s[c])||i++;const u=new ta([i],t.dtype),l=new ta([i],"int32");for(let c=0,p=0;c<s.length;c++)o.has(s[c])||(u.values[p]=s[c],l.values[p]=c,p++);return[u.toTensor(),l.toTensor()]})}const mI=fI;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gI(n){const t={x:S(n,"x","sign")};return O.runKernel(_f,t)}const yI=E({sign_:gI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xI(n){const t={x:S(n,"x","sin","float32")};return O.runKernel(cl,t)}const bI=E({sin_:xI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wI(n){const t={x:S(n,"x","sinh")};return O.runKernel(Cf,t)}const vI=E({sinh_:wI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SI(n,e,t){const r=S(n,"x","slice1d");return I(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Ie(r,[e],[t])}const $I=E({slice1d_:SI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function II(n,e,t){const r=S(n,"x","slice2d");return I(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Ie(r,e,t)}const TI=E({slice2d_:II});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CI(n,e,t){const r=S(n,"x","slice3d");return I(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Ie(r,e,t)}const _I=E({slice3d_:CI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kI(n,e,t){const r=S(n,"x","slice4d");return I(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Ie(r,e,t)}const NI=E({slice4d_:kI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EI(n,e=-1){const t=S(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const r={logits:t},s={dim:e};return O.runKernel(ci,r,s)}const RI=E({softmax_:EI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AI(n){I(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return O.runKernel(of,e)}const Xl=E({fft_:AI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OI(n){I(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return O.runKernel(uf,e)}const po=E({ifft_:OI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FI(n){const e=n.shape[n.shape.length-1],t=n.size/e;let r;if(e<=2){const s=z(n,[t,e]);r=po(s)}else{const s=[t,2*(e-1)],a=z(na(n),[t,e]),o=z(xi(n),[t,e]),i=Gr(Ie(a,[0,1],[t,e-2]),1),u=pe(Gr(Ie(o,[0,1],[t,e-2]),1),Re(-1)),l=xt([a,i],1),c=xt([o,u],1),p=z(hr(l,c),[s[0],s[1]]);r=po(p)}if(r=na(r),n.rank===3&&n.shape[0]!==0){const s=r,a=n.shape[0];r=z(r,[a,r.shape[0]/a,r.shape[1]]),s.dispose()}return r}const sg=E({irfft_:FI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DI(n,e,t=0){const s={x:S(n,"x","split")},a={numOrSizeSplits:e,axis:t};return O.runKernel(hl,s,a)}const oa=E({split_:DI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PI(n,e){I(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const r=n.size/t;let s;if(e!=null&&e<t){const f=n.shape.map(g=>0),m=n.shape.map(g=>g);m[n.shape.length-1]=e,s=Ie(n,f,m),t=e}else if(e!=null&&e>t){const f=n.shape.map(m=>m);f[n.shape.length-1]=e-t,s=xt([n,fr(f)],n.shape.length-1),t=e}else s=n;const a=Wl(s),o=z(hr(s,a),[r,t]),i=Xl(o),u=Math.floor(t/2)+1,l=na(i),c=xi(i),p=oa(l,[u,t-u],l.shape.length-1),d=oa(c,[u,t-u],c.shape.length-1),h=s.shape.slice();return h[s.shape.length-1]=u,z(hr(p[0],d[0]),h)}const Yl=E({rfft_:PI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LI(n,e){let t=S(n,"a","squaredDifference"),r=S(e,"b","squaredDifference");[t,r]=dt(t,r),Ne(t.shape,r.shape);const s={a:t,b:r},a={};return O.runKernel(yl,s,a)}const ag=E({squaredDifference_:LI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MI(n,e){const t=S(n,"x","squeeze","string_or_numeric");return z(t,yr(t.shape,e).newShape)}const ze=E({squeeze_:MI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BI(n,e=0){const t=so(n,"tensors","stack","string_or_numeric");I(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&I(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const r=t,s={axis:e};return O.runKernel(Jc,r,s)}const tr=E({stack_:BI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VI(n,e=0){const r={x:S(n,"x","step")},s={alpha:e};return O.runKernel(fi,r,s)}const og=E({step_:VI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WI(n,e,t,r,s=0,a=0,o=0,i=0,u=0){const c={x:S(n,"x","stridedSlice","string_or_numeric")},p={begin:e,end:t,strides:r,beginMask:s,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};return O.runKernel(pi,c,p)}const UI=E({stridedSlice_:WI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zI(n){const t={x:S(n,"x","tan","float32")};return O.runKernel(Sl,t)}const GI=E({tan_:zI});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mt(n,e){Ts(n);const t=xr(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return br(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vn(n,e,t){if(Ts(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=xr(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return br(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HI(n,e,t){if(Ts(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=xr(n,t);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return br(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jI(n,e,t){if(Ts(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=xr(n,t);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return br(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qI(n,e,t){if(Ts(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=xr(n,t);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,br(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KI(n,e=1,t=!0){const r=S(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const a={x:r},o={k:e,sorted:t},[i,u]=O.runKernel(di,a,o);return{values:i,indices:u}}const XI=E({topk_:KI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YI(n,e=0,t=1,r,s){if(r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new Kl(e,t,r,!0,s),o=it(n,r);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const QI=E({truncatedNormal_:YI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZI(n,e=0){const t=S(n,"x","unique","string_or_numeric");I(t.rank>0,()=>"The input tensor must be at least 1D");const r={x:t},s={axis:e},[a,o]=O.runKernel(Rf,r,s);return{values:a,indices:o}}const JI=E({unique_:ZI});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e2(n,e,t){const r=S(n,"x","unsortedSegmentSum"),s=S(e,"segmentIds","unsortedSegmentSum","int32");I(gs(t),()=>"numSegments must be of dtype int");const a={x:r,segmentIds:s},o={numSegments:t};return O.runKernel(Af,a,o)}const t2=E({unsortedSegmentSum_:e2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n2(n,e=0){const t=S(n,"x","unstack","string_or_numeric");I(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const r={value:t},s={axis:e};return O.runKernel(Il,r,s)}const Yr=E({unstack_:n2});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r2(n,e){return Hl(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s2(n,e=!0,t,r){return O.makeVariable(n,e,t,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ig(n,e){const t=[];for(let a=0;a<e.length;a++)e[a]&&t.push(a);const r=it(n,"int32"),s=it([t.length,n.length],"int32");for(let a=0;a<t.length;a++){const o=r.indexToLoc(t[a]),i=a*n.length;s.values.set(o,i)}return s.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a2(n){return se(this,null,function*(){const e=S(n,"condition","whereAsync","bool"),t=yield e.data(),r=ig(e.shape,t);return n!==e&&e.dispose(),r})}const ug=a2;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o2(n,e,t){return se(this,null,function*(){const r=S(n,"tensor","boolMask"),s=S(e,"mask","boolMask","bool"),a=t==null?0:t,o=s.rank,i=r.shape;I(o>0,()=>"mask cannot be scalar"),Zt(i.slice(a,a+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let m=a;m<a+o;m++)u*=i[m];const l=i.slice(0,a).concat([u],i.slice(a+o)),c=z(r,l),p=z(s,[-1]),d=yield ug(p),h=ze(d,[1]),f=Wm(c,h,a);return n!==r&&r.dispose(),e!==s&&s.dispose(),h.dispose(),c.dispose(),p.dispose(),d.dispose(),f})}const i2=o2;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u2(n,e,t,r,s=!0){const a=S(n,"v","movingAverage"),o=S(e,"x","movingAverage"),i=S(t,"decay","movingAverage");$0(a,o),I(pt(a.shape,o.shape),()=>"Shape mismatch in v and x");const u=Re(1),l=ke(u,i);let c=pe(ke(o,a),l);if(s){I(r!=null,()=>"When using zeroDebias: true, step is required.");const p=S(r,"step","movingAverage");c=Me(c,ke(u,zl(i,p)))}return Pe(a,c)}const c2=E({movingAverage_:u2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l2(n,e,t){const r=S(n,"indices","scatterND","int32"),s=S(e,"updates","scatterND");ym(s,r,t);const a={indices:r,updates:s},o={shape:t};return O.runKernel(ii,a,o)}const p2=E({scatterND_:l2});function d2(n,e,t,r){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const s=n.rank>0?n.shape[0]:1,a=n.rank>1?n.shape[1]:1;if(t.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${a}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2(n,e,t,r=0){const s=S(n,"sparseIndices","sparseToDense","int32"),a=S(e,"sparseValues","sparseToDense","string_or_numeric"),o=S(r,"defaultValue","sparseToDense",a.dtype);d2(s,a,t,o);const i={sparseIndices:s,sparseValues:a,defaultValue:o},u={outputShape:t};return O.runKernel(Nf,i,u)}const f2=E({sparseToDense_:h2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m2(n,e){const t=S(e,"indices","gatherND","int32"),s={params:S(n,"x","gatherND","string_or_numeric"),indices:t};return O.runKernel(zo,s)}const g2=E({gatherND_:m2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y2(n,e){if(e==null)return n.shape.slice();if(pt(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let r=0;r<n.shape.length;r++)e[r]==null&&n.shape[r]!=null?t.push(n.shape[r]):t.push(e[r]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x2(n,e,t,r){const s=S(n,"x","dropout");if(I(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),I(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof ot?s.clone():s;const a=y2(s,t),o=1-e,i=Me(Vm(Pe(tg(a,0,1,"float32",r),o)),o);return pe(s,i)}const b2=E({dropout_:x2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cg(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function Ql(n,e,t){const r=1-n%2,s=new Float32Array(n);for(let a=0;a<n;++a){const o=2*Math.PI*a/(n+r-1);s[a]=e-t*Math.cos(o)}return Mt(s,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w2(n,e,t=1){return se(this,null,function*(){const r=S(n,"predictions","inTopK"),s=S(e,"targets","inTopK");I(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),I(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),Zt(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=r.shape[r.shape.length-1];I(t>0&&t<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${t}`);const o=yield r.data(),i=yield s.data(),[u,l]=[o.length/a,a],c=Zn("bool",u);for(let p=0;p<u;p++){const d=p*l,h=o.subarray(d,d+l),f=[];for(let m=0;m<h.length;m++)f.push({value:h[m],index:m});f.sort((m,g)=>g.value-m.value),c[p]=0;for(let m=0;m<t;m++)if(f[m].index===i[p]){c[p]=1;break}}return n!==r&&r.dispose(),e!==s&&s.dispose(),Dn(c,s.shape,"bool")})}const v2=w2;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S2(n,e,t,r,s,a="NHWC",o){let i=n;n.rank===3&&(i=z(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=z(e,[1,e.shape[0],e.shape[1],e.shape[2]])),I(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),I(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),I(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const l=a==="NHWC"?i.shape[3]:i.shape[1],c=a==="NHWC"?u.shape[3]:u.shape[1];I(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),I(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),Sn("conv2dDerFilter",s,o);const p={x:i,dy:u},d={strides:r,pad:s,dataFormat:a,dimRoundingMode:o,filterShape:t};return O.runKernel(Xh,p,d)}const $2=E({conv2DBackpropFilter_:S2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ki(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return pe(n,og(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function Ni(n,e){let t=e;const r=fm(n.shape,e.shape);return r.length>0&&(t=Ye(t,r)),z(t,n.shape)}function Ei(n,e,t,r){if(e==="linear")return n;if(e==="relu")return _i(n);if(e==="elu")return Pm(n);if(e==="relu6")return ng(n);if(e==="prelu")return Jm(n,t);if(e==="leakyrelu")return zm(n,r);if(e==="sigmoid")return Yn(n);throw new Error(`Unknown fused activation ${e}.`)}const Ri=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I2({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",Ri(O.state.gradientDepth,u)===!1){I(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let C=Ii(n,e,t,r,s,a,o);return i!=null&&(C=Pe(C,i)),Ei(C,u,l,c)}const p=S(n,"x","conv2d","float32"),d=S(e,"filter","conv2d","float32");let h=p,f=!1;p.rank===3&&(f=!0,h=z(p,[1,p.shape[0],p.shape[1],p.shape[2]])),I(h.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`),I(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),Sn("fused conv2d",r,o);const m=s==="NHWC"?h.shape[3]:h.shape[1];I(d.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${d.shape[2]}.`),I(en(t,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);const g=It(h.shape,d.shape,t,a,r,o);let y;i!=null&&(y=S(i,"bias","fused conv2d"),[y]=dt(y,p),s==="NHWC"?Ne(g.outShape,y.shape):(I(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),I(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let x;if(l!=null){const C=l.shape;if(I(C.length<=1||C.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${C.length}.`),C.length===1)I(C[0]===1||C[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the number of output channels (${g.outChannels}).`);else if(C.length===3)try{Ne(C,g.outShape)}catch(k){const R=`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(R)}x=S(l,"prelu weights","fused conv2d")}const w=(C,k)=>{I(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[R,F,D,M]=k,U=ki(C,D,u);I(ra(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const j=Fm(F.shape,U,R,t,r),Y=$2(F,U,R.shape,t,r),Q=[j,Y];if(M!=null){const ae=Ni(M,U);Q.push(ae)}return Q},v={x:h,filter:d,bias:y,preluActivationWeights:x},$={strides:t,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:c};return i==null?er((k,R,F)=>{let D=O.runKernel(Js,v,$);return F([R,k,D]),f&&(D=z(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:w}})(h,d):er((k,R,F,D)=>{let M=O.runKernel(Js,v,$);return D([R,k,M,F]),f&&(M=z(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:w}})(h,d,y)}const T2=E({fusedConv2d_:I2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C2(n,e,t,r,s,a=[1,1],o){let i=n;n.rank===3&&(i=z(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=z(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:i,dy:u},c={strides:r,pad:s,dimRoundingMode:o,dilations:a,filterShape:t};return O.runKernel(Jh,l,c)}const _2=E({depthwiseConv2dNativeBackpropFilter_:C2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k2(n,e,t,r,s,a=[1,1],o){let i=e,u=!1;e.rank===3&&(u=!0,i=z(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:i,filter:t},c={strides:r,pad:s,dimRoundingMode:o,dilations:a,inputShape:n},p=O.runKernel(ef,l,c);return u?z(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const N2=E({depthwiseConv2dNativeBackpropInput_:k2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E2({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(Ri(O.state.gradientDepth,u)===!1){let $=Vl(n,e,t,r,s,a,o);return i!=null&&($=Pe($,i)),Ei($,u,l,c)}const p=S(n,"x","depthwiseConv2d","float32"),d=S(e,"filter","depthwiseConv2d","float32");let h=p,f=!1;p.rank===3&&(f=!0,h=z(p,[1,p.shape[0],p.shape[1],p.shape[2]])),I(h.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),I(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),I(h.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),a==null&&(a=[1,1]),I(en(t,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),Sn("fused depthwiseConv2d",r,o);const m=It(h.shape,d.shape,t,a,r,o,!0);let g;i!=null&&(g=S(i,"bias","fused conv2d"),[g]=dt(g,p),Ne(m.outShape,g.shape));let y;l!=null&&(y=S(l,"prelu weights","fused depthwiseConv2d"));const x=($,C)=>{I(ra(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[k,R,F,D]=C,M=ki($,F,u),U=N2(R.shape,M,k,t,r,a,o),j=_2(R,M,k.shape,t,r,a,o);if(D!=null){const Y=Ni(g,M);return[U,j,Y]}return[U,j]},w={x:h,filter:d,bias:g,preluActivationWeights:y},v={strides:t,pad:r,dataFormat:s,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:c};return i==null?er((C,k,R)=>{let F=O.runKernel(ea,w,v);return R([k,C,F]),f&&(F=z(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:x}})(h,d):er((C,k,R,F)=>{let D=O.runKernel(ea,w,v);return F([k,C,D,R]),f&&(D=z(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:x}})(h,d,g)}const R2=E({fusedDepthwiseConv2d_:E2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A2({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:i=.2}){if(Ri(O.state.gradientDepth,a)===!1){let M=Ge(n,e,t,r);return s!=null&&(M=Pe(M,s)),Ei(M,a,o,i)}let u=S(n,"a","fused matMul"),l=S(e,"b","fused matMul");[u,l]=dt(u,l);const c=t?u.shape[u.rank-2]:u.shape[u.rank-1],p=r?l.shape[l.rank-1]:l.shape[l.rank-2],d=t?u.shape[u.rank-1]:u.shape[u.rank-2],h=r?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),m=l.shape.slice(0,-2),g=V(f),y=V(m);I(c===p,()=>`Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${t} and transposeB=${r} must match.`);const w=Ne(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([d,h]),v=t?z(u,[g,c,d]):z(u,[g,d,c]),$=r?z(l,[y,h,p]):z(l,[y,p,h]);let C;s!=null&&(C=S(s,"bias","fused matMul"),[C]=dt(C,u),Ne(w,C.shape));let k;o!=null&&(k=S(o,"prelu weights","fused matMul"));const R=(M,U)=>{const[j,Y,Q,ae]=U,me=ki(z(M,Q.shape),Q,a);let le,De;if(!t&&!r?(le=Ge(me,Y,!1,!0),De=Ge(j,me,!0,!1)):!t&&r?(le=Ge(me,Y,!1,!1),De=Ge(me,j,!0,!1)):t&&!r?(le=Ge(Y,me,!1,!0),De=Ge(j,me,!1,!1)):(le=Ge(Y,me,!0,!0),De=Ge(me,j,!0,!0)),s!=null){const Xe=Ni(ae,me);return[le,De,Xe]}else return[le,De]},F={a:v,b:$,bias:C,preluActivationWeights:k},D={transposeA:t,transposeB:r,activation:a,leakyreluAlpha:i};return s==null?er((U,j,Y)=>{const Q=O.runKernel(Zs,F,D);return Y([U,j,Q]),{value:z(Q,w),gradFunc:R}})(v,$):er((U,j,Y,Q)=>{const ae=O.runKernel(Zs,F,D);return Q([U,j,ae,Y]),{value:z(ae,w),gradFunc:R}})(v,$,C)}const O2=E({fusedMatMul_:A2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F2=Object.freeze(Object.defineProperty({__proto__:null,conv2d:T2,depthwiseConv2d:R2,matMul:O2},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D2(n){return Ql(n,.54,.46)}const P2=E({hammingWindow_:D2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L2(n){return Ql(n,.5,.5)}const lg=E({hannWindow_:L2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M2(n,e,t,r=!1,s=0){let a=0;const o=[];for(;a+e<=n.size;)o.push(Ie(n,a,e)),a+=t;if(r)for(;a<n.size;){const i=a+e-n.size,u=xt([Ie(n,a,e-i),$i([i],s)]);o.push(u),a+=t}return o.length===0?vn([],[0,e]):z(xt(o),[o.length,e])}const pg=E({frame_:M2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B2(n,e,t,r,s=lg){r==null&&(r=cg(e));const a=pg(n,e,t),o=pe(a,s(e));return Yl(o,r)}const V2=E({stft_:B2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W2(n,e,t,r,s="bilinear",a=0){const o=S(n,"image","cropAndResize"),i=S(e,"boxes","cropAndResize","float32"),u=S(t,"boxInd","cropAndResize","int32"),l=i.shape[0];I(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),I(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`),I(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`),I(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),I(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),I(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const c={image:o,boxes:i,boxInd:u},p={method:s,extrapolationValue:a,cropSize:r};return O.runKernel(Mo,c,p)}const U2=E({cropAndResize_:W2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z2(n){const e=S(n,"image","flipLeftRight","float32");I(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return O.runKernel(Wo,t,{})}const G2=E({flipLeftRight_:z2});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H2(n){const e=S(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];I(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),I(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,t),s[t]=3,Xs(e,s)}const j2=E({grayscaleToRGB_:H2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q2(n,e,t=0,r=.5){const s=S(n,"image","rotateWithOffset","float32");I(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const a={image:s},o={radians:e,fillValue:t,center:r};return O.runKernel(mi,a,o)}const K2=E({rotateWithOffset_:q2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _s(n,e,t,r,s,a){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),a==null&&(a=0);const o=n.shape[0];return t=Math.min(t,o),I(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),I(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),I(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),I(e.rank===1,()=>"scores must be a 1D tensor"),I(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),I(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X2(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const a=S(n,"boxes","nonMaxSuppression","float32"),o=S(e,"scores","nonMaxSuppression","float32"),i=_s(a,o,t,r,s);t=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;const u={maxOutputSize:t,iouThreshold:r,scoreThreshold:s};return O.runKernel(Qo,{boxes:a,scores:o},u)}const Y2=E({nonMaxSuppression_:X2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q2(n,e,t){const r=Z2(n,e,t),s=r<0?-(r+1):r;n.splice(s,0,e)}function Z2(n,e,t){return eT(n,e,t||J2)}function J2(n,e){return n>e?1:n<e?-1:0}function eT(n,e,t){let r=0,s=n.length,a=0,o=!1;for(;r<s;){a=r+(s-r>>>1);const i=t(e,n[a]);i>0?r=a+1:(s=a,o=!i)}return o?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dg(n,e,t,r,s){return Zl(n,e,t,r,s,0)}function hg(n,e,t,r,s,a){return Zl(n,e,t,r,s,0,!1,a,!0)}function fg(n,e,t,r,s,a){return Zl(n,e,t,r,s,a,!0)}function Zl(n,e,t,r,s,a,o=!1,i=!1,u=!1){const l=[];for(let g=0;g<e.length;g++)e[g]>s&&l.push({score:e[g],boxIndex:g,suppressBeginIndex:0});l.sort(cd);const c=a>0?-.5/a:0,p=[],d=[];for(;p.length<t&&l.length>0;){const g=l.pop(),{score:y,boxIndex:x,suppressBeginIndex:w}=g;if(y<s)break;let v=!1;for(let $=p.length-1;$>=w;--$){const C=tT(n,x,p[$]);if(C>=r){v=!0;break}if(g.score=g.score*nT(r,c,C),g.score<=s)break}g.suppressBeginIndex=p.length,v||(g.score===y?(p.push(x),d.push(g.score)):g.score>s&&Q2(l,g,cd))}const h=p.length,f=t-h;i&&f>0&&(p.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:p};return o&&(m.selectedScores=d),u&&(m.validOutputs=h),m}function tT(n,e,t){const r=n.subarray(e*4,e*4+4),s=n.subarray(t*4,t*4+4),a=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),p=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),h=(i-a)*(u-o),f=(p-l)*(d-c);if(h<=0||f<=0)return 0;const m=Math.max(a,l),g=Math.max(o,c),y=Math.min(i,p),x=Math.min(u,d),w=Math.max(y-m,0)*Math.max(x-g,0);return w/(h+f-w)}function nT(n,e,t){const r=Math.exp(e*t*t);return t<=n?r:0}function cd(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rT(a,o,i){return se(this,arguments,function*(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const u=S(n,"boxes","nonMaxSuppressionAsync"),l=S(e,"scores","nonMaxSuppressionAsync"),c=_s(u,l,t,r,s);t=c.maxOutputSize,r=c.iouThreshold,s=c.scoreThreshold;const p=yield Promise.all([u.data(),l.data()]),d=p[0],h=p[1],{selectedIndices:f}=dg(d,h,t,r,s);return u!==n&&u.dispose(),l!==e&&l.dispose(),Mt(f,"int32")})}const sT=rT;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aT(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const o=S(n,"boxes","nonMaxSuppression"),i=S(e,"scores","nonMaxSuppression"),u=_s(o,i,t,r,s,a);t=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;const l={boxes:o,scores:i},c={maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},p=O.runKernel(Jo,l,c);return{selectedIndices:p[0],selectedScores:p[1]}}const oT=E({nonMaxSuppressionWithScore_:aT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iT(o,i,u){return se(this,arguments,function*(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const l=S(n,"boxes","nonMaxSuppressionAsync"),c=S(e,"scores","nonMaxSuppressionAsync"),p=_s(l,c,t,r,s,a);t=p.maxOutputSize,r=p.iouThreshold,s=p.scoreThreshold,a=p.softNmsSigma;const d=yield Promise.all([l.data(),c.data()]),h=d[0],f=d[1],{selectedIndices:m,selectedScores:g}=fg(h,f,t,r,s,a);return l!==n&&l.dispose(),c!==e&&c.dispose(),{selectedIndices:Mt(m,"int32"),selectedScores:Mt(g)}})}const uT=iT;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cT(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const o=S(n,"boxes","nonMaxSuppression"),i=S(e,"scores","nonMaxSuppression"),u=_s(o,i,t,r,s,null),l=u.maxOutputSize,c=u.iouThreshold,p=u.scoreThreshold,d={boxes:o,scores:i},h={maxOutputSize:l,iouThreshold:c,scoreThreshold:p,padToMaxOutputSize:a},f=O.runKernel(Zo,d,h);return{selectedIndices:f[0],validOutputs:f[1]}}const lT=E({nonMaxSuppressionPadded_:cT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pT(o,i,u){return se(this,arguments,function*(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const l=S(n,"boxes","nonMaxSuppressionAsync"),c=S(e,"scores","nonMaxSuppressionAsync"),p=_s(l,c,t,r,s,null),d=p.maxOutputSize,h=p.iouThreshold,f=p.scoreThreshold,[m,g]=yield Promise.all([l.data(),c.data()]),{selectedIndices:y,validOutputs:x}=hg(m,g,d,h,f,a);return l!==n&&l.dispose(),c!==e&&c.dispose(),{selectedIndices:Mt(y,"int32"),validOutputs:Re(x,"int32")}})}const dT=pT;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hT(n,e,t=!1,r=!1){const s=S(n,"images","resizeBilinear");I(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),I(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),I(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,o=!1;s.rank===3&&(o=!0,a=z(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const i={images:a},u={alignCorners:t,halfPixelCenters:r,size:e},l=O.runKernel(ai,i,u);return o?z(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const fT=E({resizeBilinear_:hT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mT(n,e,t=!1,r=!1){const s=S(n,"images","resizeNearestNeighbor");I(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),I(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),I(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),I(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,o=!1;s.rank===3&&(o=!0,a=z(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const i={images:a},u={alignCorners:t,halfPixelCenters:r,size:e},l=O.runKernel(si,i,u);return o?z(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const gT=E({resizeNearestNeighbor_:mT});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yT(n,e="binary",t=!1,r=.5){const s=S(n,"image","threshold"),a=.2989,o=.587,i=.114,u=s.shape[0]*s.shape[1];let l=pe(Mt([r]),255),c,p,d,h;if(I(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),I(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),I(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),I(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[c,p,d]=oa(s,[1,1,1],-1);const g=pe(c,a),y=pe(p,o),x=pe(d,i);h=Pe(Pe(g,y),x)}else h=n;if(e==="otsu"){const g=Am(tt(rg(h),"int32"),Dn([]),256);l=xT(g,u)}const f=t?Gl(h,l):Ci(h,l);return tt(pe(f,255),"int32")}function xT(n,e){let t=Mt([-1]),r=Mt([0]),s=Mt([0]),a,o,i,u,l,c;for(let p=0;p<n.size-1;p++){a=Ie(n,0,p+1),o=Ie(n,p+1),l=Me(Ye(a),e),c=Me(Ye(o),e);const d=Ye(pe(a,aa(0,a.size)));i=Me(d,Ye(a));const h=$i(o.shape,a.size),f=Pe(aa(0,o.size),h),m=pe(o,f);u=Me(Ye(m),Ye(o));const g=ke(i,u),y=ke(i,u),x=pe(l,c);s=pe(pe(x,g),y);const w=Ci(s,r);r=vs(w,s,r),t=vs(w,Mt([p]),t)}return t}const bT=E({threshold_:yT});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wT(n,e,t="nearest",r="constant",s=0,a){const o=S(n,"image","transform","float32"),i=S(e,"transforms","transform","float32");I(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),I(i.rank===2&&(i.shape[0]===o.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),I(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const u={image:o,transforms:i},l={interpolation:t,fillMode:r,fillValue:s,outputShape:a};return O.runKernel(hi,u,l)}const vT=E({transform_:wT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ST(n,e,t){I(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),I(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);const r=S(n,"a","bandPart");I(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[a,o]=r.shape.slice(-2);if(!(e<=a))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${a}).`);if(!(t<=o))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`);e<0&&(e=a),t<0&&(t=o);const i=z(aa(0,a,1,"int32"),[-1,1]),u=aa(0,o,1,"int32"),l=ke(i,u),c=co(Gl(l,Re(+e,"int32")),Um(l,Re(-t,"int32"))),p=fr([a,o],r.dtype);return z(tr(Yr(z(r,[-1,a,o])).map(d=>vs(c,d,p))),s)}const $T=E({bandPart_:ST});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IT(n){let e;if(Array.isArray(n)){e=!1,I(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let a=1;a<n.length;++a)I(n[a].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[a].shape[0]} vs. ${s})`)}else e=!0,n=oa(n,n.shape[0],0).map(s=>ze(s,[0]));I(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],r=n;for(let s=0;s<n.length;++s)t.push(O.tidy(()=>{let a=r[s];if(s>0)for(let o=0;o<s;++o){const i=pe(Ye(pe(t[o],a)),t[o]);a=ke(a,i)}return Me(a,Ti(a,"euclidean"))}));return e?tr(t,0):t}const TT=E({gramSchmidt_:IT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CT(n,e=!1){if(I(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return ld(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((u,l)=>u*l),r=Yr(z(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],a=[];r.forEach(u=>{const[l,c]=ld(u,e);s.push(l),a.push(c)});const o=z(tr(s,0),n.shape),i=z(tr(a,0),n.shape);return[o,i]}}function ld(n,e=!1){return O.tidy(()=>{I(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],r=n.shape[1];let s=Bm(t),a=pr(n);const o=vn([[1]],[1,1]);let i=pr(o);const u=t>=r?r:t;for(let l=0;l<u;++l){const c=a,p=i,d=s;[i,a,s]=O.tidy(()=>{const h=Ie(a,[l,l],[t-l,1]),f=Ti(h),m=Ie(a,[l,l],[1,1]),g=vs(Ci(m,0),vn([[-1]]),vn([[1]])),y=ke(m,pe(g,f)),x=Me(h,y);x.shape[0]===1?i=pr(o):i=xt([o,Ie(x,[1,0],[x.shape[0]-1,x.shape[1]])],0);const w=Xn(Me(Ge(g,y),f)),v=Ie(a,[l,0],[t-l,r]),$=pe(w,i),C=Ou(i);if(l===0)a=ke(v,Ge($,Ge(C,v)));else{const F=ke(v,Ge($,Ge(C,v)));a=xt([Ie(a,[0,0],[l,r]),F],0)}const k=Ou($),R=Ie(s,[0,l],[t,s.shape[1]-l]);if(l===0)s=ke(R,Ge(Ge(R,i),k));else{const F=ke(R,Ge(Ge(R,i),k));s=xt([Ie(s,[0,0],[t,l]),F],1)}return[i,a,s]}),St([c,p,d])}return!e&&t>r&&(s=Ie(s,[0,0],[t,r]),a=Ie(a,[0,0],[r,r])),[s,a]})}const _T=E({qr_:CT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ut;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Ut||(Ut={}));function kT(n,e,t=Ut.SUM_BY_NONZERO_WEIGHTS){const r=S(n,"losses","computeWeightedLoss");let s=null;e!=null&&(s=S(e,"weights","computeWeightedLoss"));const a=s==null?r:pe(r,s);if(t===Ut.NONE)return a;if(t===Ut.SUM)return Ye(a);if(t===Ut.MEAN){if(s==null)return lo(a);{const o=r.size/s.size,i=Me(Ye(a),Ye(s));return o>1?Me(i,Re(o)):i}}if(t===Ut.SUM_BY_NONZERO_WEIGHTS){if(s==null)return Me(Ye(a),Re(r.size));{const o=pe(s,Dr(r.shape)),i=tt(Ye(Qm(o,Re(0))),"float32");return Me(Ye(a),i)}}throw Error(`Unknown reduction: ${t}`)}const rr=E({computeWeightedLoss_:kT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NT(n,e,t,r=Ut.SUM_BY_NONZERO_WEIGHTS){const s=S(n,"labels","absoluteDifference"),a=S(e,"predictions","absoluteDifference");let o=null;t!=null&&(o=S(t,"weights","absoluteDifference")),Zt(s.shape,a.shape,"Error in absoluteDifference: ");const i=hn(ke(s,a));return rr(i,o,r)}const ET=E({absoluteDifference_:NT});function RT(n,e,t,r,s=Ut.SUM_BY_NONZERO_WEIGHTS){const a=S(n,"labels","cosineDistance"),o=S(e,"predictions","cosineDistance");let i=null;r!=null&&(i=S(r,"weights","cosineDistance")),Zt(a.shape,o.shape,"Error in cosineDistance: ");const u=Re(1),l=ke(u,Ye(pe(a,o),t,!0));return rr(l,i,s)}const AT=E({cosineDistance_:RT});function OT(n,e,t,r=Ut.SUM_BY_NONZERO_WEIGHTS){let s=S(n,"labels","hingeLoss");const a=S(e,"predictions","hingeLoss");let o=null;t!=null&&(o=S(t,"weights","hingeLoss")),Zt(s.shape,a.shape,"Error in hingeLoss: ");const i=Re(1);s=ke(pe(Re(2),s),i);const u=_i(ke(i,pe(s,a)));return rr(u,o,r)}const FT=E({hingeLoss_:OT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DT(n,e,t,r=1,s=Ut.SUM_BY_NONZERO_WEIGHTS){const a=S(n,"labels","huberLoss"),o=S(e,"predictions","huberLoss");let i=null;t!=null&&(i=S(t,"weights","huberLoss")),Zt(a.shape,o.shape,"Error in huberLoss: ");const u=Re(r),l=hn(ke(o,a)),c=jl(l,u),p=ke(l,c),d=Pe(pe(Re(.5),va(c)),pe(u,p));return rr(d,i,s)}const PT=E({huberLoss_:DT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LT(n,e,t,r=1e-7,s=Ut.SUM_BY_NONZERO_WEIGHTS){const a=S(n,"labels","logLoss"),o=S(e,"predictions","logLoss");let i=null;t!=null&&(i=S(t,"weights","logLoss")),Zt(a.shape,o.shape,"Error in logLoss: ");const u=Re(1),l=Re(r),c=Xn(pe(a,sa(Pe(o,l)))),p=pe(ke(u,a),sa(Pe(ke(u,o),l))),d=ke(c,p);return rr(d,i,s)}const MT=E({logLoss_:LT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BT(n,e,t,r=Ut.SUM_BY_NONZERO_WEIGHTS){const s=S(n,"labels","meanSquaredError"),a=S(e,"predictions","meanSquaredError");let o=null;t!=null&&(o=S(t,"weights","meanSquaredError")),Zt(s.shape,a.shape,"Error in meanSquaredError: ");const i=ag(s,a);return rr(i,o,r)}const VT=E({meanSquaredError_:BT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WT(n,e){const t=S(n,"labels","sigmoidCrossEntropyWithLogits"),r=S(e,"logits","sigmoidCrossEntropyWithLogits");Zt(t.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=_i(r),a=pe(r,t),o=Gm(Jn(Xn(hn(r))));return Pe(ke(s,a),o)}function UT(n,e,t,r=0,s=Ut.SUM_BY_NONZERO_WEIGHTS){let a=S(n,"multiClassLabels","sigmoidCrossEntropy");const o=S(e,"logits","sigmoidCrossEntropy");let i=null;if(t!=null&&(i=S(t,"weights","sigmoidCrossEntropy")),Zt(a.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const l=Re(r),c=Re(1),p=Re(.5);a=Pe(pe(a,ke(c,l)),pe(p,l))}const u=WT(a,o);return rr(u,i,s)}const zT=E({sigmoidCrossEntropy_:UT});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GT(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return er((s,a,o)=>{const u=jm(a,[t],!0),l=ke(tt(a,"float32"),u);o([s,l]);const c=Xn(pe(l,s));return{value:Ye(c,[t]),gradFunc:(h,f)=>{const[m,g]=f,y=mt(h.shape,[t]);return[pe(z(h,y),ke(tt(m,"float32"),Jn(g))),pe(z(h,y),ke(Jn(g),tt(m,"float32")))]}}})(n,e)}function HT(n,e,t,r=0,s=Ut.SUM_BY_NONZERO_WEIGHTS){let a=S(n,"onehotLabels","softmaxCrossEntropy");const o=S(e,"logits","softmaxCrossEntropy");let i=null;if(t!=null&&(i=S(t,"weights","softmaxCrossEntropy")),Zt(a.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const l=Re(r),c=Re(1),p=Re(a.shape[1]);a=Pe(pe(a,ke(c,l)),Me(l,p))}const u=GT(a,o);return rr(u,i,s)}const jT=E({softmaxCrossEntropy_:HT});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qT(n,e,t,r){const s=S(n,"indices","sparseFillEmptyRows","int32"),a=S(e,"values","sparseFillEmptyRows"),o=S(t,"denseShape","sparseFillEmptyRows","int32"),i=S(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const u={indices:s,values:a,denseShape:o,defaultValue:i},l=O.runKernel(fl,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}const KT=E({sparseFillEmptyRows_:qT});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XT(n,e,t){const r=S(n,"inputIndices","sparseReshape","int32"),s=S(e,"inputShape","sparseReshape","int32"),a=S(t,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const o={inputIndices:r,inputShape:s,newShape:a},i=O.runKernel(li,o);return{outputIndices:i[0],outputShape:i[1]}}const YT=E({sparseReshape_:XT});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QT(n,e,t){const r=S(n,"data","sparseSegmentMean"),s=S(e,"indices","sparseSegmentMean","int32"),a=S(t,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);const o={data:r,indices:s,segmentIds:a};return O.runKernel(ml,o)}const ZT=E({sparseSegmentMean_:QT});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JT(n,e,t){const r=S(n,"data","sparseSegmentSum"),s=S(e,"indices","sparseSegmentSum","int32"),a=S(t,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);const o={data:r,indices:s,segmentIds:a};return O.runKernel(gl,o)}const eC=E({sparseSegmentSum_:JT});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tC(n,e,t,r,s,a,o,i){const u=S(n,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=S(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:t,nGramWidths:r,leftPad:s,rightPad:a,padWidth:o,preserveShortSequences:i},p={data:u,dataSplits:l},d=O.runKernel(xl,p,c);return{nGrams:d[0],nGramsSplits:d[1]}}const nC=E({stringNGrams_:tC});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rC(n,e,t=!0){const r=S(n,"input","stringSplit","string"),s=S(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:t},o={input:r,delimiter:s},i=O.runKernel(bl,o,a);return{indices:i[0],values:i[1],shape:i[2]}}const sC=E({stringSplit_:rC});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aC(n,e){const t=S(n,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:t};return O.runKernel(wl,s,r)}const oC=E({stringToHashBucketFast_:aC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iC={fft:Xl,ifft:po,rfft:Yl,irfft:sg},uC={hammingWindow:P2,hannWindow:lg,frame:pg,stft:V2},Qn={flipLeftRight:G2,grayscaleToRGB:j2,resizeNearestNeighbor:gT,resizeBilinear:fT,rotateWithOffset:K2,cropAndResize:U2,nonMaxSuppression:Y2,nonMaxSuppressionAsync:sT,nonMaxSuppressionWithScore:oT,nonMaxSuppressionWithScoreAsync:uT,nonMaxSuppressionPadded:lT,nonMaxSuppressionPaddedAsync:dT,threshold:bT,transform:vT},cC={bandPart:$T,gramSchmidt:TT,qr:_T},lC={absoluteDifference:ET,computeWeightedLoss:rr,cosineDistance:AT,hingeLoss:FT,huberLoss:PT,logLoss:MT,meanSquaredError:VT,sigmoidCrossEntropy:zT,softmaxCrossEntropy:jT},pC={sparseFillEmptyRows:KT,sparseReshape:YT,sparseSegmentMean:ZT,sparseSegmentSum:eC},dC={stringNGrams:nC,stringSplit:sC,stringToHashBucketFast:oC};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hC=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:n=>n())();function fC(){return new Promise(n=>hC(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jl(n,e){const t=n[0].length;n.forEach((s,a)=>{I(s.length===t,()=>`Error in concat${t}D: rank of tensors[${a}] must be the same as the rank of the rest (${t})`)}),I(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const r=n[0];n.forEach((s,a)=>{for(let o=0;o<t;o++)I(o===e||s[o]===r[o],()=>`Error in concat${t}D: Shape of tensors[${a}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`)})}function Pn(n,e){const t=n[0].slice();for(let r=1;r<n.length;r++)t[e]+=n[r][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Tn;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(Tn||(Tn={}));function mg(n,e,t){let r=new Array;if(t==null&&e==null)return r;if(e==null)for(;r.length<n+t.length;)r.push(-1);else r=e.slice();if(t==null)return r;if(n+t.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${r.length}`);for(let s=1;s<t.length;++s){const a=t[s],o=r[r.length-t.length+s],i=r[o];if(a>=0)if(i>=0){if(i!==a)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${s+n}] = ${a} but shape[${s+n}] = ${i}`)}else r[o]=a}return r}function gg(n){const e={FIRST_DIM_SIZE:Tn.FIRST_DIM_SIZE,VALUE_ROWIDS:Tn.VALUE_ROWIDS,ROW_LENGTHS:Tn.ROW_LENGTHS,ROW_SPLITS:Tn.ROW_SPLITS,ROW_LIMITS:Tn.ROW_LIMITS,ROW_STARTS:Tn.ROW_STARTS},t=[];for(const r of n)if(r in e)t.push(e[r]);else break;return t}function yg(n){return n.length===0?0:n[0]===Tn.FIRST_DIM_SIZE?n.length-1:n.length}function xg(n,e){if(n==null||e==null)return;const t=n.length,r=e.length;if(t>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(t,r-1);++s){const a=n[s],o=e[s+1];if(a>=0&&o>=0&&a!==1&&a!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${s-n.length}] = ${a} but ragged tensor input.flatValues.shape[${s-n.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ep=30;function Ai(n){return n<=ep?n:mu(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tp(n,e,t){const r=t*(typeof n=="number"?n:n[0]),s=e*(typeof n=="number"?n:n[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sa(n,e,t,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(n[0]/t),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const a=e.length;for(let o=0;o<a;++o)s=s.concat([n[o+1]/e[o],e[o]]);s=s.concat(n.slice(a+1))}return s}function $a(n,e,t=!0){const r=[];if(t){r.push(e);for(let s=e+1;s<n;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],a=[];for(let o=1;o<n;++o)o>=e*2+1||o%2===1?a.push(o):s.push(o);r.push(...s),r.push(0),r.push(...a)}return r}function Ia(n,e,t,r=!0){const s=[];r?s.push(n[0]/t):s.push(n[0]*t);for(let a=1;a<n.length;++a)a<=e.length?r?s.push(e[a-1]*n[a]):s.push(n[a]/e[a-1]):s.push(n[a]);return s}function np(n,e){const t=[0];for(let r=0;r<e;++r)t.push(n[r][0]);return t}function rp(n,e,t){const r=n.slice(0,1);for(let s=0;s<t;++s)r.push(n[s+1]-e[s][0]-e[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bg=1.7580993408473768,wg=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vg=.3275911,Sg=.254829592,$g=-.284496736,Ig=1.421413741,Tg=-1.453152027,Cg=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ju(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let r=0;r<t.length;r+=2)t[r]=n[r/2],t[r+1]=e[r/2];return t}function mC(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)e[r/2]=n[r],t[r/2]=n[r+1];return{real:e,imag:t}}function gC(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function yC(n){const e=Math.floor(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function xC(n,e){const t=n[e*2],r=n[e*2+1];return{real:t,imag:r}}function bC(n,e,t,r){n[r*2]=e,n[r*2+1]=t}function wC(n,e){const t=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const a=(e?2:-2)*Math.PI*(s/n);t[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:t,imag:r}}function vC(n,e,t){const r=(t?2:-2)*Math.PI*(n/e),s=Math.cos(r),a=Math.sin(r);return{real:s,imag:a}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yi="->",SC=/->/g,pd=",",dd="...";function _g(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(SC,"").length)/Yi.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Yi}").`);const[r,s]=n.split(Yi);I(r.indexOf(dd)===-1,()=>`The ellipsis notation ("${dd}") is not supported yet.`);const a=r.split(pd),o=a.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let d=0;d<s.length;++d){const h=s[d];if(!a.some(f=>f.indexOf(h)!==-1))throw new Error(`Output subscripts contain the label ${h} not present in the input subscripts.`);i.indexOf(h)===-1&&i.push(h)}for(let d=0;d<r.length;++d){const h=r[d];i.indexOf(h)===-1&&h!==pd&&i.push(h)}const u=new Array(a.length);for(let d=0;d<o;++d){if(new Set(a[d].split("")).size!==a[d].length)throw new Error(`Found duplicate axes in input component ${a[d]}. Support for duplicate axes in input is not implemented yet.`);u[d]=[];for(let h=0;h<a[d].length;++h)u[d].push(i.indexOf(a[d][h]))}const l=i.length,c=s.length,p=[];for(let d=c;d<l;++d)p.push(d);return{allDims:i,summedDims:p,idDims:u}}function kg(n,e){let t=new Array(n);t.fill(-1);for(let s=0;s<e.length;++s)t[e[s]]=s;const r=[];for(let s=0;s<n;++s)t[s]===-1&&r.push(s);return t=t.filter(s=>s!==-1),{permutationIndices:t,expandDims:r}}function Ng(n,e,t){const r=new Array(n);for(let s=0;s<t.length;++s){const a=t[s].shape;for(let o=0;o<e[s].length;++o)r[e[s][o]]===void 0?r[e[s][o]]=a[o]:I(r[e[s][o]]===a[o],()=>`Expected dimension ${r[e[s][o]]} at axis ${o} of input shaped ${JSON.stringify(a)}, but got dimension ${a[o]}`)}}function Eg(n,e){const t=n,r=[];let s=0;n.length===0&&t.push(-1),s=n.length+1;for(let o=0;o<s;++o)r.push([]);const a=[];for(let o=0;o<t.length;++o){const i=t[o],u=$C(e,i);for(const l of u)a.indexOf(l)===-1&&(r[o].push(l),a.push(l))}return{path:t,steps:r}}function Rg(n){return n.every((e,t)=>e===t)}function $C(n,e){const t=[];for(let r=0;r<n.length;++r)(n[r].length===0||n[r].indexOf(e)!==-1||e===-1)&&t.push(r);return t}function sp(n,e,t=0){let r=[];if(typeof e=="number")I(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(n.shape[t]/e);else{const s=e.reduce((o,i)=>(i===-1&&(o+=1),o),0);I(s<=1,()=>"There should be only one negative value in split array.");const a=e.indexOf(-1);if(a!==-1){const o=e.reduce((i,u)=>u>0?i+u:i);e[a]=n.shape[t]-o}I(n.shape[t]===e.reduce((o,i)=>o+i),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ap(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function op(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function ip(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function up(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function cp(n,e){return`size ${n} must be non-negative, not ${e}`}function lp(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function pp(n,e){const t=V(n),r=V(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${n} outputShape= ${e}`}function dp(n,e){const t=V(n),r=V(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${r}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ia(){return"segment ids must be >= 0"}function hp(){return"segment ids are not increasing"}function fp(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function mp(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ag(n,e){let t=!1,r;for(n<=ep?(r=n,t=!0):r=mu(n,Math.floor(Math.sqrt(n)));!t;)r>e||r===n?t=!0:r=mu(n,r+1);return r}function Og(n,e,t){const r=[],s=n.length;for(let a=0;a<s;a++)a!==e?r.push(n[a]):r.push(t);return r}function gp(n,e,t,r){const s=e.shape.length,a=n.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);if(t<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${t}).`);for(let p=0;p<r;++p)if(n.shape[p]!==e.shape[p])throw new Error(`x.shape[${p}]: ${n.shape[p]} should be equal to indices.shape[${p}]: ${e.shape[p]}.`);const o=n.shape[t],i=[];let u=1,l=1,c=1;for(let p=0;p<r;++p)i.push(n.shape[p]),u*=n.shape[p];for(let p=r;p<t;p++)i.push(n.shape[p]),l*=n.shape[p];for(let p=r;p<s;p++)i.push(e.shape[p]);for(let p=t+1;p<a;p++)i.push(n.shape[p]),c*=n.shape[p];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:o,outputShape:i}}const IC=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:gp,computeOutShape:Og,segOpComputeOptimalWindowSize:Ag},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ua(n){try{return n.map(e=>bs(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function yp(n){return n.map(e=>Mr(e))}const TC=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:Sg,ERF_A2:$g,ERF_A3:Ig,ERF_A4:Tg,ERF_A5:Cg,ERF_P:vg,PARALLELIZE_THRESHOLD:ep,get RowPartitionType(){return Tn},SELU_SCALE:wg,SELU_SCALEALPHA:bg,applyActivation:Ei,assertAndGetBroadcastShape:Ne,assertAxesAreInnerMostDims:gt,assertParamsConsistent:Jl,assignToTypedArray:bC,axesAreInnerMostDims:Ul,calculateShapes:bi,checkEinsumDimSizes:Ng,checkPadOnDimRoundingMode:Sn,combineLocations:Lm,combineRaggedTensorToTensorShapes:mg,complexWithEvenIndex:gC,complexWithOddIndex:yC,computeConv2DInfo:It,computeConv3DInfo:ba,computeDefaultPad:Bl,computeDilation2DInfo:Nm,computeOptimalWindowSize:Ai,computeOutAndReduceShapes:kt,computeOutShape:Pn,computePool2DInfo:nr,computePool3DInfo:xa,convertConv2DDataFormat:wr,decodeEinsumEquation:_g,eitherStridesOrDilationsAreOne:en,expandShapeToKeepDim:mt,exponent:vC,exponents:wC,fromStringArrayToUint8:yp,fromUint8ToStringArray:ua,getAxesPermutation:Ht,getBroadcastDims:io,getComplexWithIndex:xC,getEinsumComputePath:Eg,getEinsumPermutation:kg,getFusedBiasGradient:Ni,getFusedDyActivation:ki,getImageCenter:tp,getInnerMostAxes:Tt,getPermuted:$a,getRaggedRank:yg,getReductionAxes:fm,getReshaped:Sa,getReshapedPermuted:Ia,getRowPartitionTypesHelper:gg,getSliceBeginCoords:np,getSliceSize:rp,getSparseFillEmptyRowsIndicesDenseShapeMismatch:ap,getSparseFillEmptyRowsNegativeIndexErrorMessage:op,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:ip,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:lp,getSparseReshapeInputOutputMismatchErrorMessage:dp,getSparseReshapeInputOutputMultipleErrorMessage:pp,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:up,getSparseReshapeNegativeOutputDimErrorMessage:cp,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:mp,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:ia,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:hp,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:fp,getUndoAxesPermutation:wa,isIdentityPermutation:Rg,log:t0,mergeRealAndImagArrays:ju,prepareAndValidate:Dl,prepareSplitSize:sp,segment_util:IC,shouldFuse:Ri,slice_util:V1,splitRealAndImagArrays:mC,tupleValuesAreOne:ra,upcastType:Bn,validateDefaultValueShape:xg,validateInput:ym,validateUpdateShape:gm,warn:Cn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Er={},Ua={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function CC(n,e){Er[n]=e}function _n(n,e){if(!(n in Er)||e!=null){const r=kC(n,e);if(r!==null)Er[n]=r;else return console.log("Could not get context for WebGL version",n),null}const t=Er[n];return t==null||t.isContextLost()?(delete Er[n],_n(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Er[n])}function _C(n){if(typeof OffscreenCanvas!="undefined"&&n===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function kC(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e==null?_C(n):e;return t.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Er[n]},!1),L().getBool("SOFTWARE_WEBGL_ENABLED")&&(Ua.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Ua)||t.getContext("experimental-webgl",Ua):t.getContext("webgl2",Ua)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ca;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(ca||(ca={}));var cn;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(cn||(cn={}));var $t;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})($t||($t={}));function Ta(n,e){return[e,n]}function NC(n,e){return n*e}function za(n){const e=V(n),t=Math.ceil(e/4);return fu(t)}function ks(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function EC(n,e){const[t,r]=ks(n,e);return t*r*4}function xp(n,e){const t=n;let r,s,a,o,i,u,l,c,p,d;return L().getNumber("WEBGL_VERSION")===2?(r=t.R32F,s=t.R16F,a=t.RGBA16F,o=t.RGBA32F,i=t.RED,l=4,c=1,p=t.HALF_FLOAT,d=t.FLOAT,u=t.RGBA8):(r=n.RGBA,s=n.RGBA,a=n.RGBA,o=t.RGBA,i=n.RGBA,l=4,c=4,p=e!=null?e.HALF_FLOAT_OES:null,d=n.FLOAT,u=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:p,textureTypeFloat:d}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oe(n,e){const t=e();return L().getBool("DEBUG")&&RC(n),t}function RC(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+DC(n,e))}const AC=596e-10,OC=65504;function FC(n){return!!(L().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||AC<Math.abs(n)&&Math.abs(n)<OC)}function DC(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Ga(n,e){return sr(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function PC(n,e){const t=sr(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(oe(n,()=>n.shaderSource(t,e)),oe(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function LC(n,e){const t=sr(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(oe(n,()=>n.shaderSource(t,e)),oe(n,()=>n.compileShader(t)),L().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw Fg(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const MC=/ERROR: [0-9]+:([0-9]+):/g;function Fg(n,e){const t=MC.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const r=+t[1],s=n.split(`
`),a=s.length.toString().length+2,o=s.map((p,d)=>ls((d+1).toString(),a)+p);let i=0;for(let p=0;p<o.length;p++)i=Math.max(o[p].length,i);const u=o.slice(0,r-1),l=o.slice(r-1,r),c=o.slice(r);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${ls(l[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function BC(n){return sr(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function VC(n,e){if(oe(n,()=>n.linkProgram(e)),!L().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Qi(n,e){if(oe(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function WC(n,e){const t=sr(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return oe(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),oe(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function UC(n,e){const t=sr(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return oe(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),oe(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function zC(n){return sr(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function GC(n,e){const t=L().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const r=`[${n}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(n>t||e>t){const r=`[${n}x${e}]`,s=`[${t}x${t}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function HC(n){return sr(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function hd(n,e,t,r,s,a,o){const i=n.getAttribLocation(e,t);return i===-1?!1:(oe(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),oe(n,()=>n.vertexAttribPointer(i,s,n.FLOAT,!1,a,o)),oe(n,()=>n.enableVertexAttribArray(i)),!0)}function jC(n,e,t){QC(n,t),oe(n,()=>n.activeTexture(n.TEXTURE0+t)),oe(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function qC(n,e,t){return sr(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function KC(n,e,t){return n.getUniformLocation(e,t)}function XC(n,e,t,r){oe(n,()=>jC(n,e,r)),oe(n,()=>n.uniform1i(t,r))}function Zi(n,e,t){oe(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),oe(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function fd(n,e){oe(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),oe(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Ha(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+YC(n,e))}function YC(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function sr(n,e,t){const r=oe(n,()=>e());if(r==null)throw new Error(t);return r}function QC(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+n.TEXTURE0;if(r<n.TEXTURE0||r>t){const s=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${s}.`)}}function Ss(n,e=2){return V(n.slice(0,n.length-e))}function $s(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Ji(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[Ss(n),...$s(n)]),e}function ZC(n,e=!1){let t=L().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=L().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&L().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=t/2),e&&(t=t*2,r=r*2,n=n.map((i,u)=>u>=n.length-2?vc(n[u]):n[u]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=yr(n).newShape);let s=V(n),a=null;n.length<=1&&s<=t?a=[1,s]:n.length===2&&n[0]<=t&&n[1]<=t?a=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?a=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?a=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?a=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(a=[n[0],n[1]*n[2]*n[3]]);const o=a!=null&&Math.max(...a)>r&&Math.min(...a)<=(e?2:1)&&Math.min(...a)>0;if(a==null||o)if(e){const i=Ss(n);let u=2,l=2;n.length&&([u,l]=$s(n)),s=i*(u/2)*(l/2),a=fu(s).map(c=>c*2)}else a=fu(s);return a}function ja(n){return n%2===0}function ho(n,e){if(n=n.slice(-2),e=e.slice(-2),pt(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n.slice(-1)[0],r=e.slice(-1)[0];if(t===r||ja(t)&&ja(r)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&ja(n[0])&&ja(e[0])}let eu,tu;function JC(n){if(eu==null){const e=_n(n);eu=e.getParameter(e.MAX_TEXTURE_SIZE)}return eu}function e_(n){if(tu==null){const e=_n(n);tu=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,tu)}function t_(n){if(n===0)return 0;let e;const t=_n(n);return bn(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:bn(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function bn(n,e){return n.getExtension(e)!=null}function md(n){try{if(_n(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function n_(n){if(n===0)return!1;const e=_n(n);if(n===1){if(!bn(e,"OES_texture_float"))return!1}else if(!bn(e,"EXT_color_buffer_float"))return!1;return qu(e)}function r_(n){if(n===0)return!1;const e=_n(n);if(n===1){if(!bn(e,"OES_texture_float")||!bn(e,"WEBGL_color_buffer_float"))return!1}else{if(bn(e,"EXT_color_buffer_float"))return qu(e);const r="EXT_color_buffer_half_float";if(bn(e,r)){const s=e.getExtension(r);return s_(e,s)}return!1}return qu(e)}function qu(n){const e=xp(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);const r=1,s=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,r,s,0,e.textureFormatFloat,e.textureTypeFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(a),o}function s_(n,e){const t=xp(n,e),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r);const s=1,a=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,s,a,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(o),i}function a_(n){return n!==2?!1:_n(n).fenceSync!=null}function Ca(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&I(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ce=L();ce.registerFlag("HAS_WEBGL",()=>ce.getNumber("WEBGL_VERSION")>0);ce.registerFlag("WEBGL_VERSION",()=>md(2)?2:md(1)?1:0);ce.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ce.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ce.get("WEBGL_VERSION")===2);ce.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ce.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ce.registerFlag("WEBGL_PACK",()=>ce.getBool("HAS_WEBGL"));ce.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_CLIP",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_PACK_REDUCE",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_LAZILY_UNPACK",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_CONV_IM2COL",()=>ce.getBool("WEBGL_PACK"));ce.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>JC(ce.getNumber("WEBGL_VERSION")));ce.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>e_(ce.getNumber("WEBGL_VERSION")));ce.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=ce.getNumber("WEBGL_VERSION");return n===0?0:t_(n)});ce.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ce.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Hf());ce.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>n_(ce.getNumber("WEBGL_VERSION")));ce.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ce.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ce.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ce.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>r_(ce.getNumber("WEBGL_VERSION")));ce.registerFlag("WEBGL_FENCE_API_ENABLED",()=>a_(ce.getNumber("WEBGL_VERSION")));ce.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ce.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ce.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});ce.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Hf()?1:-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});ce.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);ce.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);ce.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);ce.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);ce.registerFlag("WEBGL_EXP_CONV",()=>!1);ce.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>ce.getBool("IS_TEST"));ce.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);ce.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);ce.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vt(){let n,e,t,r,s,a,o,i,u,l;return L().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",r="in",s="texture",a="outputColor",o="out vec4 outputColor;",i=L().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",r="varying",s="texture2D",a="gl_FragColor",o="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:r,texture2D:s,output:a,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:u,defineRound:l}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qr(n,e,t="index"){const r=Ve(e);return r.map((s,a)=>{const o=`int ${n[a]} = ${t} / ${s}`,i=a===r.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * ${s}`:`index -= ${n[a]} * ${s}`;return`${o}; ${i};`}).join("")}function Oi(n,e,t="index"){const r=Ve(e);return r.map((s,a)=>{const o=`int ${n[a]} = ${t} / outShapeStrides[${a}]`,i=a===r.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * outShapeStrides[${a}]`:`index -= ${n[a]} * outShapeStrides[${a}]`;return`${o}; ${i};`}).join("")}function o_(n,e){const t=n.length,r=n.map(a=>`${e}[${a}]`),s=new Array(t-1);s[t-2]=r[t-1];for(let a=t-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}function i_(n,e,t="index"){const r=n.map((a,o)=>o),s=o_(r,e);return s.map((a,o)=>{const i=`int ${n[o]} = ${t} / ${s[o]}`,u=o===s.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${s[o]}`:`index -= ${n[o]} * ${s[o]}`;return`${i}; ${u};`}).join("")}function bp(n){const e=Ve(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function wp(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const Dg=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:Pg}=TC;function u_(n,e,t){const r=[];if(n.forEach(h=>{const f=V(h.shapeInfo.logicalShape);if(h.shapeInfo.isUniform?r.push(`uniform float ${h.name}${f>1?`[${f}]`:""};`):(r.push(`uniform sampler2D ${h.name};`),r.push(`uniform int offset${h.name};`)),t.enableShapeUniforms){const{uniformShape:m}=vp(t.packedInputs,h.shapeInfo.logicalShape,h.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${h.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${h.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${h.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${h.name}Shape;`);break}r.push(`uniform ivec2 ${h.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(h=>{r.push(`uniform ${h.type} ${h.name}${h.arrayIndex?`[${h.arrayIndex}]`:""};`)});const s=r.join(`
`),a=n.map(h=>c_(h,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,i=Vt(),u=d_(i);let l,c,p=m_(i);return e.isPacked?(l=l_(e.logicalShape,o,t.enableShapeUniforms),c=f_(i)):(l=p_(e.logicalShape,o,t.enableShapeUniforms),c=h_(i)),t.packedInputs&&(p+=b_),[p,u,c,s,l,a,t.userCode].join(`
`)}function Ns(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return R_(n,e);case 1:return O_(n,e);case 2:return D_(n,e);case 3:return L_(n,e);case 4:return B_(n,e);case 5:return V_(n);case 6:return W_(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function Lg(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return E_(n);case 1:return A_(n,e);case 2:return F_(n,e);case 3:return P_(n,e);default:return M_(n,e)}}function c_(n,e,t=!1,r){let s="";t?s+=Lg(n,r):s+=Ns(n,r);const a=n.shapeInfo.logicalShape,o=e.logicalShape;return a.length<=o.length&&(t?s+=U_(n,e):s+=z_(n,e)),s}function l_(n,e,t){switch(n.length){case 0:return Mg();case 1:return w_(n,e,t);case 2:return k_(n,e,t);case 3:return S_(n,e,t);default:return I_(n,e,t)}}function p_(n,e,t){switch(n.length){case 0:return Mg();case 1:return v_(n,e,t);case 2:return N_(n,e,t);case 3:return $_(n,e,t);case 4:return T_(n,e,t);case 5:return C_(n,e);case 6:return __(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function d_(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function h_(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function f_(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function m_(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${g_}
    ${y_}
    ${x_}
  `}const g_=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,y_=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,x_=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,b_=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function Mg(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function w_(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function v_(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function S_(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(n[2]/2),a=s*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function $_(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Oi(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const r=Qr(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function I_(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(n[n.length-1]/2),a=s*Math.ceil(n[n.length-2]/2);let o=a,i="",u="b, r, c";for(let l=2;l<n.length-1;l++)o*=n[n.length-l-1],i=`
      int b${l} = index / ${o};
      index -= b${l} * ${o};
    `+i,u=`b${l}, `+u;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${i}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${n.length}(${u});
    }
  `}function T_(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Oi(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const r=Qr(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function C_(n,e){const t=Qr(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function __(n,e){const t=Qr(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function k_(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(pt(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function N_(n,e,t){return pt(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Zr(n){return`offset${n}`}function E_(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),r=Vt();return`
    vec4 ${t}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function R_(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;const[s,a]=n.shapeInfo.texShape;if(s===1&&a===1)return`
      float ${r}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=Zr(t);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[i,u]=n.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${i}, ${u}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function A_(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=n.shapeInfo.texShape,a=Vt();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${a.texture2D}(${t}, uv);
    }
  `}function O_(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Es(n)}
      }
    `;const s=n.shapeInfo.texShape,a=s[0],o=s[1];if(o===1&&a===1)return`
      float ${r}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const i=Zr(t);return o===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${a}.0);
        return sampleTexture(${t}, uv);
      }
    `:a===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${i});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${a}, ${o}, index + ${i});
      return sampleTexture(${t}, uv);
    }
  `}function F_(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n.shapeInfo.texShape,o=a[0],i=a[1],u=Vt();if(a!=null&&pt(t,a))return e?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${u.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${o}.0);

        return ${u.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `;const l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=Math.ceil(t[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `}function D_(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n.shapeInfo.texShape;if(a!=null&&pt(t,a)){if(e)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const d=a[0],h=a[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${h}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:o,keptDims:i}=yr(t),u=o;if(u.length<t.length){const d=Rs(n,u),h=["row","col"];return`
      ${Ns(d,e)}
      float ${s}(int row, int col) {
        return ${s}(${As(h,i)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Es(n)}
      }
    `;const l=a[0],c=a[1],p=Zr(r);return c===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${r}, uv);
    }
  `:l===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${p};
    vec2 uv = uvFromFlat(${l}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`}function P_(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n.shapeInfo.texShape,o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(t[0]===1){const d=t.slice(1),h=[1,2],f=Rs(n,d),m=["b","row","col"];return`
        ${Lg(f,e)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${As(m,h)});
        }
      `}const i=Vt();if(e)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${r}, uv);
    }
  `;const u=o[0],l=o[1],c=Math.ceil(t[2]/2),p=c*Math.ceil(t[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${p}, ${c}, b, row, col);
      return ${i.texture2D}(${r}, uv);
    }
  `}function L_(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=t[1]*t[2],o=t[2],{newShape:i,keptDims:u}=yr(t),l=i;if(l.length<t.length){const m=Rs(n,l),g=["row","col","depth"];return`
        ${Ns(m,e)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${As(g,u)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${o}, 1)));
        ${Es(n)}
      }
    `;const c=n.shapeInfo.texShape,p=c[0],d=c[1],h=n.shapeInfo.flatOffset;if(d===a&&h==null)return e?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${p}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(d===o&&h==null)return e?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `;const f=Zr(r);return e?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${o} + depth + ${f};
        vec2 uv = uvFromFlat(${p}, ${d}, index);
        return sampleTexture(${r}, uv);
      }
  `}function M_(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=Vt();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${t}, uv);
    }
  `;const a=n.shapeInfo.logicalShape,o=a.length,i=n.shapeInfo.texShape,u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],l=u[0],c=u[1],p=Math.ceil(a[o-1]/2);let d=p*Math.ceil(a[o-2]/2),h="int b, int row, int col",f=`b * ${d} + (row / 2) * ${p} + (col / 2)`;for(let m=2;m<o-1;m++)h=`int b${m}, `+h,d*=a[o-m-1],f=`b${m} * ${d} + `+f;return`
    vec4 ${r}(${h}) {
      int index = ${f};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});
      return ${s.texture2D}(${t}, uv);
    }
  `}function B_(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=t[3],o=t[2]*a,i=t[1]*o,{newShape:u,keptDims:l}=yr(t);if(u.length<t.length){const x=Rs(n,u),w=["row","col","depth","depth2"];return`
      ${Ns(x,e)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${As(w,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${o}, ${a}, 1)));
        ${Es(n)}
      }
    `;const c=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,d=p[0],h=p[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(h===i&&c==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(h===a&&c==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;const y=Zr(r);return e?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${o} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${d}, ${h}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function V_(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=e[4],a=e[3]*s,o=e[2]*a,i=e[1]*o,{newShape:u,keptDims:l}=yr(e);if(u.length<e.length){const m=Rs(n,u),g=["row","col","depth","depth2","depth3"];return`
      ${Ns(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${As(g,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${o}, ${a}, ${s})) +
          depth3;
        ${Es(n)}
      }
    `;const c=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,d=p[0],h=p[1];if(h===i&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(h===s&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const f=Zr(t);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${o} + depth * ${a} +
          depth2 * ${s} + depth3 + ${f};
      vec2 uv = uvFromFlat(${d}, ${h}, index);
      return sampleTexture(${t}, uv);
    }
  `}function W_(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:s,keptDims:a}=yr(e);if(s.length<e.length){const g=Rs(n,s),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Ns(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${As(y,a)});
      }
    `}const o=e[5],i=e[4]*o,u=e[3]*i,l=e[2]*u,c=e[1]*l;if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${l}, ${u}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Es(n)}
      }
    `;const p=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],f=d[1];if(f===c&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${i}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${h}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===o&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${h}.0);
        return sampleTexture(${t}, uv);
      }
    `;const m=Zr(t);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${l} + depth * ${u} +
          depth2 * ${i} + depth3 * ${o} + depth4 + ${m};
      vec2 uv = uvFromFlat(${h}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Es(n){const e=n.name,t=V(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function U_(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",a=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,i=Pg(n.shapeInfo.logicalShape,e.logicalShape),u=Ke(o),l=o-a;let c;const p=["x","y","z","w","u","v"];a===0?c="":o<2&&i.length>=1?c="coords = 0;":c=i.map(x=>`coords.${p[x+l]} = 0;`).join(`
`);let d="";o<2&&a>0?d="coords":d=n.shapeInfo.logicalShape.map((x,w)=>`coords.${p[w+l]}`).join(", ");let h="return outputValue;";const m=V(n.shapeInfo.logicalShape)===1,y=V(e.logicalShape)===1;if(a===1&&!m&&!y)h=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!y)o===1?h=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:h=`
        return vec4(outputValue.x);
      `;else if(i.length){const x=a-2,w=a-1;i.indexOf(x)>-1&&i.indexOf(w)>-1?h="return vec4(outputValue.x);":i.indexOf(x)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(w)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${u} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${d});
      ${h}
    }
  `}function z_(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",a=e.texShape,o=n.shapeInfo.texShape,i=n.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!n.shapeInfo.isUniform&&i===u&&n.shapeInfo.flatOffset==null&&pt(o,a))return`
      float ${s}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const l=Ke(u),c=Pg(n.shapeInfo.logicalShape,e.logicalShape),p=u-i;let d;const h=["x","y","z","w","u","v"];i===0?d="":u<2&&c.length>=1?d="coords = 0;":d=c.map(m=>`coords.${h[m+p]} = 0;`).join(`
`);let f="";return u<2&&i>0?f="coords":f=n.shapeInfo.logicalShape.map((m,g)=>`coords.${h[g+p]}`).join(", "),`
    float ${s}() {
      ${l} coords = getOutputCoords();
      ${d}
      return get${r}(${f});
    }
  `}function Ke(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function vp(n,e,t){const{newShape:r,keptDims:s}=yr(e),a=e.length,o=n&&a===3&&e[0]===1,i=o?e.slice(1):r,u=!n&&a>1&&!pt(e,t)&&r.length<a||o;return{useSqueezeShape:u,uniformShape:u?i:e,keptDims:s}}function Rs(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function As(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G_(n,e,t,r){const s=t.map((c,p)=>{const d={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(d.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[p],shapeInfo:d}}),a=s.map(c=>c.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},i=u_(s,o,e),u=LC(n.gl,i),l=n.createProgram(u);return L().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:u,source:i,webGLProgram:l,inShapeInfos:a,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:e,fragmentShader:u,source:i,webGLProgram:l,inShapeInfos:a,outShapeInfo:o},Bg(n,e,l))}function Bg(n,e,t){const r={},s={},a={},o=[];let i,u,l,c=null,p=null;p=n.getUniformLocation(t,"NAN",!1),L().getNumber("WEBGL_VERSION")===1&&(c=n.getUniformLocation(t,"INFINITY",!1));const d=!1;for(let h=0;h<e.variableNames.length;h++){const f=e.variableNames[h];r[f]=n.getUniformLocation(t,f,d),r[`offset${f}`]=n.getUniformLocation(t,`offset${f}`,d),e.enableShapeUniforms&&(s[`${f}Shape`]=n.getUniformLocation(t,`${f}Shape`,d),a[`${f}TexShape`]=n.getUniformLocation(t,`${f}TexShape`,d))}return e.enableShapeUniforms&&(i=n.getUniformLocation(t,"outShape",d),l=n.getUniformLocation(t,"outShapeStrides",d),u=n.getUniformLocation(t,"outTexShape",d)),e.customUniforms&&e.customUniforms.forEach((h,f)=>{o[f]=n.getUniformLocation(t,h.name,d)}),{uniformLocations:r,customUniformLocations:o,infLoc:c,nanLoc:p,inShapesLocations:s,inTexShapesLocations:a,outShapeLocation:i,outShapeStridesLocation:l,outTexShapeLocation:u}}function gd(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,r)=>{const s=t.logicalShape,a=e[r],o=a.shape;if(!pt(s,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${o} must match`);if(t.isUniform&&a.isUniform)return;const i=t.texShape,u=a.isUniform?null:a.texData.texShape;if(!pt(i,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${u} must match`)})}function H_(n,e,t,r,s){e.program.enableShapeUniforms||(gd(e.inShapeInfos,t),gd([e.outShapeInfo],[r]));const a=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(a.texture,o[0],o[1]):n.setOutputMatrixTexture(a.texture,o[0],o[1]),n.setProgram(e.webGLProgram),L().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN),t.forEach((u,l)=>{const c=e.program.variableNames[l],p=e.uniformLocations[c],d=e.uniformLocations[`offset${c}`],h=e.inShapesLocations[`${c}Shape`],f=e.inTexShapesLocations[`${c}TexShape`];if(h){const{uniformShape:m}=vp(e.program.packedInputs,u.shape,u.texData.texShape);switch(m.length){case 1:n.gl.uniform1iv(h,new Int32Array(m));break;case 2:n.gl.uniform2iv(h,new Int32Array(m));break;case 3:n.gl.uniform3iv(h,new Int32Array(m));break;case 4:n.gl.uniform4iv(h,new Int32Array(m));break}}if(f&&n.gl.uniform2i(f,u.texData.texShape[0],u.texData.texShape[1]),p!=null){if(u.isUniform){if(V(u.shape)<2)n.gl.uniform1f(p,u.uniformValues[0]);else{let m=u.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),n.gl.uniform1fv(p,m)}return}u.texData.slice!=null&&d!=null&&n.gl.uniform1i(d,u.texData.slice.flatOffset),n.setInputMatrixTexture(u.texData.texture.texture,p,l)}});const i=e.outShapeLocation;if(i)switch(r.shape.length){case 1:n.gl.uniform1iv(i,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(i,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(i,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(i,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const u=Ve(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break}}e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&s&&e.program.customUniforms.forEach((u,l)=>{const c=e.customUniformLocations[l],p=s[l];if(u.type==="float")n.gl.uniform1fv(c,p);else if(u.type==="vec2")n.gl.uniform2fv(c,p);else if(u.type==="vec3")n.gl.uniform3fv(c,p);else if(u.type==="vec4")n.gl.uniform4fv(c,p);else if(u.type==="int")n.gl.uniform1iv(c,p);else if(u.type==="ivec2")n.gl.uniform2iv(c,p);else if(u.type==="ivec3")n.gl.uniform3iv(c,p);else if(u.type==="ivec4")n.gl.uniform4iv(c,p);else throw Error(`uniform type ${u.type} is not supported yet.`)}),n.executeProgram()}function j_(n,e,t){let r="";e.concat(t).forEach(o=>{const i=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const u=o.texData.texShape,{useSqueezeShape:l,uniformShape:c,keptDims:p}=vp(n.packedInputs,o.shape,u);let d="",h="",f="";if(c.length===1&&n.packedInputs){const $=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];d=`${$[0]>1}_${$[1]>1}`}else if(c.length===2&&!n.packedInputs)h=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!n.packedInputs){const $=Ve(c);f=`${$[0]===u[1]}_${$[$.length-1]===u[1]}`}const m=o.shape.length,g=c.length===2&&pt(o.shape,u),y=V(o.shape)===1,x=io(o.shape,t.shape),w=!n.packedInputs&&m===t.shape.length&&pt(u,t.texData.texShape),v=n.packedInputs||c.length>2?"":`${u[0]>1}_${u[1]>1}`;r+=`${m}_${w}_${l?p:""}_${c.length}_${y}_${x}_${g}_${d}_${h}_${f}_${v}_${i}`}else{const u=o.isUniform?"uniform":o.texData.texShape;r+=`${o.shape}_${u}_${i}`}});const s=n.userCode;let a=n.constructor.name;return a+="_"+r+"_"+s+`${L().getNumber("WEBGL_VERSION")}`,a}function Wt(n){return L().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class q_{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=ca.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Vt();this.outputShape=e,this.enableShapeUniforms=Wt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Oi(["r","c","d"],e):Qr(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K_{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=ca.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Vt();this.outputShape=e,this.enableShapeUniforms=Wt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Oi(["r","c","d"],e):Qr(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X_{constructor(e){this.variableNames=["A"],this.outTexUsage=cn.DOWNLOAD;const t=Vt();this.outputShape=e,this.userCode=`
      ${Dg}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y_{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=cn.DOWNLOAD;const t=Vt();this.outputShape=e,this.userCode=`
      ${Dg}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q_{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Vt();this.outputShape=e,this.enableShapeUniforms=Wt(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?wp():bp(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${r.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${r.output} = vec4(${s}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z_{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Vt();this.outputShape=e,this.enableShapeUniforms=Wt(this.outputShape.length);let s="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const u=o*2+i;s+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?wp():bp(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${a};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J_(n){const e=Vt(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return PC(n,t)}function ek(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return WC(n,e)}function tk(n){const e=new Uint16Array([0,1,2,2,1,3]);return UC(n,e)}function _a(n,e,t,r,s,a){GC(e,t);const o=zC(n),i=n.TEXTURE_2D;return oe(n,()=>n.bindTexture(i,o)),oe(n,()=>n.texParameteri(i,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),oe(n,()=>n.texParameteri(i,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),oe(n,()=>n.texParameteri(i,n.TEXTURE_MIN_FILTER,n.NEAREST)),oe(n,()=>n.texParameteri(i,n.TEXTURE_MAG_FILTER,n.NEAREST)),L().getNumber("WEBGL_VERSION")===1?oe(n,()=>n.texImage2D(i,0,r,e,t,0,s,a,null)):oe(n,()=>n.texStorage2D(i,1,r,e,t)),oe(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[t,e]}}function Vg(n){return n.internalFormatFloat}function nk(n,e,t,r){const[s,a]=Ta(e,t);return _a(n,s,a,Vg(r),r.textureFormatFloat,n.FLOAT)}function Wg(n){return n.internalFormatHalfFloat}function rk(n,e,t,r){const[s,a]=Ta(e,t);return _a(n,s,a,Wg(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function Ug(n){return n.downloadTextureFormat}function sk(n,e,t,r){const[s,a]=Ta(e,t);return _a(n,s,a,Ug(r),n.RGBA,n.UNSIGNED_BYTE)}function zg(n){return n.internalFormatPackedFloat}function ak(n,e,t,r){const[s,a]=ks(e,t);return _a(n,s,a,zg(r),n.RGBA,n.FLOAT)}function Gg(n){return n.internalFormatPackedHalfFloat}function ok(n,e,t,r){const[s,a]=ks(e,t);return _a(n,s,a,Gg(r),n.RGBA,r.textureTypeHalfFloat)}function ik(n,e,t){return oe(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),hd(n,e,"clipSpacePos",t,3,20,0)&&hd(n,e,"uv",t,2,20,12)}function uk(n,e,t,r,s,a){oe(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,i,u;s instanceof Uint8Array?(o=new Uint8Array(t*r*4),i=n.UNSIGNED_BYTE,u=n.RGBA):(o=new Float32Array(t*r*4),i=n.FLOAT,u=a.internalFormatPackedFloat),o.set(s),L().getNumber("WEBGL_VERSION")===2?oe(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,r,n.RGBA,i,o)):oe(n,()=>n.texImage2D(n.TEXTURE_2D,0,u,t,r,0,n.RGBA,i,o)),oe(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function ck(n,e,t){oe(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?L().getNumber("WEBGL_VERSION")===2?oe(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):oe(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):L().getNumber("WEBGL_VERSION")===2?oe(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):oe(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),oe(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function lk(n,e,t,r){const s=n.createBuffer();oe(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));const i=4*4*e*t;return oe(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,i,n.STREAM_READ)),oe(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),oe(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}function pk(n,e,t){const r=n,s=new Float32Array(t);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function dk(n,e,t,r){const[s,a]=Ta(e,t),o=4,i=new Uint8Array(NC(e*t,o));return oe(n,()=>n.readPixels(0,0,s,a,r.downloadTextureFormat,n.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function hk(n,e,t,r,s,a,o,i){const u=n,l=new Float32Array(EC(a,o));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function fk(n,e,t){const r=new Float32Array(e*t*4);return oe(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nu{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=L().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,CC(t,e)):this.gl=_n(t);let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),L().getNumber("WEBGL_VERSION")===1){const a="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=Ga(this.gl,a),bn(this.gl,o))this.textureHalfFloatExtension=Ga(this.gl,o);else if(L().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),bn(this.gl,s))this.colorBufferHalfFloatExtension=Ga(this.gl,s);else if(L().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",bn(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(bn(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=ek(this.gl),this.indexBuffer=tk(this.gl),this.framebuffer=HC(this.gl),this.textureConfig=xp(this.gl,this.textureHalfFloatExtension)}get debug(){return L().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;oe(e,()=>e.finish()),oe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),oe(e,()=>e.deleteFramebuffer(this.framebuffer)),oe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),oe(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),oe(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),nk(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),rk(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),sk(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),ck(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,r,s){this.throwIfDisposed(),uk(this.gl,e,t,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),ok(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),ak(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(fd(this.gl,this.framebuffer),this.outputTexture=null),oe(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r){return this.downloadMatrixDriver(e,()=>dk(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,r,s,a,o){return hk(this.gl,e,t,r,s,a,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return pk(this.gl,e,t)}createBufferFromTexture(e,t,r){this.bindTextureToFrameBuffer(e);const s=lk(this.gl,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,r;if(L().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,a=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const o=s.clientWaitSync(a,0,0);return o===s.ALREADY_SIGNALED||o===s.CONDITION_SATISFIED},t=a}else L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(e,t,r){return this.downloadMatrixDriver(e,()=>fk(this.gl,t,r))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=J_(t));const r=BC(t);return oe(t,()=>t.attachShader(r,this.vertexShader)),oe(t,()=>t.attachShader(r,e)),VC(t,r),this.debug&&Qi(t,r),this.vertexAttrsAreBound||(this.setProgram(r),this.vertexAttrsAreBound=ik(t,this.program,this.vertexBuffer)),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&oe(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Qi(this.gl,this.program),oe(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,r=!0){return this.throwIfDisposed(),r?qC(this.gl,e,t):KC(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),oe(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),XC(this.gl,e,t,r)}setOutputMatrixTexture(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)}setOutputPackedMatrixTexture(e,t,r){this.throwIfDisposed();const[s,a]=ks(t,r);this.setOutputMatrixTextureDriver(e,s,a)}setOutputMatrixWriteRegion(e,t,r,s){this.setOutputMatrixWriteRegionDriver(r,e,s,t)}setOutputPackedMatrixWriteRegion(e,t,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Qi(this.gl,this.program),Ha(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),oe(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),oe(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Ga(this.gl,L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),a=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,a),a}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,r=this.getQueryTimerExtensionWebGL2();t.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(e){return se(this,null,function*(){return yield zp(()=>this.disposed||this.isQueryAvailable(e,L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})}getQueryTime(e,t){if(t===0)return null;if(t===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),a=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=mk(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:r}=this.itemsToPoll[t];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in L().platform&&(r=L().platform.setTimeoutCustom.bind(L().platform)),zp(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Zi(this.gl,e,this.framebuffer),this.debug&&Ha(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Zi(this.gl,this.outputTexture,this.framebuffer),this.debug&&Ha(this.gl)):fd(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,t,r){this.throwIfDisposed();const s=this.gl;Zi(s,e,this.framebuffer),this.debug&&Ha(s),this.outputTexture=e,oe(s,()=>s.viewport(0,0,t,r)),oe(s,()=>s.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(e,t,r,s){this.throwIfDisposed(),oe(this.gl,()=>this.gl.scissor(e,t,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function mk(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gk(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ln(n){return(e,t,r,s,a)=>{const o=Ne(e,t),i=o.length,u=Ve(o),l=V(o),c=Zn(a,l),p=e.length,d=t.length,h=Ve(e),f=Ve(t),m=io(e,o),g=io(t,o);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=n(r[y%r.length],s[y%s.length]);else for(let y=0;y<c.length;++y){const x=Sc(y,i,u),w=x.slice(-p);m.forEach(k=>w[k]=0);const v=yu(w,p,h),$=x.slice(-d);g.forEach(k=>$[k]=0);const C=yu($,d,f);c[y]=n(r[v],s[C])}return[c,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yk(n,e,t,r){if(r==="int32"){const s=Int32Array.from(n);return[e,"int32",s]}if(r==="bool"){const s=yi([0],t),[a,o]=ln((i,u)=>i!==u?1:0)(e,[],n,s,"bool");return[o,"bool",a]}throw new Error(`Error in Cast: failed to cast ${t} to ${r}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xk=ln((n,e)=>n+e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bk(n,e,t,r,s){const a=V(r),o=dr(s,t);for(let i=0;i<n.length;i++){const u=n[i];if(u<0)throw new Error("Input x must be non-negative!");u>=s||(a>0?o[u]+=e[i]:o[u]+=1)}return o}function wk(n,e,t,r=!1){const s=n.shape[0],a=n.shape[1],o=it([s,t],e.dtype);for(let i=0;i<s;i++)for(let u=0;u<a;u++){const l=n.get(i,u);if(l<0)throw new Error("Input x must be non-negative!");l>=t||(r?o.set(1,i,l):e.size>0?o.set(o.get(i,l)+e.get(i,u),i,l):o.set(o.get(i,l)+1,i,l))}return o}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vr(n){return(e,t,r)=>{const s=Zn(t,e.length);for(let a=0;a<e.length;++a)s[a]=n(e[a],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vk=vr(n=>Math.ceil(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hg(n,e,t,r){const s=zt(t,V(e));if(r&&t!=="string"){let a=0;n.forEach(o=>{const i=V(o.shape);s.set(o.vals,a),a+=i})}else{let a=0;n.forEach(o=>{const i=t==="string"?ua(o.vals):o.vals;let u=0;for(let l=0;l<o.shape[0];++l){const c=l*e[1]+a;for(let p=0;p<o.shape[1];++p)s[c+p]=i[u++]}a+=o.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sk=ln((n,e)=>n===e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $k=vr(n=>Math.exp(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ik=vr(n=>Math.expm1(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tk=vr(n=>Math.floor(n));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ck(n,e,t,r,s,a,o,i,u){const l=it([r,a],t);for(let c=0;c<r;c++){const p=[];let d=0;for(let h=0;h<s;h++){const f=n[c*s+h];d+=f*o[h],p.push(f)}if(d<0||d>=u/a)throw new Error(`Invalid indices: ${p} does not index into ${i}`);for(let h=0;h<a;h++)l.values[c*a+h]=e.get(...e.indexToLoc(d*a+h))}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _k(n,e,t){const r=it(t,n.dtype);for(let s=0;s<r.size;++s){const o=r.indexToLoc(s).slice(),i=o[0],u=o[2],l=e.locToIndex([i,u]);o[2]=e.values[l];const c=n.locToIndex(o);0<=c&&c<n.values.length&&(r.values[s]=n.values[c])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kk=ln((n,e)=>n>e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nk=ln((n,e)=>n>=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ek=ln((n,e)=>n<e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rk=ln((n,e)=>n<=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ak(n,e,t){const r=(e-n)/(t-1),s=dr(t,"float32");s[0]=n;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ok=vr(n=>Math.log(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fk(n,e,t,r){const s=Zn(r,V(t));for(let a=0;a<s.length;++a){const o=a*e;let i=n[o];for(let u=0;u<e;++u){const l=n[o+u];(Number.isNaN(l)||l>i)&&(i=l)}s[a]=i}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dk=ln((n,e)=>Math.max(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pk=ln((n,e)=>Math.min(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jg=ln((n,e)=>n*e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lk(n,e,t){const r=Cs(-1,t);return jg([],e,r,n,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mk=ln((n,e)=>n!==e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bk(n,e,t,r,s){const a=e.length,o=V(e),i=Ve(e),u=Ve(s),l=Zn(t,V(s));for(let c=0;c<o;++c){const p=Sc(c,a,i),d=new Array(p.length);for(let f=0;f<d.length;f++)d[f]=p[r[f]];const h=yu(d,a,u);l[h]=n[c]}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vk(n,e,t,r){const[s,a]=kt(n,r),o=Bn(e,"int32"),i=dr(V(s),o),u=V(a);for(let l=0;l<i.length;++l){const c=l*u;let p=1;for(let d=0;d<u;++d)p*=t[c+d];i[l]=p}return{outVals:i,outShape:s,outDtype:o}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wk(n,e,t){n.forEach((r,s)=>{if(r<0||r>=t){const a=Sc(s,e.length,Ve(e)).join(",");throw new Error(`indices[${a}] = ${r} is not in [0, ${t})`)}})}function Uk(n,e){for(let t=0;t<n.length;++t){const r=n[t],s=t===n.length-1?e:n[t+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let a=1;a<r.length;++a)if(r[a-1]>r[a])throw new Error("Ragged splits must be sorted in ascending order")}}function zk(n,e,t,r){const s=[];let a=0;const o=e.length-1+t.length,i=new Array(o).fill(null).map(()=>[0]);Uk(t,r);let u=1;for(let l=0;l<e.length-1;++l){u*=e[l];const c=e[l+1];for(let p=1;p<u+1;++p)i[l].push(p*c)}for(let l=0;l<n.length;++l){let c=n[l],p=n[l]+1;for(let d=0;d<t.length;++d){const h=t[d],f=d+e.length-1;if(f>=0){const m=i[f],g=m[m.length-1]-h[c];for(let y=c;y<p;++y)i[f].push(h[y+1]+g)}c=h[c],p=h[p]}p!==c&&(s.push([c,p]),a+=p-c)}return{outSplits:i,valueSlices:s,numValues:a}}function Gk(n){const e=[];for(let t=0;t<n.length;++t){const r=n[t].length,s=zt("int32",r);e.push(s),n[t].forEach((a,o)=>s[o]=a)}return e}function yd(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let r=e;r<n.length;r++)t[e-1]*=n[r];return t}function Hk(n,e,t,r,s,a){const o=yd(e,2)[1],i=yd(a,2)[1];let u=0;for(const l of t)for(let c=l[0];c<l[1];++c){for(let p=0;p<r;++p)s[u*i+p]=n[c*o+p];++u}}function jk(n,e,t,r,s){const a=e.slice();a[0]=s;const o=zt(t,V(a)),i=n.length,u=i===0?0:i/e[0];return Hk(n,e,r,u,o,a),[o,a]}function qk(n,e,t,r,s,a,o,i){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const u=e[0][0]-1;if(Wk(a,o,u),r.length===0)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:c,valueSlices:p,numValues:d}=zk(a,o,n,l),h=Gk(c),f=jk(t,r,s,p,d);return[h,f[0],f[1]]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var pn=Tn;class fo{constructor(e,t,r,s,a,o,i,u,l,c){this.shape=e,this.shapeShape=t,this.values=r,this.valuesShape=s,this.valuesDType=a,this.defaultValue=o,this.defaultValueShape=i,this.rowPartitionValues=u,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=gg(c),this.raggedRank=yg(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===pn.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===pn.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case pn.VALUE_ROWIDS:return fo.getMaxWidthValueRowID(t);case pn.ROW_SPLITS:return fo.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${pn[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let r=0;for(let s=0;s<t-1;++s){const a=e[s+1]-e[s];a>r&&(r=a)}return r}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let r=0,s=e[0],a=0;for(let o=1;o<t;++o){const i=e[o];i!==s&&(s=i,a=Math.max(o-r,a),r=o)}return Math.max(t-r,a)}tensorShapeFromTensor(e,t,r=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return bd(e,r)}calculateOutputSize(e){const t=this.valuesShape,r=this.defaultValueShape;xg(r,t);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=mg(this.raggedRank,s,t);o[0]<0&&(o[0]=e);for(let i=1;i<=this.raggedRank;++i)o[i]<0&&(o[i]=this.getMaxWidth(i));return o}calculateFirstParentOutputIndex(e,t,r){const s=Math.min(e,r),a=[];let o=0;for(let i=0;i<s;++i,o+=t)a.push(o);for(let i=s;i<e;++i)a.push(-1);return I(a.length===e,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(e,t,r,s){const a=e.length,o=[];for(let i=0;i<a-1;++i){const u=e[i+1]-e[i];let l=Math.min(s,u),c=t[i];c===-1&&(l=0);for(let p=0;p<l;++p)o.push(c),c+=r;for(let p=0;p<u-l;++p)o.push(-1)}if(a>0&&o.length!==e[a-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,r,s){const a=e.length,o=[];if(a===0)return[];let i=0,u=e[0];if(u>=t.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${t.length}`);let l=t[u];o.push(l);for(let c=1;c<a;++c){const p=e[c];if(p===u)l>=0&&(++i,i<s?l+=r:l=-1);else{if(i=0,u=p,p>=t.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${t.length}`);l=t[p]}o.push(l)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,r,s){const a=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case pn.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,r,s);case pn.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,r,s);default:throw new Error(`Unsupported partition type: ${pn[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case pn.FIRST_DIM_SIZE:return e[0];case pn.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case pn.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${pn[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),r=this.calculateOutputSize(t),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let u=s.length-2;u>=0;--u)s[u]=s[u+1]*r[u+1];const a=bd(r,!1),o=zt(this.valuesDType,V(a));if(s[0]*r[0]>0){let u=this.calculateFirstParentOutputIndex(t,s[0],r[0]);for(let l=1;l<=this.raggedRank;++l)u=this.calculateOutputIndex(l-1,u,s[l],r[l]);this.setOutput(this.raggedRank,u,o,a)}return[a,o]}setOutput(e,t,r,s){if(r.length===0)return;const a=this.values,o=r;let i=s.slice();i=i.slice(e+1);const u=V(i),l=t.length;let c=this.defaultValue;if(c.length!==u&&c.length!==1){const f=this.defaultValueShape;Be(()=>{const m=z(c,f);c=Ks(m,i).dataSync()})}let p=0,d=0,h=0;for(let f=0;f<=l;++f){let m=f<l?t[f]:-1;if(m===h){++h;continue}if(d<h){const g=a.subarray(p*u),y=o.subarray(d*u),x=(h-d)*u;xd(y,g,x)}if(f>=l){const g=r.length;m=Math.floor(g/u)}if(m>h)if(this.defaultValue.length===1)o.subarray(h*u,m*u).fill(this.defaultValue[0]),h=m;else for(;m>h;){const g=o.slice(h*u);xd(g,c,u),++h}m<0?(p=f+1,d=h):(p=f,d=h,h=d+1)}}}function xd(n,e,t){for(let r=0;r<t;r++)n[r]=e[r]}function bd(n,e){const t=[];for(let r of n){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}t.push(r)}return t}function Kk(n,e,t,r,s,a,o,i,u,l){return new fo(n,e,t,r,s,a,o,i,u,l).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qg(n,e,t,r){const s=n===e,a=n<e&&t<0,o=e<n&&t>1;if(s||a||o)return dr(0,r);const i=Math.abs(Math.ceil((e-n)/t)),u=dr(i,r);e<n&&t===1&&(t=-1),u[0]=n;for(let l=1;l<u.length;l++)u[l]=u[l-1]+t;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xk=vr(n=>1/Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yk(n,e,t,r,s,a,o,i,u,l){const c=[r/s,s],p=n.values,d=e.values;if(r===0)return it(t,e.dtype);const h=it(c,e.dtype);typeof u=="string"||typeof u=="number"?h.values.fill(u):typeof u=="boolean"&&h.values.fill(+u);for(let f=0;f<a;f++){const m=[];let g=0;for(let y=0;y<o;y++){const x=p[f*o+y];m.push(x),g+=x*i[y]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${t}`);for(let y=0;y<s;y++)l?h.values[g*s+y]+=d[f*s+y]:h.values[g*s+y]=e.rank===0?d[0]:d[f*s+y]}return h}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qk=vr(n=>1/(1+Math.exp(-n)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ku(n,e,t,r,s){const a=wi(r,e,t),o=V(t),i=Ve(r);if(a){const p=vi(e,i);return s==="string"?n.slice(p,p+o):n.subarray(p,p+o)}const u=s==="string"?ua(n):n,l=it(r,s,u),c=it(t,s);for(let p=0;p<c.size;++p){const d=c.indexToLoc(p),h=d.map((f,m)=>f+e[m]);c.set(l.get(...h),...d)}return s==="string"?yp(c.values):c.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zk(n,e,t,r,s,a,o){const i=e[0],u=a[0],l=new Array(u),c=new Array(i),p=e[1];if(u===0){if(i!==0)throw new Error(ap(i));const g=zt(t,0),y=zt(s,0);return[g,[0,p],y,l,c]}let d=!0,h=0;const f=new Array(u).fill(0);for(let g=0;g<i;++g){const y=n[g*p];if(y<0)throw new Error(op(g,y));if(y>=u)throw new Error(ip(g,y,u));++f[y],d=d&&y>=h,h=y}let m=!0;for(let g=0;g<u;++g){const y=f[g]===0;l[g]=y,m=m&&!y,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const g=n,y=r;for(let x=0;x<i;++x)c[x]=x;return[g,[i,p],y,l,c]}else{const g=f[u-1],y=zt(t,g*p),x=zt(s,g),w=new Array(u).fill(0);for(let v=0;v<i;++v){const $=n[v*p],C=w[$],k=($===0?0:f[$-1])+C;w[$]++;for(let R=0;R<p;++R)y[k*p+R]=n[v*p+R];x[k]=r[v],c[v]=k}for(let v=0;v<u;++v)if(w[v]===0){const C=v===0?0:f[v-1];y[C*p+0]=v;for(let k=1;k<p;++k)y[C*p+k]=0;x[C]=o}return[y,[g,p],x,l,c]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jk(n,e,t,r,s){const a=V(r),o=e[0],i=s.length,u=[];let l=1,c=-1;for(let g=0;g<i;++g){const y=s[g];if(y===-1){if(c!==-1)throw new Error(up(c,g));c=g,u.push(1)}else{if(y<0)throw new Error(cp(g,y));l*=y,u.push(y)}}if(c!==-1){if(l<=0)throw new Error(lp());const g=Math.trunc(a/l);if(l*g!==a)throw new Error(pp(r,u));u[c]=g}if(V(u)!==a)throw new Error(dp(r,u));const d=r.length,h=[];if(d>0){h[d-1]=1;for(let g=d-2;g>=0;--g)h[g]=h[g+1]*r[g+1]}const f=[];if(i>0){f[i-1]=1;for(let g=i-2;g>=0;--g)f[g]=f[g+1]*u[g+1]}const m=zt(t,o*i);for(let g=0;g<o;++g){let y=0;for(let x=0;x<d;++x)y+=n[g*d+x]*h[x];for(let x=0;x<i;++x)m[g*i+x]=Math.trunc(y/f[x]),y%=f[x]}return[m,[o,i],u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eN(n,e,t,r,s,a=!1,o=0){const i=r.length,u=[e[0],n.length/e[0]],l=u[1],p=i>0?s[i-1]+1:0;if(p<0)throw new Error(ia());const d=e.slice();d[0]=p;const h=d.reduce((w,v)=>w*v,1),f=zt(t,h);if(i===0)return p>0&&f.fill(o),[f,d];if(p<=0)throw new Error(ia());let m=0,g=1,y=0,x=s[m];for(;;){let w=0;if(g<i){if(w=s[g],x===w){++g;continue}if(x>=w)throw new Error(hp())}if(x<0||x>=p)throw new Error(fp(x,p));x>y&&f.fill(o,y*l,x*l);for(let v=m;v<g;++v){const $=r[v];if($<0||$>=u[0])throw new Error(mp(v,r[v],u[0]));for(let C=0;C<l;C++)f[x*l+C]+=n[$*l+C]}if(a)for(let v=0;v<l;v++)f[x*l+v]/=g-m;if(m=g,++g,y=x+1,x=w,g>i)break}return y<p&&f.fill(o,y*l,p*l),[f,d]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tN=vr(n=>Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nN=ln((n,e)=>{const t=n-e;return t*t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rN(n,e,t,r){const s=it(n,e.dtype);for(let a=0;a<s.size;a++){const o=s.indexToLoc(a),i=new Array(o.length);for(let u=0;u<i.length;u++)i[u]=o[u]*t[u]+r[u];s.set(e.get(...i),...o)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sN{constructor(e,t,r,s,a,o){this.separator=Mr(e),this.nGramWidths=t,this.leftPad=Mr(r),this.rightPad=Mr(s),this.padWidth=a,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const r=this.getPadWidth(t);return Math.max(0,e+2*r-t+1)}createNGrams(e,t,r,s,a,o){for(let i=0;i<a;++i){const u=this.getPadWidth(o),l=Math.max(0,u-i),c=Math.max(0,u-(a-(i+1))),p=o-(l+c),d=t+(l>0?0:i-u);let h=0;h+=l*this.leftPad.length;for(let x=0;x<p;++x)h+=e[d+x].length;h+=c*this.rightPad.length;const f=l+c+p-1;h+=f*this.separator.length,r[s+i]=new Uint8Array(h);const m=r[s+i];let g=0;const y=x=>x.forEach(w=>m[g++]=w);for(let x=0;x<l;++x)y(this.leftPad),y(this.separator);for(let x=0;x<p-1;++x)y(e[d+x]),y(this.separator);if(p>0){y(e[d+p-1]);for(let x=0;x<c;++x)y(this.separator),y(this.rightPad)}else{for(let x=0;x<c-1;++x)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,t){const r=e.length,s=t.length;if(s>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<s;++l){let c=t[l]>=u;if(c=c&&t[l]<=r,!c)throw new Error(`Invalid split value ${t[l]}, must be in [${u}, ${r}]`);u=t[l]}if(u!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${u}`)}const a=s-1,o=zt("int32",s);if(r===0||s===0){const u=new Array(r);for(let l=0;l<=a;++l)o[l]=0;return[u,o]}o[0]=0;for(let u=1;u<=a;++u){const l=t[u]-t[u-1];let c=0;this.nGramWidths.forEach(p=>{c+=this.getNumNGrams(l,p)}),this.preserveShort&&l>0&&c===0&&(c=1),o[u]=o[u-1]+c}const i=new Array(o[a]);for(let u=0;u<a;++u){const l=t[u];let c=o[u];if(this.nGramWidths.forEach(p=>{const d=t[u+1]-t[u],h=this.getNumNGrams(d,p);this.createNGrams(e,l,i,c,h,p),c+=h}),this.preserveShort&&c===o[u]){const p=t[u+1]-t[u];if(p===0)continue;const d=p+2*this.padWidth,h=1;this.createNGrams(e,l,i,c,h,d)}}return[i,o]}}function Kg(n,e,t,r,s,a,o,i){return new sN(t,r,s,a,o,i).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aN(n,e,t,r){if(!n.length)return;if(e.length===0){for(let a=0;a<n.length;++a)r.push(n.subarray(a,a+1));return}if(e.length===1){const a=e[0];let o=n.indexOf(a);for(;o!==-1;){const i=n.subarray(0,o);(!t||i.length!==0)&&r.push(i),n=n.subarray(o+1),o=n.indexOf(a)}(!t||n.length!==0)&&r.push(n);return}let s=0;for(let a=0;a<n.length+1;a++)if(a===n.length||e.indexOf(n[a])!==-1){const o=n.subarray(s,a);(!t||o.length!==0)&&r.push(o),s=a+1}}function Xg(n,e,t){const r=n.length,s=[];let a=0,o=0;const i=new Array(r);for(let d=0;d<r;++d){const h=s.length;aN(n[d],e,t,s);const f=s.length-h;i[d]=f,a+=f,o=Math.max(o,f)}const u=zt("int32",a*2),l=new Array(a),c=[r,o];let p=0;for(let d=0;d<r;++d)for(let h=0;h<i[d];++h)u[p*2]=d,u[p*2+1]=h,l[p]=s[p],++p;return[u,l,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yg(n,e){const t=zt("int32",n.length);for(let r=0;r<n.length;++r)t[r]=c0(n[r]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oN=ln((n,e)=>n-e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iN(n,e){const t=new Array(n.rank);for(let s=0;s<t.length;s++)t[s]=n.shape[s]*e[s];const r=it(t,n.dtype);for(let s=0;s<r.values.length;++s){const a=r.indexToLoc(s),o=new Array(n.rank);for(let u=0;u<o.length;u++)o[u]=a[u]%n.shape[u];const i=n.locToIndex(o);r.values[s]=n.values[i]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hs=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function Qg(n,e,t=0,r=n.length-1){for(;r>t;){if(r-t>600){const i=r-t+1,u=e-t+1,l=Math.log(i),c=.5*Math.exp(2*l/3),p=.5*Math.sqrt(l*c*(i-c)/i)*Math.sign(u-i/2),d=Math.max(t,Math.floor(e-u*c/i+p)),h=Math.min(r,Math.floor(e+(i-u)*c/i+p));Qg(n,e,d,h)}const s=n[e];let a=t,o=r;for(Bs(n,t,e),Hs(n[r],s)>0&&Bs(n,t,r);a<o;){for(Bs(n,a,o),a++,o--;Hs(n[a],s)<0;)a=a+1;for(;Hs(n[o],s)>0;)o=o-1}Hs(n[t],s)===0?Bs(n,t,o):(o=o+1,Bs(n,o,r)),o<=e&&(t=o+1),e<=o&&(r=o-1)}}function uN(n,e,t,r,s){const a=e[e.length-1],[o,i]=[n.length/a,a],u=Zn(t,o*r),l=Zn("int32",o*r);for(let p=0;p<o;p++){const d=p*i,h=n.subarray(d,d+i);let f=new Array(h.length);h.forEach((x,w)=>f[w]={value:x,index:w}),r<f.length&&(Qg(f,r),f=f.slice(0,r)),s&&f.sort(Hs);const m=p*r,g=u.subarray(m,m+r),y=l.subarray(m,m+r);for(let x=0;x<r;x++)g[x]=f[x].value,y[x]=f[x].index}const c=e.slice();return c[c.length-1]=r,[it(c,t,u),it(c,"int32",l)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cN(n,e,t,r){const s=ct(e,t)[0],a=[1,t[0],1];for(let f=0;f<s;f++)a[0]*=t[f];a[1]=t[s];for(let f=s+1;f<t.length;f++)a[2]*=t[f];const o={},i=new Int32Array(t[s]),u=new ta(a,r,n),l=[],c=a[0]===1&&a[2]===1;for(let f=0;f<t[s];f++){let m;if(c)m=n[f].toString();else{const g=[];for(let y=0;y<a[0];y++)for(let x=0;x<a[2];x++)g.push(u.get(y,f,x));m=g.join(",")}if(o[m]!==void 0)i[f]=o[m];else{const g=Object.keys(o).length;o[m]=g,i[f]=g,l.push(f)}}const p=a.slice();p[1]=Object.keys(o).length;const d=new ta(p,r);l.forEach((f,m)=>{for(let g=0;g<a[0];g++)for(let y=0;y<a[2];y++)d.set(u.get(g,f,y),g,m,y)});const h=t.slice();return h[s]=p[1],{outputValues:d.values,outputShape:h,indices:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lN=Object.freeze(Object.defineProperty({__proto__:null,addImpl:xk,bincountImpl:bk,bincountReduceImpl:wk,castImpl:yk,ceilImpl:vk,concatImpl:Hg,equalImpl:Sk,expImpl:$k,expm1Impl:Ik,floorImpl:Tk,gatherNdImpl:Ck,gatherV2Impl:_k,greaterEqualImpl:Nk,greaterImpl:kk,lessEqualImpl:Rk,lessImpl:Ek,linSpaceImpl:Ak,logImpl:Ok,maxImpl:Fk,maximumImpl:Dk,minimumImpl:Pk,multiplyImpl:jg,negImpl:Lk,notEqualImpl:Mk,prodImpl:Vk,raggedGatherImpl:qk,raggedTensorToTensorImpl:Kk,rangeImpl:qg,rsqrtImpl:Xk,scatterImpl:Yk,sigmoidImpl:Qk,simpleAbsImpl:gk,sliceImpl:Ku,sparseFillEmptyRowsImpl:Zk,sparseReshapeImpl:Jk,sparseSegmentReductionImpl:eN,sqrtImpl:tN,squaredDifferenceImpl:nN,stridedSliceImpl:rN,stringNGramsImpl:Kg,stringSplitImpl:Xg,stringToHashBucketFastImpl:Yg,subImpl:oN,tileImpl:iN,topKImpl:uN,transposeImpl:Bk,uniqueImpl:cN},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:pN,bincountImpl:Zg,bincountReduceImpl:dN,castImpl:hN,ceilImpl:fN,concatImpl:mN,equalImpl:gN,expImpl:yN,expm1Impl:xN,floorImpl:bN,gatherNdImpl:wN,gatherV2Impl:vN,greaterImpl:SN,greaterEqualImpl:$N,lessImpl:IN,lessEqualImpl:TN,linSpaceImpl:CN,logImpl:_N,maxImpl:kN,maximumImpl:NN,minimumImpl:EN,multiplyImpl:RN,negImpl:AN,notEqualImpl:ON,prodImpl:FN,raggedGatherImpl:DN,raggedTensorToTensorImpl:PN,rangeImpl:LN,rsqrtImpl:MN,scatterImpl:BN,sigmoidImpl:VN,simpleAbsImpl:Jg,sliceImpl:WN,sparseFillEmptyRowsImpl:UN,sparseReshapeImpl:zN,sparseSegmentReductionImpl:ey,sqrtImpl:GN,stridedSliceImpl:HN,stringNGramsImpl:jN,stringSplitImpl:qN,stringToHashBucketFastImpl:KN,subImpl:XN,tileImpl:YN,topKImpl:QN,transposeImpl:Sp,uniqueImpl:ZN}=lN;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ty(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function Pt(n,e){return e===1?[n]:ty(n,e)}function JN(n,e){if(n===1)return"rc";let t="";for(let r=0;r<n;r++)t+=e[r],r<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eE{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Wt(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=Pt("rc",this.rank),r=Ke(this.rank),s=this.getOutOfBoundsCondition(t),a=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let a=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)a=`${e[e.length-1-o]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let r=this.rank-2;r<this.rank;r++)t+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ny{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Wt(this.outputShape.length);let r="";for(let s=0;s<4;s++){let a="thisRC = rc;";s%2===1&&(a+="thisRC.z += 1;"),s>1&&(a+="thisRC.y += 1;"),r+=`
        ${a}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${tE(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?wp():bp(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function tE(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?i_(["r","c","d"],"inputShape"):Qr(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nE{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,r){const s=vd(t,r),a=Sd(e,s,r);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const o=wd(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const u=this.freeTextures[a].shift();return this.usedTextures[a].push(u),u}let i;return s===$t.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===$t.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===$t.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===$t.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===$t.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(i),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),i}releaseTexture(e,t,r,s){if(this.freeTextures==null)return;const a=vd(r,s),o=Sd(t,a,s);o in this.freeTextures||(this.freeTextures[o]=[]);const i=wd(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,s),u=L().get("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[o],c=l.indexOf(e);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(c,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function rE(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function wd(n,e,t,r,s){const a=sE(e,r);let o;if(s){const[u,l]=ks(n[0],n[1]);o=u*l}else{const[u,l]=Ta(n[0],n[1]);o=u*l}const i=rE(t,a);return o*i}function sE(n,e){switch(n){case $t.PACKED_2X2_FLOAT32:return zg(e);case $t.PACKED_2X2_FLOAT16:return Gg(e);case $t.UNPACKED_FLOAT32:return Vg(e);case $t.UNPACKED_FLOAT16:return Wg(e);case $t.PACKED_4X1_UNSIGNED_BYTE:return Ug(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function aE(n){return L().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?$t.PACKED_2X2_FLOAT32:$t.UNPACKED_FLOAT32:n?$t.PACKED_2X2_FLOAT16:$t.UNPACKED_FLOAT16}function vd(n,e){if(n===cn.UPLOAD)return $t.PACKED_2X2_FLOAT32;if(n===cn.RENDER||n==null)return aE(e);if(n===cn.DOWNLOAD||n===cn.PIXELS)return $t.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function Sd(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kn{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Wt(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const $n="if (isnan(x)) return x;",oE="return x;",$d="return abs(x);",iE="return (x >= 0.0) ? x : (exp(x) - 1.0);",uE=$n+`
  return (x < 0.0) ? 0.0 : x;
`,cE=$n+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ss="return x;",lE="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pE="return x;",dE=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,hE=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,fE=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,mE="return 1.0 / (1.0 + exp(-1.0 * x));";class Pr{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Wt(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gE{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Wt(this.outputShape.length);const t=e.length,r=Pt("rc",t),s=Ke(t),a=JN(t,r),o=r.slice(-2),i=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yE=ig,xE=1e-7,bE=1e-4,qa={};function wE(n){return n in qa||(qa[n]={}),qa[n]}const vE=L().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),SE=600;function $E(){return L().global.screen==null?1024:L().global.screen.height*L().global.screen.width*window.devicePixelRatio*SE/1024/1024}class Fi extends wc{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!L().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof nu)t=e;else{const r=_n(L().getNumber("WEBGL_VERSION"),e);t=new nu(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=_n(L().getNumber("WEBGL_VERSION"));t=new nu(r),this.binaryCache=wE(L().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new nE(this.gpgpu),this.numMBBeforeWarning=$E(),this.texData=new Nh(this,or())}nextDataId(){return Fi.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,r){if((L().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||L().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:t,dtype:r,values:e,usage:cn.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,r,s,a){if(L().getBool("DEBUG")&&this.checkNumericalProblems(t),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:s,values:t,usage:cn.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:r,dtype:s,complexTensorInfos:a,slice:o,shape:i,isPacked:u}=t;if(o!=null){let d;u?d=new Pr(i,ss):d=new Kn(i,ss);const h=this.runWebGLProgram(d,[{dataId:e,shape:i,dtype:s}],s),f=this.readSync(h.dataId);return this.disposeIntermediateTensorInfo(h),f}if(r!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return r;const l=this.activeTimers!=null;let c;l&&(c=un());let p;if(s==="complex64"){const d=this.readSync(a.real.dataId),h=this.readSync(a.imag.dataId);p=ju(d,h)}else p=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=un()-c),this.convertAndCacheOnCPU(e,p)}read(e){return se(this,null,function*(){if(this.pendingRead.has(e)){const f=this.pendingRead.get(e);return new Promise(m=>f.push(m))}const t=this.texData.get(e),{values:r,shape:s,slice:a,dtype:o,complexTensorInfos:i,isPacked:u}=t;if(a!=null){let f;u?f=new Pr(s,ss):f=new Kn(s,ss);const m=this.runWebGLProgram(f,[{dataId:e,shape:s,dtype:o}],o),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(r!=null)return this.convertAndCacheOnCPU(e);if(L().getBool("DEBUG")&&!L().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&L().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,c;if(o!=="complex64"&&L().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const f=this.texData.get(c.dataId);l=this.gpgpu.createBufferFromTexture(f.texture.texture,...za(s))}this.pendingRead.set(e,[]),o!=="complex64"&&(yield this.gpgpu.createAndWaitForFence());let p;if(o==="complex64"){const f=yield Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),m=f[0],g=f[1];p=ju(m,g)}else if(l==null)p=this.getValuesFromTexture(e);else{const f=V(s);p=this.gpgpu.downloadFloat32MatrixFromBuffer(l,f)}if(c!=null&&this.disposeIntermediateTensorInfo(c),l!=null){const f=this.gpgpu.gl;oe(f,()=>f.deleteBuffer(l))}const d=this.convertAndCacheOnCPU(e,p),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach(f=>f(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&or().removeDataId(e,this),this.pendingDeletes--),d})}readToGPU(e,t={}){const r=this.texData.get(e),{values:s,shape:a,slice:o,dtype:i,isPacked:u,texture:l}=r;if(i==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let h;u?h=new Pr(a,ss):h=new Kn(a,ss);const f=this.runWebGLProgram(h,[{dataId:e,shape:a,dtype:i}],i),m=this.readToGPU(f,t);return this.disposeIntermediateTensorInfo(f),m}if(l==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,t.customTexShape),p=or().makeTensorFromTensorInfo(c),d=this.texData.get(c.dataId);return Object.assign({tensorRef:p},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(s=>bs(s));return it(e.shape,e.dtype,r)}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return it(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const r=e[t];if(!FC(r))throw L().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:r,isPacked:s}=this.texData.get(e),a=V(t);if(L().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(e),h=this.texData.get(d.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(h.texture.texture,...za(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(d),f}const o=L().getBool("WEBGL_PACK")&&s===!0,i=o?Ji(t):t,u=o?new Y_(i):new X_(i),l=this.runWebGLProgram(u,[{shape:i,dtype:r,dataId:e}],"float32"),c=this.texData.get(l.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),p}timerAvailable(){return L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const a=ms(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),o=ms(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,s&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(()=>se(this,null,function*(){if(L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=yield Promise.all(a);i.kernelMs=Ab(u),i.getExtraProfileInfo=()=>u.map((l,c)=>({name:o[c],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i}))()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:un(),endMs:null}}endTimer(e){return L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=un(),e)}getQueryTime(e){return se(this,null,function*(){if(L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs})}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:r,texShape:s,usage:a,isPacked:o,slice:i}=this.texData.get(e),u=i&&i.origDataId||e,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),t!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(t,s,a,o)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=vE){return L().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&V(r.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Cn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return yE(e.shape,t)}packedUnaryOp(e,t,r){const s=new Pr(e.shape,t),a=this.compileAndRun(s,[e],r);return or().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const s=Jg(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(L().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,$d,e.dtype);const t=new Kn(e.shape,$d),r=this.compileAndRun(t,[e]);return or().makeTensorFromTensorInfo(r)}makeTensorInfo(e,t,r){let s;if(t==="string"&&r!=null&&r.length>0&&$o(r[0])){const a=r.map(o=>Mr(o));s=this.write(a,e,t)}else s=this.write(r,e,t);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:t}}makeOutput(e,t,r){return or().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,r),this)}unpackTensor(e){const t=new gE(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new eE(e.shape),r=!0;return this.runWebGLProgram(t,[e],e.dtype,null,r)}packedReshape(e,t){const r=[Ss(e.shape),...$s(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[Ss(t),...$s(t)],o=new ny(a,r),i=!0,u=[r],l=this.runWebGLProgram(o,[s],e.dtype,u,i);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e,t){const r=this.texData.get(e),{isPacked:s,shape:a,dtype:o}=r;if(t!=null){const d=V(a),h=t[0]*t[1]*4;I(d<=h,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const i=Ji(a);let u;s?u=new K_(i):u=new q_(i);const l=!0,c=[t!=null?t:za(i)],p=this.runWebGLProgram(u,[{shape:i,dtype:o,dataId:e}],o,c,l,t);return{dtype:o,shape:a,dataId:p.dataId}}runWebGLProgram(e,t,r,s,a=!1,o){const i=this.makeTensorInfo(e.outputShape,r),u=this.texData.get(i.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===ca.DENSE){const y=o!=null?o:za(e.outputShape);u.texShape=y.map(x=>x*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),V(i.shape)===0)return u.values=Zn(i.dtype,0),i;const l=[],c=t.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let x=this.texData.get(y.dataId);if(x.texture==null){if(!e.packedInputs&&V(y.shape)<=L().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:x.values};e.packedInputs&&(x.isPacked=!0,x.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!x.isPacked!=!!e.packedInputs)y=x.isPacked?this.unpackTensor(y):this.packTensor(y),l.push(y),x=this.texData.get(y.dataId);else if(x.isPacked&&!ho(x.shape,y.shape)){const w=y,v=y.shape;y.shape=x.shape,y=this.packedReshape(y,v),l.push(y),x=this.texData.get(y.dataId),w.shape=v}return{shape:y.shape,texData:x,isUniform:!1}});this.uploadToGPU(i.dataId);const p={shape:i.shape,texData:u,isUniform:!1},d=j_(e,c,p),h=this.getAndSaveBinary(d,()=>G_(this.gpgpu,e,c,p)),f=this.activeTimers!=null;let m;f&&(m=this.startTimer()),L().get("ENGINE_COMPILE_ONLY")||H_(this.gpgpu,h,c,p,s),l.forEach(y=>this.disposeIntermediateTensorInfo(y)),f&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const g=L().get("WEBGL_FLUSH_THRESHOLD");if(g>0){const y=un();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!L().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&a===!1){const y=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),y}return i}compileAndRun(e,t,r,s,a=!1){return r=r||t[0].dtype,this.runWebGLProgram(e,t,r,s,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(L().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Be(()=>{if(!L().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=L().getBool("DEBUG");L().set("DEBUG",!1);const t=this.abs(Re(1e-8)).dataSync()[0];if(L().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?xE:bE}uploadToGPU(e){const t=this.texData.get(e),{shape:r,dtype:s,values:a,texture:o,usage:i,isPacked:u}=t;if(o!=null)return;const l=this.activeTimers!=null;let c;l&&(c=un());let p=t.texShape;if(p==null&&(p=ZC(r,u),t.texShape=p),a!=null){const d=Ji(r);let h,f=p[1],m=p[0];const g=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(u||!g)&&([f,m]=ks(p[0],p[1])),u?h=new Z_(d,g):h=new Q_(d,g);const y=g?[m,f]:p,x=this.makeTensorInfo(y,s),w=this.texData.get(x.dataId);g?w.usage=cn.PIXELS:w.usage=cn.UPLOAD,w.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId),f,m,a);const v=[[m,f]],$=!0,C=this.runWebGLProgram(h,[x],s,v,$),k=this.texData.get(C.dataId);t.texShape=k.texShape,t.isPacked=k.isPacked,t.usage=k.usage,L().get("ENGINE_COMPILE_ONLY")?this.disposeData(C.dataId):(t.texture=k.texture,t.values=null,this.texData.delete(C.dataId)),this.disposeIntermediateTensorInfo(x),l&&(this.uploadWaitMs+=un()-c)}else{const d=this.acquireTexture(p,i,s,u);t.texture=d}}convertAndCacheOnCPU(e,t){const r=this.texData.get(e),{dtype:s}=r;return this.releaseGPUData(e),t!=null&&(r.values=IE(t,s)),r.values}acquireTexture(e,t,r,s){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,s)}computeBytes(e,t){return e[0]*e[1]*Qs(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){return se(this,null,function*(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const r=new Promise(s=>{try{this.checkCompletion_(t),s(!0)}catch(a){throw a}});e.push(r)}return Promise.all(e)}})}checkCompletionAsync_(e){return se(this,null,function*(){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(yield fC(),this.checkCompletionAsync_(e))})}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(Fg(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:r,infLoc:s,nanLoc:a,inShapesLocations:o,inTexShapesLocations:i,outShapeLocation:u,outShapeStridesLocation:l,outTexShapeLocation:c}=Bg(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=r,e.infLoc=s,e.nanLoc=a,e.inShapesLocations=o,e.inTexShapesLocations=i,e.outShapeLocation=u,e.outShapeStridesLocation=l,e.outTexShapeLocation=c}}}Fi.nextDataId=0;function IE(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<t.length;++r)t[r]=Math.round(n[r]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */jf()&&hm("webgl",()=>new Fi,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $p=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Is{constructor(e,t,r){this.variableNames=["A","B"],this.outputShape=Ne(t,r),this.enableShapeUniforms=Wt(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ka=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Na{constructor(e,t,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ne(t,r);const a=this.outputShape.length;this.enableShapeUniforms=Wt(a);let o="";if(s)if(a===0||V(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Ke(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=Pt("coords",a);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${u[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${u[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${u[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${u[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qt(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const TE={kernelName:Go,backendName:"webgl",kernelFunc:Qt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sr(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,a=t.makeTensorInfo(r.shape,"complex64"),o=t.texData.get(a.dataId),i=Qt({inputs:{x:r},backend:t}),u=Qt({inputs:{x:s},backend:t});return o.complexTensorInfos={real:i,imag:u},a}const CE={kernelName:qh,backendName:"webgl",kernelFunc:Sr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ry="return (a < 0.) ? b * a : a;",sy=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function _E(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:a}=r,o=t.makeTensorInfo([],"float32",Cs(a,"float32")),i=L().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Na(sy,s.shape,o.shape):new Is(ry,s.shape,o.shape),u=t.runWebGLProgram(i,[s,o],"float32");return t.disposeIntermediateTensorInfo(o),u}const kE={kernelName:Ho,backendName:"webgl",kernelFunc:_E};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ay="return (a < 0.) ? b * a : a;",oy=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function NE(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e,a=L().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Na(oy,r.shape,s.shape):new Is(ay,r.shape,s.shape);return t.runWebGLProgram(a,[r,s],"float32")}const EE={kernelName:ni,backendName:"webgl",kernelFunc:NE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Os="if (isnan(x)) return x;";function Ae({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:r}){return({inputs:s,backend:a})=>{const{x:o}=s,i=a,u=r||o.dtype;if(i.shouldExecuteOnCPU([o])&&t!=null){const p=i.texData.get(o.dataId),d=t(p.values,u);return i.makeTensorInfo(o.shape,u,d)}const l=L().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let c;return l?c=new Pr(o.shape,e):c=new Kn(o.shape,n),i.runWebGLProgram(c,[o],u)}}function Ct({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:o,backend:i})=>{const{a:u,b:l}=o,c=i;if(r&&u.dtype==="complex64"){const f=c.texData.get(u.dataId),m=c.texData.get(l.dataId),[g,y]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(w=>{const[v,$]=w,C={dataId:v.dataId,dtype:v.dtype,shape:u.shape},k={dataId:$.dataId,dtype:$.dtype,shape:l.shape},R=new Is(n,u.shape,l.shape);return c.runWebGLProgram(R,[C,k],Bn(v.dtype,$.dtype))}),x=Sr({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),x}const p=a||Bn(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||c.shouldExecuteOnCPU([u,l]))&&s!=null){const f=c.texData.get(u.dataId).values,m=c.texData.get(l.dataId).values,g=u.dtype==="string"?ua(f):f,y=u.dtype==="string"?ua(m):m,[x,w]=s(u.shape,l.shape,g,y,p),v=c.makeTensorInfo(w,p),$=c.texData.get(v.dataId);return $.values=x,v}const d=L().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let h;return d?h=new Na(e,u.shape,l.shape,t):h=new Is(n,u.shape,l.shape),c.runWebGLProgram(h,[u,l],p)}}function la(n,e=!1){if(n==="linear")return e?pE:oE;if(n==="relu")return e?hE:uE;if(n==="elu")return e?dE:iE;if(n==="relu6")return e?fE:cE;if(n==="prelu")return e?oy:ay;if(n==="leakyrelu")return e?sy:ry;if(n==="sigmoid")return e?mE:lE;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iy{constructor(e,t,r,s=!1,a=!1,o=!1,i=null,u=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Wt(this.outputShape.length);const c=s?e[1]:e[2],p=Math.ceil(c/2),d=s?"i * 2, rc.y":"rc.y, i * 2",h=a?"rc.z, i * 2":"i * 2, rc.z",f=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";i&&(u?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:g=`vec4 activation(vec4 x) {
          ${i}
        }`,y="result = activation(result);");const x=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let w="rc.x",v="rc.x";e[0]<t[0]?w=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(v=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${p}; i++) {
          int batchA = ${w};
          int batchB = ${v};
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${h});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${m[0]});
          result += (${f[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${x}

        ${y}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Id={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Td{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ne(t,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cd="return a * b;";function Ip(n){const{inputs:e,backend:t}=n,{a:r,b:s}=e,a=Bn(r.dtype,s.dtype);if(r.dtype==="complex64"){const i=t.texData.get(r.dataId),u=t.texData.get(s.dataId),l=new Td(Id.REAL,r.shape,s.shape),c=new Td(Id.IMAG,r.shape,s.shape),p=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:r.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:s.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:s.shape}],d=t.runWebGLProgram(l,p,"float32"),h=t.runWebGLProgram(c,p,"float32"),f=Sr({inputs:{real:d,imag:h},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),f}if(t.shouldExecuteOnCPU([r,s])){const i=t.texData.get(r.dataId),u=t.texData.get(s.dataId),[l,c]=RN(r.shape,s.shape,i.values,u.values,a),p=t.makeTensorInfo(c,a),d=t.texData.get(p.dataId);return d.values=l,p}let o;return L().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new Na(Cd,r.shape,s.shape):o=new Is(Cd,r.shape,s.shape),t.runWebGLProgram(o,[r,s],a)}const RE={kernelName:Xc,backendName:"webgl",kernelFunc:Ip};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AE(n,e,t){const r=[Ss(n.shape),...$s(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},a=[Ss(e),...$s(e)],o=new ny(a,r),i=!0,u=[r],l=t.runWebGLProgram(o,[s],n.dtype,u,i);return{dataId:l.dataId,shape:e,dtype:l.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function te(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{shape:a}=r,o=t,i=V(s.shape),u=Eh(a,i),l=V(u);I(i===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);const c=o.texData.get(s.dataId);return c.isPacked&&!ho(s.shape,u)&&!(c.texture!==null&&ho(c.shape,u))?AE(s,u,o):(o.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype})}const OE={kernelName:rl,backendName:"webgl",kernelFunc:te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _d{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:a,outSize:o}=e;this.outputShape=[s,o];const i=Math.floor(r/4)*4,u=r%4;let l="sumValue += dot(values, ones);";if(t!=null){const p=1/t;l=`sumValue += dot(values * ${gs(p)?p.toPrecision(2):p}, ones);`}let c="";a%r>0&&(c=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FE{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:a,outSize:o}=e;this.outputShape=[s,o];let i="0.0",u="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",u="min"):t==="max"&&(i="-1.0 / 1e-20",u="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");const c=Math.floor(r/4)*4,p=r%4;let d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,h="vec4";t==="all"?(i="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,h="bvec4"):t==="any"&&(i="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,h="bvec4");let f="";a%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${p===2}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${p===3}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${l});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DE(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],r=Ai(t);e.push({inSize:t,windowSize:r,outSize:Math.ceil(t/r)})}return e}function Jr(n,e,t,r){const s=DE(n.shape);let a=n;for(let o=0;o<s.length;o++){const{inSize:i,windowSize:u,outSize:l}=s[o];let c,p;t==="mean"?c=o===0?new _d({windowSize:u,inSize:i,batchSize:n.shape[0],outSize:l},i):new _d({windowSize:u,inSize:i,batchSize:n.shape[0],outSize:l}):c=new FE({windowSize:u,inSize:i,batchSize:n.shape[0],outSize:l},t),p=a,a=r.runWebGLProgram(c,[a],e),p.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(p)}return a}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PE{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[t[o]];this.outputShape=r,this.rank=r.length;const s=Ke(this.rank),a=LE(t);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}}function LE(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let s=0;s<n.length;s++)r[n[s]]=t[s];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ME{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let c=0;c<r.length;c++)r[c]=e[t[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Ke(this.rank),a=ty("rc",this.rank),o=new Array(this.rank);for(let c=0;c<t.length;c++)o[t[c]]=a[c];const i=`vec2(${o.slice(-2).join()})`,u=`++${a[this.rank-1]} < ${r[this.rank-1]}`,l=`getChannel(getA(${o.join()}), ${i})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Di(n,e,t){const r=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ME(n.shape,e):new PE(n.shape,e);return t.runWebGLProgram(r,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BE(n,e,t,r){const s=e,a=n.shape.length,o=ct(s,n.shape);let i=o;const u=Ht(i,a),l=u!=null;let c=n;l&&(c=Di(n,u,r),i=Tt(i.length,a)),gt("sum",i,a);const[p,d]=kt(c.shape,i);let h=p;t&&(h=mt(p,o));const f=V(d),g=V(n.shape)/f,y=te({inputs:{x:c},attrs:{shape:[g,f]},backend:r}),x=_l(n.dtype),w=Jr(y,x,"sum",r),v=te({inputs:{x:w},attrs:{shape:h},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(w),l&&r.disposeIntermediateTensorInfo(c),v}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pi(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:a,keepDims:o}=r;return BE(s,a,o,t)}const VE={kernelName:ui,backendName:"webgl",kernelFunc:Pi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bt(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{perm:a}=r,o=t,i=s.shape.length,u=new Array(i);for(let c=0;c<u.length;c++)u[c]=s.shape[a[c]];let l;if(o.shouldExecuteOnCPU([s])){const p=o.texData.get(s.dataId).values,d=Sp(p,s.shape,s.dtype,a,u);l=o.makeTensorInfo(u,s.dtype);const h=o.texData.get(l.dataId);h.values=d}else l=Di(s,a,o);return l}const WE={kernelName:ps,backendName:"webgl",kernelFunc:Bt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uy=1e3;function mo({a:n,b:e,transposeA:t,transposeB:r,backend:s,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:u=null}){const l=n.shape.length,c=e.shape.length,p=t?n.shape[l-2]:n.shape[l-1],d=r?e.shape[c-1]:e.shape[c-2],h=t?n.shape[l-1]:n.shape[l-2],f=r?e.shape[c-2]:e.shape[c-1],m=n.shape.slice(0,-2),g=e.shape.slice(0,-2),y=V(m),x=V(g),v=Ne(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([h,f]);I(p===d,()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);const $=t?[y,p,h]:[y,h,p],C=r?[x,f,d]:[x,d,f],k=te({inputs:{x:n},backend:s,attrs:{shape:$}}),R=te({inputs:{x:e},backend:s,attrs:{shape:C}}),F=[k,R],D=Math.max(y,x),M=t?k.shape[1]:k.shape[2],U=a!=null,j=o!=null,Y=u==="leakyrelu",Q=u!=null?la(u,!0):null,ae=U||j||Y||Q!=null;let me;if((h===1||f===1)&&M>uy&&ae===!1){let De=k,Xe=R;t&&(De=Bt({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),F.push(De)),r&&(Xe=Bt({inputs:{x:R},backend:s,attrs:{perm:[0,2,1]}}),F.push(Xe));const lt=f!==1,wt=f===1;let Je=De;lt&&(Je=te({inputs:{x:De},backend:s,attrs:{shape:[D,M,1]}}),F.push(Je));const Nn=f===1?2:1;let jt=Xe;wt&&(jt=te({inputs:{x:Xe},backend:s,attrs:{shape:[D,1,M]}}),F.push(jt));const En=Ip({inputs:{a:Je,b:jt},backend:s});me=Pi({inputs:{x:En},backend:s,attrs:{axis:Nn,keepDims:!0}}),F.push(En)}else{const De=Bn(n.dtype,e.dtype),Xe=new iy($,C,[D,h,f],t,r,U,Q,j,Y),lt=[k,R];if(a!=null&&lt.push(a),j&&lt.push(o),Y){const wt=s.makeTensorInfo([],"float32",Cs(i,"float32"));lt.push(wt),F.push(wt)}me=s.runWebGLProgram(Xe,lt,De)}const le=te({inputs:{x:me},backend:s,attrs:{shape:v}});F.push(me);for(const De of F)s.disposeIntermediateTensorInfo(De);return le}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UE(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:a,bias:o,preluActivationWeights:i}=e,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=r;return mo({a:s,b:a,transposeA:u,transposeB:l,backend:t,bias:o,preluActivationWeights:i,leakyreluAlpha:p,activation:c})}const zE={kernelName:Zs,backendName:"webgl",kernelFunc:UE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kd="return abs(x);";function GE(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const a=t.texData.get(r.dataId),o=Jg(a.values);return t.makeTensorInfo(r.shape,r.dtype,o)}let s;return L().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Pr(r.shape,kd):s=new Kn(r.shape,kd),t.runWebGLProgram(s,[r],r.dtype)}const HE={kernelName:Ic,backendName:"webgl",kernelFunc:GE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jE=$n+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,qE=Ae({opSnippet:jE}),KE={kernelName:Ph,backendName:"webgl",kernelFunc:qE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XE=$n+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,YE=Ae({opSnippet:XE}),QE={kernelName:Lh,backendName:"webgl",kernelFunc:YE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nd="return a + b;",ZE=Ct({opSnippet:Nd,packedOpSnippet:Nd,supportsComplex:!0,cpuKernelImpl:pN}),JE={kernelName:To,backendName:"webgl",kernelFunc:ZE};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eR{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((a,o)=>`T${o}`);const r=[];this.variableNames.forEach(a=>{r.push(`float v${a} = get${a}AtOutCoords();`)});const s=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tR{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((a,o)=>`T${o}`);const r=[];this.variableNames.forEach(a=>{r.push(`vec4 v${a} = get${a}AtOutCoords();`)});const s=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Za(n){const{inputs:e,backend:t}=n,r=e;if(r.length===1)return Qt({inputs:{x:r[0]},backend:t});if(r.length>L().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(r.length/2),l=Za({inputs:r.slice(0,u),backend:t}),c=Za({inputs:r.slice(u),backend:t});return Za({inputs:[l,c],backend:t})}const s=r.map(u=>u.dtype).reduce((u,l)=>Bn(u,l)),a=r.map(u=>u.shape),i=L().getBool("WEBGL_PACK")?new tR(r[0].shape,a):new eR(r[0].shape,a);return t.runWebGLProgram(i,r,s)}const nR={kernelName:Co,backendName:"webgl",kernelFunc:Za};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rR(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:a,keepDims:o}=r,i=s.shape.length,u=ct(a,s.shape);let l=u;const c=Ht(l,i);let p=s;c!=null&&(p=Bt({inputs:{x:s},backend:t,attrs:{perm:c}}),l=Tt(l.length,i)),gt("all",l,i);const[d,h]=kt(p.shape,l),f=V(h),m=te({inputs:{x:p},backend:t,attrs:{shape:[-1,f]}}),g=Jr(m,m.dtype,"all",t);let y;if(o){const x=mt(d,u);y=te({inputs:{x:g},backend:t,attrs:{shape:x}})}else y=te({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(p),y}const sR={kernelName:_o,backendName:"webgl",kernelFunc:rR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aR(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:a,keepDims:o}=r,i=s.shape.length,u=ct(a,s.shape);let l=u;const c=Ht(l,i);let p=s;c!=null&&(p=Bt({inputs:{x:s},backend:t,attrs:{perm:c}}),l=Tt(l.length,i)),gt("any",l,i);const[d,h]=kt(p.shape,l),f=V(h),m=te({inputs:{x:p},backend:t,attrs:{shape:[-1,f]}}),g=Jr(m,m.dtype,"any",t);let y;if(o){const x=mt(d,u);y=te({inputs:{x:g},backend:t,attrs:{shape:x}})}else y=te({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(p),y}const oR={kernelName:ko,backendName:"webgl",kernelFunc:aR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iR{constructor(e,t,r){this.variableNames=["A"];const{windowSize:s,batchSize:a,outSize:o}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[a,o];const i=t==="max"?">":"<",u=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uR{constructor(e,t,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,I(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const a=e[e.length-1],o=Math.ceil(a/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),s||this.variableNames.push("bestIndicesA");const i=this.outputShape,u=i.length,l=Ke(u),c=Pt("coords",u);let p,d;if(o===1){d=u+1;const R=Ke(d);p=`
        ${R} sourceLocR = ${R}(${c.join()}, 0);
        ++${c[u-1]};
        ${R} sourceLocG = ${R}(${c.join()}, 0);
        ++${c[u-2]};
        ${R} sourceLocA = ${R}(${c.join()}, 0);
        --${c[u-1]};
        ${R} sourceLocB = ${R}(${c.join()}, 0);
        --${c[u-2]};`}else d=u,p=`
        ${l} sourceLocR = coords;
        ++${c[u-1]};
        ${l} sourceLocG = coords;
        ++${c[u-2]};
        ${l} sourceLocA = coords;
        --${c[u-1]};
        ${l} sourceLocB = coords;
        --${c[u-2]};`;const h=["x","y","z","w","u","v"].slice(0,d),f="."+h[d-1],m=h.map(R=>"int "+R),g=Pt("sourceLocR",d-1).concat("inIdx.r"),y=Pt("sourceLocG",d-1).concat("inIdx.g"),x=Pt("sourceLocB",d-1).concat("inIdx.b"),w=Pt("sourceLocA",d-1).concat("inIdx.a"),v=r==="max"?"greaterThan":"lessThan",$=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${w.join()})));`,C=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${x.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,k=s?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${h.join()}),
                                          vec2(${h.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${h.join()}),
                               vec2(${h.slice(-2).join()}));
      }
      ${k}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${c[u-1]} < ${i[u-1]-1};
        bool hasNextRow = ${c[u-2]} < ${i[u-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${C};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${$}
          vec4 candidate = ${C};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cy(n,e,t,r=null){let s=e.shape[0],a=e.shape[1];r!=null&&(s=r.shape[0],a=r.shape[1]);const o=Ai(a),i={windowSize:o,inSize:a,batchSize:s,outSize:Math.ceil(a/o)},u=new iR(i,t,r==null),l=[e];r!=null&&l.push(r);const c=n.runWebGLProgram(u,l,"int32");if(c.shape[1]===1)return c;const p=cy(n,e,t,c);return n.disposeIntermediateTensorInfo(c),p}function ly(n,e,t,r=null){const s=r!=null?r.shape:e.shape,a=s[s.length-1],o=Ai(a),i=new uR(s,o,t,r==null),u=r==null?[e]:[e,r],l=n.runWebGLProgram(i,u,"int32");if(l.shape.length===e.shape.length){const c=ly(n,e,t,l);return n.disposeIntermediateTensorInfo(l),c}return l}function py(n,e,t,r){const s=[t];if(gt("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!L().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const a=[],o=n.texData.get(e.dataId),i=o!==null&&o.isPacked;let u=e;i&&(u=n.unpackTensor(e),a.push(u));const[l,c]=kt(u.shape,s),p=V(c),d=te({inputs:{x:u},backend:n,attrs:{shape:[-1,p]}});a.push(d);const h=cy(n,d,r);a.push(h);const f=te({inputs:{x:h},backend:n,attrs:{shape:l}});return a.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}return ly(n,e,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cR(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:a}=r;let o=ct(a,s.shape);const i=Ht(o,s.shape.length);let u=s;const l=[];i!=null&&(u=Bt({inputs:{x:s},backend:t,attrs:{perm:i}}),l.push(u),o=Tt(o.length,u.shape.length)),gt("argMax",[o[0]],u.shape.length);const c=py(t,u,o[0],"max");return l.forEach(p=>t.disposeIntermediateTensorInfo(p)),c}const lR={kernelName:No,backendName:"webgl",kernelFunc:cR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pR(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:a}=r;let o=ct(a,s.shape);const i=Ht(o,s.shape.length);let u=s;const l=[];i!=null&&(u=Bt({inputs:{x:s},backend:t,attrs:{perm:i}}),l.push(u),o=Tt(o.length,u.shape.length)),gt("argMin",[o[0]],u.shape.length);const c=py(t,u,o[0],"min");return l.forEach(p=>t.disposeIntermediateTensorInfo(p)),c}const dR={kernelName:Mh,backendName:"webgl",kernelFunc:pR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hR=$n+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,fR=Ae({opSnippet:hR}),mR={kernelName:Bh,backendName:"webgl",kernelFunc:fR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gR=$n+"return log(x + sqrt(x * x + 1.0));",yR=Ae({opSnippet:gR}),xR={kernelName:Vh,backendName:"webgl",kernelFunc:yR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bR=$n+`
  return atan(x);
`,wR=Ae({opSnippet:bR}),vR={kernelName:Wh,backendName:"webgl",kernelFunc:wR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SR=$p+`
  return atan(a, b);
`,$R=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+ka+`
  return result;
`,IR=Ct({opSnippet:SR,packedOpSnippet:$R}),TR={kernelName:zh,backendName:"webgl",kernelFunc:IR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CR=$n+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,_R=Ae({opSnippet:CR}),kR={kernelName:Uh,backendName:"webgl",kernelFunc:_R};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pa{constructor(e,t,r,s=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,i=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,p=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;const m=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let x="0.0";if(m||(x="-1.0 / 1e-20"),r){const R=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${u});
        const ivec2 pads = ivec2(${h}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${R} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?a?g:y:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const w="max";let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(v="avgValue / count");const $=Math.floor(o/4)*4,C=o%4,k=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${u});
      const ivec2 pads = ivec2(${h}, ${f});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${$}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${k}
          }

          int xC = xCCorner + ${$};
          if (${C===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${C===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${C===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${k}
          }
        }
        setOutput(${v});
      }
    `}}class Tp{constructor(e,t,r,s=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,i=e.strideDepth,u=e.strideHeight,l=e.strideWidth,c=e.dilationDepth,p=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,f=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=e.padInfo.front,y=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;const w=t==="avg";let v="0.0";if(w||(v="-1.0 / 1e-20"),r){const D=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${u}, ${l});
        const ivec3 pads = ivec3(${g}, ${y}, ${x});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${h};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${D} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const $="max";let C=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(C="avgValue / count");const k=Math.floor(o/4)*4,R=o%4,F=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${$}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${u}, ${l});
      const ivec3 pads = ivec3(${g}, ${y}, ${x});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${k}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${F}
            }

            int xC = xCCorner + ${k};
            if (${R===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${F}
            } else if (${R===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${F}
            } else if (${R===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${F}
            }
          }
          setOutput(${C});
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NR(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;Ca(s,"avgPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=r,l=1;I(en(o,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const c=nr(s.shape,a,o,l,i,u);if(c.filterWidth===1&&c.filterHeight===1&&pt(c.inShape,c.outShape))return Qt({inputs:{x:s},backend:t});const p=new pa(c,"avg",!1);return t.runWebGLProgram(p,[s],"float32")}const ER={kernelName:Eo,backendName:"webgl",kernelFunc:NR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RR(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:a,strides:o,pad:i,dimRoundingMode:u,dataFormat:l}=r,c=[1,1,1],p=xa(s.shape,a,o,c,i,u,l),d=new Tp(p,"avg",!1);return t.runWebGLProgram(d,[s],"float32")}const AR={kernelName:Gh,backendName:"webgl",kernelFunc:RR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OR{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,a=e.strideWidth,o=e.dilationHeight,i=e.dilationWidth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=u-1-e.padInfo.top,p=l-1-e.padInfo.left,d=1/(t*r);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${p});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class FR{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,a=e.strideDepth,o=e.strideHeight,i=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,p=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,f=p-1-e.padInfo.front,m=d-1-e.padInfo.top,g=h-1-e.padInfo.left,y=1/(t*r*s);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DR(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:a}=e,o=a,{filterSize:i,strides:u,pad:l,dimRoundingMode:c}=r,p=[1,1,1],d=xa(o.shape,i,u,p,l,c),h=new FR(d);return t.runWebGLProgram(h,[s],o.dtype)}const PR={kernelName:jb,backendName:"webgl",kernelFunc:DR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LR(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:a}=e,o=a;Ca([s,a],"avgPoolGrad");const{filterSize:i,strides:u,pad:l}=r,c=nr(o.shape,i,u,1,l),p=new OR(c);return t.runWebGLProgram(p,[s],o.dtype)}const MR={kernelName:Hb,backendName:"webgl",kernelFunc:LR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BR(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:a}=e,{transposeA:o,transposeB:i}=r;return mo({a:s,b:a,transposeA:o,transposeB:i,backend:t})}const VR={kernelName:Ro,backendName:"webgl",kernelFunc:BR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WR{constructor(e,t,r,s,a,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Ne(e,t),Ne(e,r);let i="0.0";s!=null&&(Ne(e,s),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="1.0";a!=null&&(Ne(e,a),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UR{constructor(e,t,r,s,a,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ne(e,t),Ne(e,r);let i="vec4(0.0)";s!=null&&(Ne(e,s),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="vec4(1.0)";a!=null&&(Ne(e,a),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zR=({inputs:n,backend:e,attrs:t})=>{const{x:r,mean:s,variance:a,offset:o,scale:i}=n;I(s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I(o==null||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=t;u==null&&(u=.001);const l=[r,s,a];let c=null;o!=null&&(c=o.shape,l.push(o));let p=null;i!=null&&(p=i.shape,l.push(i));const d=L().getBool("WEBGL_PACK_NORMALIZATION")?new UR(r.shape,s.shape,a.shape,c,p,u):new WR(r.shape,s.shape,a.shape,c,p,u);return e.runWebGLProgram(d,l,l[0].dtype)},GR={kernelName:Uo,backendName:"webgl",kernelFunc:zR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HR{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Ke(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=jR(this.rank);let s;const a=e.map((o,i)=>`sourceLoc.${Xu[i]} = start[${i}] + coords.${Xu[i]};`);s=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}}const Xu=["x","y","z","w","u","v"];function jR(n){if(n===1)return"sourceLoc";if(n<=6)return Xu.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qR{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Ke(this.rank),r=Pt("coords",this.rank),s=Pt("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,o=`getChannel(getSource(${s.join()}), ${a})`,i=`
      result.x = ${o};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${o};
        --${s[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${o};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${o};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,p)=>`start[${p}]`).join()});`:e.map((c,p)=>`${s[p]} = ${r[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KR(n,e,t,r){const s=r.texData.get(n.dataId),a=r.makeTensorInfo(t,n.dtype),o=r.texData.get(a.dataId);Object.assign(o,s),o.refCount=1,o.shape=t,o.dtype=n.dtype;let i=vi(e,Ve(n.shape));s.slice&&(i+=s.slice.flatOffset),o.slice={flatOffset:i,origDataId:s.slice&&s.slice.origDataId||n.dataId};const u=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,u+1),a}function Fs(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:a,size:o}=r,[i,u]=Ll(s,a,o);if(xm(s,i,u),V(u)===0)return t.makeTensorInfo(u,s.dtype,[]);if(t.shouldExecuteOnCPU([s])||s.dtype==="string"){const p=t.texData.get(s.dataId),d=WN(p.values,i,u,s.shape,s.dtype);return t.makeTensorInfo(u,s.dtype,d)}const{isPacked:l}=t.texData.get(s.dataId),c=wi(s.shape,i,u);if(l||!c){const p=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new qR(u):new HR(u),d=[i];return t.runWebGLProgram(p,[s],s.dtype,d)}return t.uploadToGPU(s.dataId),KR(s,i,u,t)}const XR={kernelName:ul,backendName:"webgl",kernelFunc:Fs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YR=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:a,crops:o}=r;I(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const i=a.reduce((x,w)=>x*w),u=Sa(s.shape,a,i),l=$a(u.length,a.length),c=Ia(s.shape,a,i),p=np(o,a.length),d=rp(c,o,a.length),h=[],f=te({inputs:{x:s},backend:t,attrs:{shape:u}}),m=Bt({inputs:{x:f},backend:t,attrs:{perm:l}}),g=te({inputs:{x:m},backend:t,attrs:{shape:c}}),y=Fs({inputs:{x:g},backend:t,attrs:{begin:p,size:d}});return h.push(f),h.push(m),h.push(g),h.forEach(x=>t.disposeIntermediateTensorInfo(x)),y},QR={kernelName:Tc,backendName:"webgl",kernelFunc:YR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZR(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:a}=e,{size:o}=r,i=t.readSync(s.dataId),u=t.readSync(a.dataId),l=Zg(i,u,a.dtype,a.shape,o);return t.makeTensorInfo([o],a.dtype,l)}const JR={kernelName:Hh,backendName:"webgl",kernelFunc:ZR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eA(n){const{inputs:e,backend:t}=n,{s0:r,s1:s}=e,a=t.readSync(r.dataId),o=t.readSync(s.dataId),i=Ne(Array.from(a),Array.from(o));return t.makeTensorInfo([i.length],"int32",Int32Array.from(i))}const tA={kernelName:jh,backendName:"webgl",kernelFunc:eA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nA="return float(a != b);",dy=Ct({opSnippet:nA,cpuKernelImpl:ON,dtype:"bool"}),rA={kernelName:Qc,backendName:"webgl",kernelFunc:dy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ea(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.texData.get(r.dataId);return Qt({inputs:{x:s.complexTensorInfos.real},backend:t})}const sA={kernelName:Sf,backendName:"webgl",kernelFunc:Ea};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aA="return float(int(x));";function oA(n,e){const t=new Kn(n.shape,aA),r=e.runWebGLProgram(t,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yu(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return Qt({inputs:{x:s},backend:t});const o=fr(s.shape),i=Yu({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),u=Sr({inputs:{real:i,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(i),u}if(s.dtype==="complex64"){const o=Ea({inputs:{input:s},backend:t}),i=Yu({inputs:{x:o},backend:t,attrs:{dtype:a}});return t.disposeIntermediateTensorInfo(o),i}if(!Db(s.dtype,a)){const o=Qt({inputs:{x:s},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:a}}if(t.shouldExecuteOnCPU([s])){const o=t.texData.get(s.dataId).values,[i,u,l]=hN(o,s.shape,s.dtype,a);return t.makeTensorInfo(i,u,l)}if(a==="int32")return oA(s,t);if(a==="bool"){const o=t.makeTensorInfo([],"bool",Zn("bool",1)),u=dy({inputs:{a:s,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),u}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}const iA={kernelName:Ao,backendName:"webgl",kernelFunc:Yu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ed="return ceil(x);",uA=Ae({opSnippet:Ed,packedOpSnippet:Ed,cpuKernelImpl:fN}),cA={kernelName:Cc,backendName:"webgl",kernelFunc:uA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lA{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pA{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dA(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{clipValueMin:a,clipValueMax:o}=r;let i;L().getBool("WEBGL_PACK_CLIP")?i=new pA(s.shape):i=new lA(s.shape);const u=[[a],[o]];return t.runWebGLProgram(i,[s],s.dtype,u)}const hA={kernelName:Oo,backendName:"webgl",kernelFunc:dA};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fA{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rd(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function mA(n){const{inputs:e,backend:t}=n,{x:r}=e,s=t.texData.get(r.dataId),a=new fA(r.shape),o=[Rd(r,s.complexTensorInfos.real),Rd(r,s.complexTensorInfos.imag)];return t.runWebGLProgram(a,o,o[0].dtype)}const gA={kernelName:Kh,backendName:"webgl",kernelFunc:mA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yA{constructor(e){this.outputShape=[],this.outputShape=Pn(e,1),this.variableNames=e.map((o,i)=>`T${i}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const r=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const i=t[o-1];r.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${i}));`)}const s=t.length,a=t[t.length-1];r.push(`else setOutput(getT${s}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xA{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Pn(e,t);const r=this.outputShape,s=r.length,a=Ke(s),o=Pt("coords",s),i=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((m,g)=>`T${g}`);const u=new Array(e.length-1);u[0]=e[0][t];for(let m=1;m<u.length;m++)u[m]=u[m-1]+e[m][t];const l=i[t],c=i.slice(-2),p=i.join();let d=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${p}), vec2(${c.join()}));
        }`;for(let m=1;m<u.length;m++){const g=u[m-1];d+=`
        if (${l} < ${u[m]}  && ${l} >= ${u[m-1]}) {
          return getChannel(
            getT${m}(${Ka(i,l,g)}),
            vec2(${Ka(c,l,g)}));
        }`}const h=u.length,f=u[u.length-1];d+=`
        return getChannel(
          getT${h}(${Ka(i,l,f)}),
          vec2(${Ka(c,l,f)}));`,this.userCode=`
      float getValue(${i.map(m=>"int "+m)}) {
        ${d}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[s-1]} = ${o[s-1]} + 1;
        if (${o[s-1]} < ${r[s-1]}) {
          result.g = getValue(${o});
        }

        ${o[s-2]} = ${o[s-2]} + 1;
        if (${o[s-2]} < ${r[s-2]}) {
          result.a = getValue(${o});
        }

        ${o[s-1]} = ${o[s-1]} - 1;
        if (${o[s-2]} < ${r[s-2]} &&
            ${o[s-1]} < ${r[s-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function Ka(n,e,t){const r=n.indexOf(e);return n.map((a,o)=>o===r?`${a} - ${t}`:a).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Li(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.texData.get(r.dataId);return Qt({inputs:{x:s.complexTensorInfos.imag},backend:t})}const bA={kernelName:cf,backendName:"webgl",kernelFunc:Li};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function js(n,e,t){const r=n[0].dtype;if(r==="complex64"){const p=n.map(g=>Ea({inputs:{input:g},backend:t})),d=n.map(g=>Li({inputs:{input:g},backend:t})),h=js(p,e,t),f=js(d,e,t),m=Sr({inputs:{real:h,imag:f},backend:t});return p.forEach(g=>t.disposeIntermediateTensorInfo(g)),d.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),m}let s=t.shouldExecuteOnCPU(n);if(r==="string"&&(s=!0),s){const p=n.map(x=>{const v=[-1,V(x.shape.slice(e))];return te({inputs:{x},backend:t,attrs:{shape:v}})}),d=p.map(x=>({vals:t.readSync(x.dataId),shape:x.shape})),h=Pn(p.map(x=>x.shape),1),f=p[0].shape[0]===1,m=mN(d,h,r,f),g=Pn(n.map(x=>x.shape),e),y=t.makeTensorInfo(g,r,m);return p.forEach(x=>t.disposeIntermediateTensorInfo(x)),y}const a=L().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(n.length>a){const p=[];for(let h=0;h<n.length;h+=a){const f=n.slice(h,h+a);p.push(js(f,e,t))}const d=js(p,e,t);for(const h of p)t.disposeIntermediateTensorInfo(h);return d}if(L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&n[0].shape.length>1){const p=new xA(n.map(d=>d.shape),e);return t.runWebGLProgram(p,n,r)}const{tensors2D:o,outShape:i}=wA(n,e,t),u=new yA(o.map(p=>p.shape)),l=t.runWebGLProgram(u,o,r);o.forEach(p=>t.disposeIntermediateTensorInfo(p));const c=te({inputs:{x:l},attrs:{shape:i},backend:t});return t.disposeIntermediateTensorInfo(l),c}function wA(n,e,t){const r=Pn(n.map(a=>a.shape),e);return{tensors2D:n.map(a=>te({inputs:{x:a},attrs:{shape:[-1,V(a.shape.slice(e))]},backend:t})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hy(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,a=ct(s,e[0].shape)[0],o=e.map(l=>l.shape);Jl(o,a);const i=Pn(e.map(l=>l.shape),a);if(V(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);const u=e.filter(l=>V(l.shape)>0);return u.length===1?Qt({inputs:{x:u[0]},backend:t}):js(u,a,t)}const vA={kernelName:_c,backendName:"webgl",kernelFunc:hy};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fy{constructor(e,t=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,i=e.padInfo.left,u=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,p=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,f=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,g=e.dataFormat==="channelsLast",y=g?1:2,x=g?2:3,w=g?3:1;let v="",$="";r&&(s?v=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?v=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:v=`
          float activation(float x) {
            ${r}
          }
        `,$="result = activation(result);");const C=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${v}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${o}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${x}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${h}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${C}
        ${$}
        setOutput(result);
      }
    `}}class SA{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,r=e.padInfo.top,s=e.padInfo.left,a=e.strideDepth,o=e.strideHeight,i=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,p=e.filterDepth,d=e.filterHeight,h=e.filterWidth,f=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${o}, ${i});
      const ivec3 pads = ivec3(${t}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class my{constructor(e,t=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Wt(this.outputShape.length);const o=e.padInfo.left,i=e.strideWidth,u=e.dilationWidth,l=e.filterHeight,c=e.filterWidth,p=c;let d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<c;g++)d+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;d+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let g=0;g<c;g++)d+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(p+1)/2;g++){const y=g*2;if(d+=`
           xC = xCCorner + ${y*u};
           `,i===1){if(y<c&&(o%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,u===1&&y>0?d+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<c)){const x=o%2===0?vc(u):u;u%2===0&&o%2===1||u%2!==0&&o%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${x};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,u>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:d+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):x===1?d+=`
                     xC${y+1} = xTexelC${y};
                     `:d+=`
                     xCOffset = xC + ${x};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<c&&(o%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<c&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<c&&(d+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<c&&(d+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<c&&(d+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let h="",f="";r&&(s?h=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:a?h=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:h=`vec4 activation(vec4 x) {
           ${r}
         }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${h}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${f}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $A{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Wt(this.outputShape.length);const{dataFormat:r}=t,s=Vt(),a=r==="channelsLast",o=a?1:2,i=a?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let c=0;c<=1;c++)for(let p=0;p<=1;p++)l+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${c};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function go(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function gy({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:i=null}){const u=n.shape,l=r.texData.get(n.dataId),c=t.inChannels,p=u[0]*u[1]*u[2],d=t.outChannels,h=t.dataFormat==="channelsLast",f=!1,m=!1;let g;const y=[];if(a!=null){const v=go(a.shape,h);v!=null&&(a=te({inputs:{x:a},backend:r,attrs:{shape:v}}),y.push(a))}if(s!=null){const v=go(s.shape,h);v!=null&&(s=te({inputs:{x:s},backend:r,attrs:{shape:v}}),y.push(s))}if(!((p===1||d===1)&&c>uy)&&l.isPacked&&h&&l.texture!=null&&u[2]%2!==0&&pt(l.shape.slice(-3),u.slice(-3))){const v=u[0]*u[1]*(u[2]+1),$={dataId:n.dataId,shape:[1,v,t.inChannels],dtype:n.dtype},C=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,I(ho(l.shape,$.shape),()=>`packed reshape ${l.shape} to ${$.shape} isn't free`);const k=te({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});y.push(k);const R=mo({a:$,b:k,backend:r,transposeA:f,transposeB:m,bias:s,activation:i,preluActivationWeights:a,leakyreluAlpha:o}),F=r.texData.get(R.dataId);I(F.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=C,F.shape=t.outShape,g=Qt({inputs:{x:R},backend:r}),g.shape=t.outShape,y.push(R)}else{const v=t.outHeight*t.outWidth,$=te({inputs:{x:n},backend:r,attrs:{shape:h?[t.batchSize,v,t.inChannels]:[t.batchSize,t.inChannels,v]}}),C=te({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}}),k=mo({a:h?$:C,b:h?C:$,transposeA:!h,transposeB:m,backend:r,bias:s,activation:i,preluActivationWeights:a,leakyreluAlpha:o});g=te({inputs:{x:k},backend:r,attrs:{shape:t.outShape}}),y.push($),y.push(C),y.push(k)}for(const v of y)r.disposeIntermediateTensorInfo(v);return g}function yy({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:i=null}){const{filterWidth:u,filterHeight:l,inChannels:c,outWidth:p,outHeight:d,dataFormat:h}=t,f=h==="channelsLast",m=u*l*c,g=d*p,y=[t.batchSize,m,g],x=!0,w=!1,v=[];if(a!=null){const le=go(a.shape,f);le!=null&&(a=te({inputs:{x:a},backend:r,attrs:{shape:le}}),v.push(a))}if(s!=null){const le=go(s.shape,f);le!=null&&(s=te({inputs:{x:s},backend:r,attrs:{shape:le}}),v.push(s))}const $=te({inputs:{x:e},backend:r,attrs:{shape:[1,m,V(e.shape)/m]}});v.push($);const C=new $A(y,t),k=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],R=r.runWebGLProgram(C,[n],"float32",k),F=te({inputs:{x:R},backend:r,attrs:{shape:y}});v.push(R),v.push(F);const D=s!=null,M=a!=null,U=i==="leakyrelu",j=i?la(i,!0):null,Y=new iy(f?F.shape:$.shape,f?$.shape:F.shape,f?[t.batchSize,g,t.outChannels]:[t.batchSize,t.outChannels,g],x,w,D,j,M,U),Q=f?[F,$]:[$,F];if(s&&Q.push(s),M&&Q.push(a),U){const le=r.makeTensorInfo([],"float32",Cs(o,"float32"));Q.push(le),v.push(le)}const ae=r.runWebGLProgram(Y,Q,"float32"),me=te({inputs:{x:ae},backend:r,attrs:{shape:t.outShape}});v.push(ae);for(const le of v)r.disposeIntermediateTensorInfo(le);return me}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IA(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:a}=e,{strides:o,pad:i,dataFormat:u,dilations:l,dimRoundingMode:c}=r,p=wr(u),d=It(s.shape,a.shape,o,l,i,c,!1,p);let h;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))h=gy({x:s,filter:a,convInfo:d,backend:t});else if(d.strideWidth<=2&&p==="channelsLast"&&L().getBool("WEBGL_EXP_CONV")){const m=new my(d),g=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];h=t.runWebGLProgram(m,[s,a],"float32",g)}else if(L().getBool("WEBGL_CONV_IM2COL"))h=yy({x:s,filter:a,convInfo:d,backend:t});else{const m=new fy(d);h=t.runWebGLProgram(m,[s,a],"float32")}const f=te({inputs:{x:h},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(h),f}const TA={kernelName:Fo,backendName:"webgl",kernelFunc:IA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CA{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,a=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${o}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class _A{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,a=e.strideWidth,o=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,u=r-1-e.padInfo.left,l=o?1:2,c=o?2:3,p=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class kA{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,a=e.padInfo.front,o=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${a};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class NA{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,a=e.strideDepth,o=e.strideHeight,i=e.strideWidth,u=t-1-e.padInfo.front,l=r-1-e.padInfo.top,c=s-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EA(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:a}=e,{strides:o,pad:i,dataFormat:u,dimRoundingMode:l,filterShape:c}=r,p=wr(u),d=It(s.shape,c,o,1,i,l,!1,p),h=new CA(d);return t.runWebGLProgram(h,[s,a],"float32")}const RA={kernelName:Xh,backendName:"webgl",kernelFunc:EA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AA(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:a}=e,{inputShape:o,strides:i,pad:u,dataFormat:l,dimRoundingMode:c}=r,p=wr(l),d=It(o,a.shape,i,1,u,c,!1,p),h=new _A(d);return t.runWebGLProgram(h,[s,a],"float32")}const OA={kernelName:Do,backendName:"webgl",kernelFunc:AA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FA(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:a}=e,{strides:o,pad:i,dilations:u}=r,l=ba(s.shape,a.shape,o,u,i),c=new SA(l);return t.runWebGLProgram(c,[s,a],"float32")}const DA={kernelName:Yh,backendName:"webgl",kernelFunc:FA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PA(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:a}=e,{strides:o,pad:i,filterShape:u}=r,l=ba(s.shape,u,o,1,i),c=new kA(l);return t.runWebGLProgram(c,[s,a],"float32")}const LA={kernelName:qb,backendName:"webgl",kernelFunc:PA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MA(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:a}=e,{pad:o,strides:i,inputShape:u}=r,l=ba(u,a.shape,i,1,o),c=new NA(l);return t.runWebGLProgram(c,[s,a],"float32")}const BA={kernelName:Qh,backendName:"webgl",kernelFunc:MA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VA=Os+`
  return cos(x);
`,WA=Ae({opSnippet:VA}),UA={kernelName:kc,backendName:"webgl",kernelFunc:WA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zA=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,GA=Ae({opSnippet:zA}),HA={kernelName:Nc,backendName:"webgl",kernelFunc:GA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jA{constructor(e,t,r,s,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,i,u,l]=e,[c]=t,[p,d]=r;this.outputShape=[c,p,d,l];const h=s==="bilinear"?1:0,[f,m]=[`${i-1}.0`,`${u-1}.0`],[g,y,x]=p>1?[`${(i-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[w,v,$]=d>1?[`${(u-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${v};

        float in_y = ${x};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${$};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${h} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qA=n=>{const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:a,boxInd:o}=e,{cropSize:i,method:u,extrapolationValue:l}=r,c=new jA(s.shape,a.shape,i,u,l);return t.runWebGLProgram(c,[s,a,o],"float32")},KA={kernelName:Mo,backendName:"webgl",kernelFunc:qA};var da;(function(n){n.Prod="*",n.Sum="+"})(da||(da={}));class Ad{constructor(e,t,r,s){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,o=this.op===da.Prod?"1.0":"0.0",i=r?o:`getX(${Od(a,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let l="",c="";r?(l=s?`end != ${u-1}`:"end != 0",c=s?"end + 1":"end - 1"):(l=s?`end + pow2 < ${u}`:"end >= pow2",c=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Ke(a)} coords = getOutputCoords();
        int end = ${Fd(a,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${c};
          ${Fd(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${Od(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function Od(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function Fd(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xy(n,e,t,r,s,a){const o=e.shape.length,i=Ht([r],o);let u=e;i!=null&&(u=Bt({inputs:{x:e},backend:t,attrs:{perm:i}}));const l=Tt(1,o)[0];if(l!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const c=u.shape[l];let p=Qt({inputs:{x:u},backend:t});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){const h=new Ad(n,u.shape,!1,a),f=[[d]],m=p;p=t.runWebGLProgram(h,[p],p.dtype,f),t.disposeIntermediateTensorInfo(m)}if(s){const d=new Ad(n,u.shape,s,a),h=p;p=t.runWebGLProgram(d,[p],p.dtype),t.disposeIntermediateTensorInfo(h)}if(i!=null){const d=wa(i),h=Bt({inputs:{x:p},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(u),h}return p}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XA(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:a,exclusive:o,reverse:i}=r;return xy(da.Prod,s,t,a,o,i)}const YA={kernelName:Po,backendName:"webgl",kernelFunc:XA};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QA(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:a,exclusive:o,reverse:i}=r;return xy(da.Sum,s,t,a,o,i)}const ZA={kernelName:Lo,backendName:"webgl",kernelFunc:QA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JA(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:a}=e,{size:o,binaryOutput:i}=r;if(s.shape.length===1){const u=t.readSync(s.dataId),l=t.readSync(a.dataId),c=Zg(u,l,a.dtype,a.shape,o);return t.makeTensorInfo([o],a.dtype,c)}else if(s.shape.length===2){const u=t.bufferSync(s),l=t.bufferSync(a),c=dN(u,l,o,i);return t.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const eO={kernelName:Zh,backendName:"webgl",kernelFunc:JA};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tO{constructor(e,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nO(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:a,dataFormat:o}=r,i=s.shape[0],u=o==="NHWC"?s.shape[1]:s.shape[2],l=o==="NHWC"?s.shape[2]:s.shape[3],c=o==="NHWC"?s.shape[3]:s.shape[1],p=u*a,d=l*a,h=c/(a*a),f=o==="NHWC"?[i,p,d,h]:[i,h,p,d],m=new tO(f,a,o);return t.runWebGLProgram(m,[s],s.dtype)}const rO={kernelName:Bo,backendName:"webgl",kernelFunc:nO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class by{constructor(e,t=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Wt(this.outputShape.length);const o=e.filterHeight,i=e.filterWidth,u=e.outChannels/e.inChannels;let l="",c="";r&&(s?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:l=`
          float activation(float x) {
            ${r}
          }
        `,c="result = activation(result);");const p=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${c}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wy{constructor(e,t=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Wt(this.outputShape.length);const o=e.outChannels/e.inChannels,i=e.padInfo.left,u=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,p=e.filterWidth,d=p;let h=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<p;y++)h+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;h+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let y=0;y<p;y++)h+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;h+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(d+1)/2;y++){const x=y*2;if(h+=`
          xC = xCCorner + ${x*l};
          `,u===1){if(x<p&&(i%2===1?(h+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }
              `,l===1&&x>0?h+=`
                xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                `:h+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                  } else {
                    xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                  }
                  `):h+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xC${x} = xTexelC${x};
                `,x+1<p)){const w=i%2===0?vc(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(h+=`
                  xCOffset = xC + imod(pads[1], 2) + ${w};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                    xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${x+1}.zw = vec2(0.0);
                    }
                    xTexelC${x+1}Ready = 1;
                  }
                  `,l>1?h+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                    } else {
                     xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                    }
                    `:h+=`
                    xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                    `):w===1?h+=`
                    xC${x+1} = xTexelC${x};
                    `:h+=`
                    xCOffset = xC + ${w};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                      xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${x+1}.zw = vec2(0.0);
                      }
                      xTexelC${x+1}Ready = 1;
                    }

                    xC${x+1} = xTexelC${x+1};
                    `}}else x<p&&(i%2===1?(h+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.0);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
              `,x+1<p&&(h+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                `)):(h+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(
                  xTexelC${x}.xy, xTexelC${x+1}.xy);
              `,x+1<p&&(h+=`
                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                `)));x<p&&(h+=`
            wTexel = getW(r, ${x}, d1, q);
            dotProd += xC${x} * vec4(wTexel.xz, wTexel.xz);
          `,x+1<p&&(h+=`
              wTexel = getW(r, ${x+1}, d1, q);
              dotProd += xC${x+1} * vec4(wTexel.xz, wTexel.xz);
            `))}h+=`
    }
  `,h+=`
      }
    `;let f="",m="";r&&(s?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:f=`vec4 activation(vec4 x) {
          ${r}
        }`,m="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${h}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sO(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:a}=e,{strides:o,pad:i,dilations:u,dimRoundingMode:l}=r;let c=u;c==null&&(c=[1,1]),I(en(o,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const p=It(s.shape,a.shape,o,c,i,l,!0);let d;L().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?d=new wy(p):d=new by(p);const h=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return t.runWebGLProgram(d,[s,a],"float32",h)}const aO={kernelName:Vo,backendName:"webgl",kernelFunc:sO};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oO{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,a=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class iO{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,a=e.strideWidth,o=t-1-e.padInfo.top,i=r-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uO(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:a}=e,{strides:o,dilations:i,pad:u,dimRoundingMode:l,filterShape:c}=r,p=It(s.shape,c,o,i,u,l,!0),d=new oO(p);return t.runWebGLProgram(d,[s,a],"float32")}const cO={kernelName:Jh,backendName:"webgl",kernelFunc:uO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lO(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:a}=e,{strides:o,dilations:i,pad:u,dimRoundingMode:l,inputShape:c}=r,p=It(c,a.shape,o,i,u,l,!0),d=new iO(p);return t.runWebGLProgram(d,[s,a],"float32")}const pO={kernelName:ef,backendName:"webgl",kernelFunc:lO};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dO{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hO(n){const{inputs:e,backend:t}=n,{x:r}=e,s=[...r.shape,...r.shape],a=V(r.shape),o=te({inputs:{x:r},backend:t,attrs:{shape:[a]}}),i=new dO(a),u=t.runWebGLProgram(i,[o],o.dtype),l=te({inputs:{x:u},backend:t,attrs:{shape:s}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(u),l}const fO={kernelName:tf,backendName:"webgl",kernelFunc:hO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mO{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:r,padInfo:s,strideHeight:a,strideWidth:o,filterHeight:i,filterWidth:u,dilationHeight:l,dilationWidth:c}=e,{top:p,left:d}=s;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${o});
      const ivec2 pads = ivec2(${p}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gO(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:a}=e,{strides:o,pad:i,dilations:u}=r,l=Nm(s.shape,a.shape,o,i,"NHWC",u);let c;const p=new mO(l);c=t.runWebGLProgram(p,[s,a],"float32");const d=te({inputs:{x:c},backend:t,attrs:{shape:l.outShape}});return t.disposeIntermediateTensorInfo(c),d}const yO={kernelName:nf,backendName:"webgl",kernelFunc:gO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xO(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,a=e,{allDims:o,summedDims:i,idDims:u}=_g(s,a.length);Ng(o.length,u,a);const{path:l,steps:c}=Eg(i,u),p=c.length;let d=null,h=o.length;const f=[];for(let m=0;m<p;++m){for(const g of c[m]){const{permutationIndices:y,expandDims:x}=kg(h,u[g]);let w;Rg(y)?w=a[g]:(w=Bt({inputs:{x:a[g]},backend:t,attrs:{perm:y}}),f.push(w));const v=w.shape.slice();for(let $=0;$<x.length;++$)v.splice(x[$],0,1);pt(w.shape,v)||(w=te({inputs:{x:w},backend:t,attrs:{shape:v}}),f.push(w)),d===null?d=w:(d=Ip({inputs:{a:w,b:d},backend:t}),f.push(d))}m<p-1&&(l[m]>=0&&(d=Pi({inputs:{x:d},backend:t,attrs:{axis:l[m]-(o.length-h),keepDims:!1}}),f.push(d)),h--)}for(const m of f)m!==d&&t.disposeIntermediateTensorInfo(m);return d}const bO={kernelName:rf,backendName:"webgl",kernelFunc:xO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wO="return (x >= 0.0) ? x : (exp(x) - 1.0);",vO=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,SO=Ae({opSnippet:wO,packedOpSnippet:vO}),$O={kernelName:Rc,backendName:"webgl",kernelFunc:SO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IO="return (b >= 1.0) ? a : a * (b + 1.0);",TO=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,CO=n=>{const{inputs:e,backend:t}=n,{dy:r,y:s}=e,a=L().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Na(TO,r.shape,s.shape):new Is(IO,r.shape,s.shape);return t.runWebGLProgram(a,[r,s],r.dtype)},_O={kernelName:Kb,backendName:"webgl",kernelFunc:CO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kO=`
  return vec4(equal(a, b));
`,NO="return float(a == b);",EO=Ct({opSnippet:NO,packedOpSnippet:kO,dtype:"bool",cpuKernelImpl:gN}),RO={kernelName:Ac,backendName:"webgl",kernelFunc:EO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AO=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${vg};
  float a1 = ${Sg};
  float a2 = ${$g};
  float a3 = ${Ig};
  float a4 = ${Tg};
  float a5 = ${Cg};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,OO=Ae({opSnippet:AO}),FO={kernelName:sf,backendName:"webgl",kernelFunc:OO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DO=Os+`
  return exp(x);
`,PO=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,vy=Ae({opSnippet:DO,packedOpSnippet:PO,cpuKernelImpl:yN,dtype:"float32"}),LO={kernelName:Oc,backendName:"webgl",kernelFunc:vy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qu(n){const{inputs:e,attrs:t,backend:r}=n,{dim:s}=t,{input:a}=e,o=a.shape.length,i=a.shape.slice();let u=s;return s<0&&(I(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+s+1),i.splice(u,0,1),te({inputs:{x:a},backend:r,attrs:{shape:i}})}const MO={kernelName:Fc,backendName:"webgl",kernelFunc:Qu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dd="return exp(x) - 1.0;",BO=Ae({opSnippet:Dd,packedOpSnippet:Dd,cpuKernelImpl:xN}),VO={kernelName:af,backendName:"webgl",kernelFunc:BO};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pd{constructor(e,t,r){this.variableNames=["real","imag"];const s=t[1];this.outputShape=t;const a=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=r?`${s}.0`:"1.0";let i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sy(n,e,t){const r=t.texData.get(n.dataId),s=V(n.shape),a=n.shape[n.shape.length-1],o=s/a,i=te({inputs:{x:n},backend:t,attrs:{shape:[o,a]}}),u=i.shape,l=new Pd("real",u,e),c=new Pd("imag",u,e),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],d=t.runWebGLProgram(l,p,"float32"),h=t.runWebGLProgram(c,p,"float32"),f=Sr({inputs:{real:d,imag:h},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h);const m=te({inputs:{x:f},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(f),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WO(n){const{inputs:e,backend:t}=n,{input:r}=e;return Sy(r,!1,t)}const UO={kernelName:of,backendName:"webgl",kernelFunc:WO};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zO{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ra(n){const{backend:e,attrs:t}=n,{shape:r,value:s}=t;let{dtype:a}=t;if(a=a||Io(s),a==="string"){const o=zt(a,V(r));return o.fill(s),e.makeTensorInfo(r,a,o)}else{const o=new zO(r,s),i=[[s]];return e.runWebGLProgram(o,[],a,i)}}const GO={kernelName:Dc,backendName:"webgl",kernelFunc:Ra};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HO{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jO={kernelName:Wo,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,r=e,s=new HO(t.shape);return r.runWebGLProgram(s,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ld="return floor(x);",qO=Ae({opSnippet:Ld,packedOpSnippet:Ld,cpuKernelImpl:bN}),KO={kernelName:Pc,backendName:"webgl",kernelFunc:qO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XO=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,YO=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,QO=Ct({opSnippet:XO,packedOpSnippet:YO,dtype:"int32"}),ZO={kernelName:Lc,backendName:"webgl",kernelFunc:QO};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JO{constructor(e){this.variableNames=["A"];const t=Vt(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eF{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Vt(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tF={kernelName:xu,backendName:"webgl",kernelFunc:nF};let as,ru=L().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function nF(n){const{inputs:e,backend:t,attrs:r}=n;let{pixels:s}=e;const{numChannels:a}=r,o=typeof HTMLVideoElement!="undefined"&&s instanceof HTMLVideoElement,i=typeof HTMLImageElement!="undefined"&&s instanceof HTMLImageElement,[u,l]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[l,u],p=[l,u,a];if(i||o){const m=L().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(as==null||m!==ru)&&(ru=m,as=document.createElement("canvas").getContext("2d",{willReadFrequently:ru})),as.canvas.width=u,as.canvas.height=l,as.drawImage(s,0,0,u,l),s=as.canvas}const d=t.makeTensorInfo(c,"int32");t.texData.get(d.dataId).usage=cn.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId),s);const h=L().getBool("WEBGL_PACK")?new eF(p):new JO(p),f=t.runWebGLProgram(h,[d],"int32");return t.disposeData(d.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rF(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:a,bias:o,preluActivationWeights:i}=e,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r,m=wr(c),g=It(s.shape,a.shape,u,p,l,d,!1,m);let y;const x=[],w=o!=null,v=i!=null,$=h==="leakyrelu",C=()=>{const R=[s,a],F=(D,M)=>{if(M==="NCHW"&&D.shape.length===1&&D.shape[0]!==1){const U=te({inputs:{x:D},backend:t,attrs:{shape:[D.shape[0],1,1]}});return x.push(U),U}return D};if(w&&R.push(F(o,c)),v&&R.push(F(i,c)),$){const D=t.makeTensorInfo([],"float32",Cs(f,"float32"));R.push(D),x.push(D)}return R};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=gy({x:s,filter:a,convInfo:g,backend:t,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:f});else if(g.strideWidth<=2&&m==="channelsLast"&&L().getBool("WEBGL_EXP_CONV")){const R=h?la(h,!0):null,F=new my(g,w,R,v,$),D=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],M=C();y=t.runWebGLProgram(F,M,"float32",D)}else if(L().getBool("WEBGL_CONV_IM2COL"))y=yy({x:s,filter:a,convInfo:g,backend:t,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:f});else{const R=h?la(h,!1):null,F=new fy(g,w,R,v,$),D=C();y=t.runWebGLProgram(F,D,"float32")}const k=te({inputs:{x:y},backend:t,attrs:{shape:g.outShape}});return x.push(y),x.forEach(R=>t.disposeIntermediateTensorInfo(R)),k}const sF={kernelName:Js,backendName:"webgl",kernelFunc:rF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aF(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:a,bias:o,preluActivationWeights:i}=e,{strides:u,pad:l,dilations:c,dimRoundingMode:p,activation:d,leakyreluAlpha:h}=r,f=[];let m=c;m==null&&(m=[1,1]),I(en(u,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`);const g=It(s.shape,a.shape,u,m,l,p,!0),y=L().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,x=d?la(d,y):null,w=[s,a],v=o!=null,$=i!=null,C=d==="leakyrelu";if(v&&w.push(o),$&&w.push(i),C){const D=t.makeTensorInfo([],"float32",Cs(h,"float32"));w.push(D),f.push(D)}let k;y?k=new wy(g,v,x,$,C):k=new by(g,v,x,$,C);const R=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],F=t.runWebGLProgram(k,w,"float32",R);return f.forEach(D=>t.disposeIntermediateTensorInfo(D)),F}const oF={kernelName:ea,backendName:"webgl",kernelFunc:aF};class iF{constructor(e,t,r,s){this.sliceDim=e,this.strides=t,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const a=Ke(r.length);let o=`
    int index;`;for(let i=0;i<this.sliceDim;i++)o+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uF(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,a=s.shape,o=a[a.length-1],i=V(r.shape),[u,l,c,p]=Dl(r,s),d=te({inputs:{x:s},backend:t,attrs:{shape:[l,o]}}),h=te({inputs:{x:r},backend:t,attrs:{shape:[V(r.shape)/c,c]}});if(t.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const y=t.readSync(s.dataId),x=t.bufferSync(r),w=wN(y,x,r.dtype,l,o,c,p,r.shape,i);return t.makeTensorInfo(u,r.dtype,w.values)}const f=new iF(o,p,[l,c],r.shape),m=t.runWebGLProgram(f,[h,d],h.dtype),g=te({inputs:{x:m},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(m),g}const cF={kernelName:zo,backendName:"webgl",kernelFunc:uF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lF{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const r=Ke(this.rank),s=pF(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}}function pF(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n.length;s++)s===2?r.push("index"):r.push(`${t[s]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $y(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:a}=e,{axis:o,batchDims:i}=r,u=ct(o,s.shape)[0];if(L().get("DEBUG")){const x=t.readSync(a.dataId),w=s.shape[u];for(let v=0;v<x.length;++v){const $=x[v];I($<=w-1&&$>=0,()=>`GatherV2: the index value ${$} is not in [0, ${w-1}]`)}}const l=gp(s,a,u,i),c=V(a.shape),p=[],d=te({inputs:{x:s},backend:t,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),h=te({inputs:{x:a},backend:t,attrs:{shape:[l.batchSize,c/l.batchSize]}});p.push(d),p.push(h);const f=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(t.shouldExecuteOnCPU([s,a])||s.dtype==="string"){const x=t.bufferSync(h),w=t.bufferSync(d),v=vN(w,x,f);return p.forEach($=>t.disposeIntermediateTensorInfo($)),t.makeTensorInfo(l.outputShape,v.dtype,v.values)}const m=new lF(d.shape,f),g=t.runWebGLProgram(m,[d,h],d.dtype);p.push(g);const y=te({inputs:{x:g},backend:t,attrs:{shape:l.outputShape}});return p.forEach(x=>t.disposeIntermediateTensorInfo(x)),y}const dF={kernelName:Mc,backendName:"webgl",kernelFunc:$y};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hF="return float(a > b);",fF=`
  return vec4(greaterThan(a, b));
`,mF=Ct({opSnippet:hF,packedOpSnippet:fF,cpuKernelImpl:SN,dtype:"bool"}),gF={kernelName:Bc,backendName:"webgl",kernelFunc:mF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yF="return float(a >= b);",xF=`
  return vec4(greaterThanEqual(a, b));
`,bF=Ct({opSnippet:yF,packedOpSnippet:xF,dtype:"bool",cpuKernelImpl:$N}),wF={kernelName:Vc,backendName:"webgl",kernelFunc:bF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vF(n){const{inputs:e,backend:t}=n,{input:r}=e;return Sy(r,!0,t)}const SF={kernelName:uf,backendName:"webgl",kernelFunc:vF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $F="return float(!isnan(x) && !isinf(x));",IF=Ae({opSnippet:$F,dtype:"bool"}),TF={kernelName:lf,backendName:"webgl",kernelFunc:IF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CF="return float(isinf(x));",_F=Ae({opSnippet:CF,dtype:"bool"}),kF={kernelName:pf,backendName:"webgl",kernelFunc:_F};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NF="return float(isnan(x));",EF=Ae({opSnippet:NF,dtype:"bool"}),RF={kernelName:df,backendName:"webgl",kernelFunc:EF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AF="return float(a < b);",OF=`
  return vec4(lessThan(a, b));
`,FF=Ct({opSnippet:AF,packedOpSnippet:OF,cpuKernelImpl:IN,dtype:"bool"}),DF={kernelName:Wc,backendName:"webgl",kernelFunc:FF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PF="return float(a <= b);",LF=`
  return vec4(lessThanEqual(a, b));
`,MF=Ct({opSnippet:PF,packedOpSnippet:LF,cpuKernelImpl:TN,dtype:"bool"}),BF={kernelName:Uc,backendName:"webgl",kernelFunc:MF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VF(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:a}=t,o=CN(r,s,a);return e.makeTensorInfo([o.length],"float32",o)}const WF={kernelName:hf,backendName:"webgl",kernelFunc:VF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UF=Os+`
  return x < 0.0 ? 0./0. : log(x);
`,zF=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,GF=Ae({opSnippet:UF,packedOpSnippet:zF,cpuKernelImpl:_N}),HF={kernelName:zc,backendName:"webgl",kernelFunc:GF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jF=Os+`
  return log(1.0 + x);
`,qF=Ae({opSnippet:jF}),KF={kernelName:ff,backendName:"webgl",kernelFunc:qF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XF="return float(a >= 1.0 && b >= 1.0);",YF=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,QF=Ct({opSnippet:XF,packedOpSnippet:YF,dtype:"bool"}),ZF={kernelName:Gc,backendName:"webgl",kernelFunc:QF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JF="return float(!(x >= 1.0));",eD=Ae({opSnippet:JF}),tD={kernelName:Hc,backendName:"webgl",kernelFunc:eD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nD="return float(a >= 1.0 || b >= 1.0);",rD=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,sD=Ct({opSnippet:nD,packedOpSnippet:rD,dtype:"bool"}),aD={kernelName:jc,backendName:"webgl",kernelFunc:sD};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oD{constructor(e,t,r,s,a){this.variableNames=["x"],this.outputShape=[];const o=t,i=e[3]-1;this.outputShape=e;let u;const l=`float(${r}) + float(${s}) * sum`;a===.5?u=`inversesqrt(${l})`:a===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iD{constructor(e,t,r,s,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,i=e[3]-1;this.outputShape=e;let u;const l=`float(${r}) + float(${s}) * sum`;a===.5?u=`inversesqrt(${l})`:a===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uD=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:a,bias:o,alpha:i,beta:u}=r,l=L().getBool("WEBGL_PACK_NORMALIZATION")?new iD(s.shape,a,o,i,u):new oD(s.shape,a,o,i,u);return t.runWebGLProgram(l,[s],s.dtype)},cD={kernelName:mf,backendName:"webgl",kernelFunc:uD};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lD{constructor(e,t,r,s,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=r,this.alpha=s,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${a})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pD=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s,y:a,dy:o}=e,{depthRadius:i,bias:u,alpha:l,beta:c}=r,p=new lD(s.shape,i,u,l,c);return t.runWebGLProgram(p,[s,a,o],s.dtype)},dD={kernelName:Yb,backendName:"webgl",kernelFunc:pD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hD(n,e,t,r){const s=V(e),o=V(n.shape)/s,i=te({inputs:{x:n},attrs:{shape:[o,s]},backend:r}),u=Jr(i,n.dtype,"max",r),l=te({inputs:{x:u},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(u),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iy(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:a,keepDims:o}=r,i=s.shape.length,u=ct(a,s.shape);let l=u;const c=Ht(l,i),p=c!=null,d=t.shouldExecuteOnCPU([s]);let h=s;if(p){if(d){const w=t.texData.get(h.dataId).values,v=new Array(i);for(let k=0;k<v.length;k++)v[k]=s.shape[c[k]];const $=Sp(w,s.shape,s.dtype,c,v);h=t.makeTensorInfo(v,s.dtype);const C=t.texData.get(h.dataId);C.values=$}else h=Di(s,c,t);l=Tt(l.length,i)}gt("max",l,i);const[f,m]=kt(h.shape,l);let g=f;o&&(g=mt(f,u));let y;if(d){const w=t.texData.get(h.dataId).values,v=kN(w,V(m),g,s.dtype);y=t.makeTensorInfo(g,s.dtype);const $=t.texData.get(y.dataId);$.values=v}else y=hD(h,m,g,t);return p&&t.disposeIntermediateTensorInfo(h),y}const fD={kernelName:jo,backendName:"webgl",kernelFunc:Iy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mD=$p+`
  return max(a, b);
`,gD=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+ka+`
  return result;
`,yD=Ct({opSnippet:mD,packedOpSnippet:gD,cpuKernelImpl:NN}),xD={kernelName:qc,backendName:"webgl",kernelFunc:yD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bD(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;Ca(s,"maxPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:u}=r,l=1;I(en(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const c=nr(s.shape,a,o,l,i,u);if(c.filterWidth===1&&c.filterHeight===1&&pt(c.inShape,c.outShape))return Qt({inputs:{x:s},backend:t});const p=new pa(c,"max",!1);return t.runWebGLProgram(p,[s],s.dtype)}const wD={kernelName:qo,backendName:"webgl",kernelFunc:bD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vD(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:a,strides:o,pad:i,dataFormat:u,dimRoundingMode:l}=r,c=[1,1,1],p=xa(s.shape,a,o,c,i,l,u),d=new Tp(p,"max",!1);return t.runWebGLProgram(d,[s],s.dtype)}const SD={kernelName:gf,backendName:"webgl",kernelFunc:vD};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $D{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,a=e.effectiveFilterHeight,o=e.effectiveFilterWidth,i=a-1-e.padInfo.top,u=o-1-e.padInfo.left,l=a*o-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class ID{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,i=e.dilationWidth,u=e.effectiveFilterDepth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,p=u-1-e.padInfo.front,d=l-1-e.padInfo.top,h=c-1-e.padInfo.left,f=u*l*c-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${d}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TD(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:a}=e,o=a,{filterSize:i,strides:u,pad:l,dimRoundingMode:c}=r,p=[1,1,1],d=xa(o.shape,i,u,p,l,c),h=new Tp(d,"max",!0),f=t.runWebGLProgram(h,[o],o.dtype),m=new ID(d),g=t.runWebGLProgram(m,[s,f],o.dtype);return t.disposeIntermediateTensorInfo(f),g}const CD={kernelName:Zb,backendName:"webgl",kernelFunc:TD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _D(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:a,output:o}=e,i=a;Ca([a,o],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:p}=r,d=nr(i.shape,u,l,1,c,p),h=!0,f=new pa(d,"max",h),m=t.runWebGLProgram(f,[i],i.dtype),g=new $D(d),y=t.runWebGLProgram(g,[s,m],i.dtype);return t.disposeIntermediateTensorInfo(m),y}const kD={kernelName:Qb,backendName:"webgl",kernelFunc:_D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ND(n,e,t,r){let s=new pa(t,"max",!1);const a=r.runWebGLProgram(s,[n],"float32");s=new pa(t,"max",!0,!0,e);const o=r.runWebGLProgram(s,[n],"float32");return[a,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ED={kernelName:yf,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:s,strides:a,pad:o,includeBatchInIndex:i}=e,u=t;I(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const l=[1,1];I(en(a,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);const c=nr(r.shape,s,a,l,o),[p,d]=ND(r,i,c,u);return[p,d]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RD(n,e,t,r){const s=V(e),o=V(n.shape)/s,i=te({inputs:{x:n},attrs:{shape:[o,s]},backend:r}),u=Jr(i,"float32","mean",r),l=te({inputs:{x:u},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(u),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AD={kernelName:Ko,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{keepDims:s,axis:a}=e,o=t,i=r.shape.length,u=ct(a,r.shape);let l=u;const c=Ht(l,i),p=c!=null,d=o.shouldExecuteOnCPU([r]),h=[];let f=r;if(p){if(d){const v=o.texData.get(f.dataId).values,$=new Array(i);for(let R=0;R<$.length;R++)$[R]=r.shape[c[R]];const C=Sp(v,r.shape,r.dtype,c,$);f=o.makeTensorInfo($,r.dtype);const k=o.texData.get(f.dataId);k.values=C}else f=Di(r,c,o);h.push(f),l=Tt(l.length,i)}gt("sum",l,i);const[m,g]=kt(f.shape,l);let y=m;s&&(y=mt(m,u));const x=RD(f,g,y,o);for(const w of h)o.disposeIntermediateTensorInfo(w);return x}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OD(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:a,keepDims:o}=r,i=s.shape.length,u=ct(a,s.shape);let l=u;const c=Ht(l,i);let p=s;c!=null&&(p=Bt({inputs:{x:s},backend:t,attrs:{perm:c}}),l=Tt(l.length,s.shape.length)),gt("min",l,i);const[d,h]=kt(p.shape,l),f=V(h),m=te({inputs:{x:p},backend:t,attrs:{shape:[-1,f]}}),g=Jr(m,m.dtype,"min",t);let y;if(o){const x=mt(d,u);y=te({inputs:{x:g},backend:t,attrs:{shape:x}})}else y=te({inputs:{x:g},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(p),y}const FD={kernelName:Xo,backendName:"webgl",kernelFunc:OD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DD=$p+`
  return min(a, b);
`,PD=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+ka+`
  return result;
`,LD=Ct({opSnippet:DD,packedOpSnippet:PD,cpuKernelImpl:EN}),MD={kernelName:Kc,backendName:"webgl",kernelFunc:LD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BD{constructor(e,t,r){this.variableNames=["x"],this.outputShape=t.map((c,p)=>c[0]+e[p]+c[1]);const s=e.length,a=Ke(s),o=t.map(c=>c[0]).join(","),i=t.map((c,p)=>c[0]+e[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),l=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${o};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${o});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VD{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((f,m)=>f[0]+e[m]+f[1]);const s=e.length,a=Ke(s),o=t.map(f=>f[0]).join(","),i=t.map((f,m)=>f[0]+e[m]).join(","),u=Pt("rc",s),l=Pt("source",s),c=`${u[s-1]} < ${this.outputShape[s-1]}`,p=s===1?"source":`vec2(${l.slice(-2).join()})`,d=r==="reflect"?0:1;let h="";if(s===1){const f=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;h=`
        ${a} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${u[s-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
      `}else{const f=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;h=`
        ${a} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${u[s-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
        rc = outputLoc;
        ${u[s-2]} += 1;
        if(${u[s-2]} < ${this.outputShape[s-2]}) {
          ${f}
          result[2] = getChannel(getX(${l.join()}), ${p});
          ${u[s-1]} += 1;
          if(${c}) {
            ${f}
            result[3] = getChannel(getX(${l.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${o});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WD=({inputs:n,backend:e,attrs:t})=>{const{x:r}=n,{paddings:s,mode:a}=t,o=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new VD(r.shape,s,a):new BD(r.shape,s,a);return e.runWebGLProgram(o,[r],r.dtype)},UD={kernelName:Yo,backendName:"webgl",kernelFunc:WD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zD=`if (b == 0.0) return NAN;
  return mod(a, b);`,GD=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+ka+`
  return result;
`,HD=Ct({opSnippet:zD,packedOpSnippet:GD}),jD={kernelName:xf,backendName:"webgl",kernelFunc:HD};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qD{constructor(e,t,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KD=`
if (a == b) {
  return 1.0;
};
return a / b;`,XD=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Ty=Ct({opSnippet:KD,packedOpSnippet:XD,checkOutOfBounds:!0}),YD={kernelName:Ec,backendName:"webgl",kernelFunc:Ty};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Md="return a - b;",Cy=Ct({opSnippet:Md,packedOpSnippet:Md,supportsComplex:!0,cpuKernelImpl:XN}),QD={kernelName:vl,backendName:"webgl",kernelFunc:Cy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _y(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:a}=r,o=ct([a],s.shape),i=Iy({inputs:{x:s},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),u=mt(i.shape,o),l=te({inputs:{x:i},backend:t,attrs:{shape:u}}),c=Cy({inputs:{a:s,b:l},backend:t}),p=vy({inputs:{x:c},backend:t}),d=Pi({inputs:{x:p},backend:t,attrs:{axis:o,keepDims:!1}}),h=te({inputs:{x:d},backend:t,attrs:{shape:u}}),f=Ty({inputs:{a:p,b:h},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),f}const ZD={kernelName:ci,backendName:"webgl",kernelFunc:_y};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JD(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:a,seed:o,normalized:i}=r,u=i?s:_y({inputs:{logits:s},backend:t,attrs:{dim:s.shape.length-1}}),l=u.shape[0],c=u.shape[1],p=new qD(l,c,a),d=[[o]],h=t.runWebGLProgram(p,[u],"int32",d);return i||t.disposeIntermediateTensorInfo(u),h}const eP={kernelName:bf,backendName:"webgl",kernelFunc:JD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tP=$n+`
  return -x;
`,nP=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function rP(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){const a=t.texData.get(r.dataId),[o,i]=AN(a.values,r.shape,r.dtype);return t.makeTensorInfo(i,r.dtype,o)}let s;return L().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Pr(r.shape,nP):s=new Kn(r.shape,tP),t.runWebGLProgram(s,[r],r.dtype)}const sP={kernelName:Yc,backendName:"webgl",kernelFunc:rP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aP=dg;function oP(n){Cn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:a}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=r,l=t.readSync(s.dataId),c=t.readSync(a.dataId),{selectedIndices:p}=aP(l,c,o,i,u);return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}const iP={kernelName:Qo,backendName:"webgl",kernelFunc:oP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uP=hg;function cP(n){Cn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:a}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=r,c=t.readSync(s.dataId),p=t.readSync(a.dataId),{selectedIndices:d,validOutputs:h}=uP(c,p,o,i,u,l);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([h]))]}const lP={kernelName:Zo,backendName:"webgl",kernelFunc:cP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pP=fg;function dP(n){Cn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:a}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=r,c=t.readSync(s.dataId),p=t.readSync(a.dataId),d=o,h=i,f=u,m=l,{selectedIndices:g,selectedScores:y}=pP(c,p,d,h,f,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const hP={kernelName:Jo,backendName:"webgl",kernelFunc:dP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fP{constructor(e,t,r,s){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mP=n=>{const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{dtype:a,depth:o,onValue:i,offValue:u}=r,l=V(s.shape),c=new fP(l,o,i,u),p=te({inputs:{x:s},backend:t,attrs:{shape:[l]}}),d=t.runWebGLProgram(c,[p],a);t.disposeIntermediateTensorInfo(p);const h=[...s.shape,o],f=te({inputs:{x:d},backend:t,attrs:{shape:h}});return t.disposeIntermediateTensorInfo(d),f},gP={kernelName:ei,backendName:"webgl",kernelFunc:mP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yo(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){const s=Ea({inputs:{input:r},backend:t}),a=yo({inputs:{x:s},backend:t}),o=Li({inputs:{input:r},backend:t}),i=yo({inputs:{x:o},backend:t}),u=Sr({inputs:{real:a,imag:i},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),u}else return Ra({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}const yP={kernelName:Tl,backendName:"webgl",kernelFunc:yo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ky(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=Ea({inputs:{input:r},backend:t}),a=ky({inputs:{x:s},backend:t}),o=Li({inputs:{input:r},backend:t}),i=yo({inputs:{x:o},backend:t}),u=Sr({inputs:{real:a,imag:i},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),u}else return Ra({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}const xP={kernelName:Zc,backendName:"webgl",kernelFunc:ky};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bP(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return Qu({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const a=e[0].shape,o=e[0].dtype;e.forEach(c=>{Zt(a,c.shape,"All tensors passed to stack must have matching shapes"),I(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],u=e.map(c=>{const p=Qu({inputs:{input:c},backend:t,attrs:{dim:s}});return i.push(p),p}),l=hy({inputs:u,backend:t,attrs:{axis:s}});return i.forEach(c=>t.disposeIntermediateTensorInfo(c)),l}const wP={kernelName:Jc,backendName:"webgl",kernelFunc:bP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vP{constructor(e,t,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,c)=>l[0]+e[c]+l[1]);const s=e.length,a=Ke(s),o=t.map(l=>l[0]).join(","),i=t.map((l,c)=>l[0]+e[c]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${o};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${o});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SP{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((m,g)=>m[0]+e[g]+m[1]);const s=e.length,a=Ke(s),o=t.map(m=>m[0]).join(","),i=t.map((m,g)=>m[0]+e[g]).join(","),u=Pt("rc",s),l=Pt("source",s),c=`${u[s-1]} < ${this.outputShape[s-1]}`,p=s===1?"source":`vec2(${l.slice(-2).join()})`,d=[`${a} rc = outputLoc;`,`${u[s-1]} += 1;
       if(${c}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${u[s-2]} += 1;
       if(${u[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${u[s-1]} += 1;
         if(${c}) {`],h=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let m=0,g=s===1?2:4;m<g;m++)f+=`
        ${d[m]}
        if (${h}) {
          result[${m}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${m}] = getChannel(getX(${l.join()}), ${p});
        }
      `;f+=s===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${o});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ny=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:a,constantValue:o}=r;if(V(s.shape)===0){const l=a.map((c,p)=>c[0]+s.shape[p]+c[1]);return Ra({backend:t,attrs:{shape:l,value:o,dtype:s.dtype}})}const i=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SP(s.shape,a,o):new vP(s.shape,a,o),u=[[o]];return t.runWebGLProgram(i,[s],s.dtype,u)},$P={kernelName:ti,backendName:"webgl",kernelFunc:Ny};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IP=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,TP=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+ka+`
  return result;
`,CP=Ct({opSnippet:IP,packedOpSnippet:TP}),_P={kernelName:el,backendName:"webgl",kernelFunc:CP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kP(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:a,keepDims:o}=r,i=s.shape.length,u=[],l=ct(a,s.shape);let c=l;const p=Ht(c,i);let d=s;p!=null&&(d=Bt({inputs:{x:s},backend:t,attrs:{perm:p}}),c=Tt(c.length,i),u.push(d)),gt("prod",c,i);let h;if(t.shouldExecuteOnCPU([d])){const f=t.texData.get(d.dataId).values,{outVals:m,outShape:g,outDtype:y}=FN(d.shape,d.dtype,f,c);h=t.makeTensorInfo(g,y,m)}else{const[f,m]=kt(d.shape,c),g=V(m),y=te({inputs:{x:d},backend:t,attrs:{shape:[-1,g]}}),x=_l(s.dtype),w=Jr(y,x,"prod",t);h=te({inputs:{x:w},backend:t,attrs:{shape:f}}),u.push(y),u.push(w)}if(o){u.push(h);const f=mt(h.shape,l);h=te({inputs:{x:h},backend:t,attrs:{shape:f}})}return u.forEach(f=>t.disposeIntermediateTensorInfo(f)),h}const NP={kernelName:ri,backendName:"webgl",kernelFunc:kP};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EP(n){const{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:a,indices:o}=e,{outputRaggedRank:i}=r,u=s.map(y=>t.readSync(y.dataId)),l=s.map(y=>y.shape),c=t.readSync(a.dataId),p=t.readSync(o.dataId),[d,h,f]=DN(u,l,c,a.shape,a.dtype,p,o.shape,i),m=d.map(y=>t.makeTensorInfo([y.length],"int32",y)),g=t.makeTensorInfo(f,a.dtype,h);return m.concat([g])}const RP={kernelName:wf,backendName:"webgl",kernelFunc:EP};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AP(n){const{inputs:e,backend:t,attrs:r}=n,{shape:s,values:a,defaultValue:o,rowPartitionTensors:i}=e,{rowPartitionTypes:u}=r,l=t.readSync(s.dataId),c=t.readSync(a.dataId),p=t.readSync(o.dataId),d=i.map(g=>t.readSync(g.dataId)),h=i.map(g=>g.shape),[f,m]=PN(l,s.shape,c,a.shape,a.dtype,p,o.shape,d,h,u);return t.makeTensorInfo(f,a.dtype,m)}const OP={kernelName:vf,backendName:"webgl",kernelFunc:AP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ey=n=>{const{backend:e,attrs:t}=n,{start:r,stop:s,step:a,dtype:o}=t,i=LN(r,s,a,o);return e.makeTensorInfo([i.length],o,i)},FP={kernelName:tl,backendName:"webgl",kernelFunc:Ey};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DP="return 1.0 / x;",PP=Ae({opSnippet:DP}),LP={kernelName:$f,backendName:"webgl",kernelFunc:PP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MP=$n+`
  return (x < 0.0) ? 0.0 : x;
`,BP=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,VP=Ae({opSnippet:MP,packedOpSnippet:BP}),WP={kernelName:nl,backendName:"webgl",kernelFunc:VP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UP=$n+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,zP=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,GP=Ae({opSnippet:UP,packedOpSnippet:zP}),HP={kernelName:sl,backendName:"webgl",kernelFunc:GP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jP{constructor(e,t,r,s,a){this.variableNames=["A"],this.outputShape=[];const[o,i,u,l]=e;this.outputShape=[o,t,r,l];const c=[s&&t>1?i-1:i,s&&r>1?u-1:u],p=[s&&t>1?t-1:t,s&&r>1?r-1:r];let d;a?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qP{constructor(e,t,r,s,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,u,l]=e;this.outputShape=[o,t,r,l];const c=[s&&t>1?i-1:i,s&&r>1?u-1:u],p=[s&&t>1?t-1:t,s&&r>1?r-1:r];let d;a?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KP(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:a,halfPixelCenters:o,size:i}=r,[u,l]=i,c=L().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new qP(s.shape,u,l,a,o):new jP(s.shape,u,l,a,o);return t.runWebGLProgram(c,[s],"float32")}const XP={kernelName:ai,backendName:"webgl",kernelFunc:KP};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YP{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,a]=t,[,o,i]=e,u=[r&&o>1?s-1:s,r&&i>1?a-1:a],l=[r&&o>1?o-1:o,r&&i>1?i-1:i],c=u[0]/l[0],p=u[1]/l[1],d=1/c,h=1/p,f=Math.ceil(d)*2+2,m=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${h});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QP(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:a}=e,{alignCorners:o}=r,i=new YP(a.shape,s.shape,o);return t.runWebGLProgram(i,[a],a.dtype)}const ZP={kernelName:e0,backendName:"webgl",kernelFunc:QP};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JP{constructor(e,t,r,s,a){this.variableNames=["A"],this.outputShape=[];const[o,i,u,l]=e;this.outputShape=[o,t,r,l];const c=[s&&t>1?i-1:i,s&&r>1?u-1:u],p=[s&&t>1?t-1:t,s&&r>1?r-1:r],d=s?"0.5":"0.0";let h;a?h="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e3{constructor(e,t,r,s,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,u,l]=e;this.outputShape=[o,t,r,l];const c=[s&&t>1?i-1:i,s&&r>1?u-1:u],p=[s&&t>1?t-1:t,s&&r>1?r-1:r],d=s?"0.5":"0.0";let h;a?h="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t3(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:a,halfPixelCenters:o,size:i}=r,[u,l]=i,c=L().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new e3(s.shape,u,l,a,o):new JP(s.shape,u,l,a,o);return t.runWebGLProgram(c,[s],s.dtype)}const n3={kernelName:si,backendName:"webgl",kernelFunc:t3};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r3{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,a]=t,[,o,i]=e,u=[r&&o>1?s-1:s,r&&i>1?a-1:a],l=[r&&o>1?o-1:o,r&&i>1?i-1:i],c=u[0]/l[0],p=u[1]/l[1],d=1/c,h=1/p,f=Math.ceil(d)*2+2,m=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${h});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s3(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:a}=e,{alignCorners:o}=r,i=new r3(a.shape,s.shape,o);return t.runWebGLProgram(i,[a],a.dtype)}const a3={kernelName:Jb,backendName:"webgl",kernelFunc:s3};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o3{constructor(e,t){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const s=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,a=e.map((i,u)=>s(u)).join(","),o=Ke(r);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i3{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const s=Pt("rc",r),a=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,o=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,i=Ke(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(s.slice())};
          if(${a}){
            result.g = ${l(s.slice())};
          }
          if(${o}) {
            result.b = ${c(s.slice())};
            if(${a}) {
              result.a = ${p(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(f){return d(f)}function l(f){return f[r-1]="("+f[r-1]+" + 1)",d(f)}function c(f){return f[r-2]="("+f[r-2]+" + 1)",d(f)}function p(f){return f[r-1]="("+f[r-1]+" + 1)",f[r-2]="("+f[r-2]+" + 1)",d(f)}function d(f){const m=e.map((x,w)=>h(w,f)),g=m.join(","),y=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function h(f,m){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${m[f]} - 1`:`${m[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u3(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:a}=r,o=s.shape.length,i=ct(a,s.shape);if(o===0)return Qt({inputs:{x:s},backend:t});const u=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new i3(s.shape,i):new o3(s.shape,i);return t.runWebGLProgram(u,[s],s.dtype)}const c3={kernelName:oi,backendName:"webgl",kernelFunc:u3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class l3{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],s=e[2];this.outputShape=e;let a="";typeof t=="number"?a=`float outputValue = ${t.toFixed(2)};`:a=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p3={kernelName:mi,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:a,center:o}=e,i=t,u=new l3(r.shape,a),[l,c]=tp(o,r.shape[1],r.shape[2]),p=[[l,c,Math.sin(s),Math.cos(s)]];return i.runWebGLProgram(u,[r],r.dtype,p)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d3=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,h3=Ae({opSnippet:d3}),f3={kernelName:al,backendName:"webgl",kernelFunc:h3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m3="return inversesqrt(x);",g3=Ae({opSnippet:m3,cpuKernelImpl:MN}),y3={kernelName:ol,backendName:"webgl",kernelFunc:g3};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ry{constructor(e,t,r,s,a,o,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const u=Ke(a.length),l=Ke(o.length);let c="";r===1?c="i":r===2&&(c="i, j");const p=`getIndices(${c})`;let d="";s===1?d="i":s===2&&(d="i, coords[1]");const h=`getUpdates(${d})`,f=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${a});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${f};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${h};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x3(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:a}=e,{shape:o}=r,{sliceRank:i,numUpdates:u,sliceSize:l,strides:c,outputSize:p}=bi(a,s,o),d=[p/l,l];if(p===0)return t.makeTensorInfo(o,s.dtype);const h=te({inputs:{x:s},backend:t,attrs:{shape:[u,i]}}),f=te({inputs:{x:a},backend:t,attrs:{shape:[u,l]}}),m=t.makeTensorInfo([],"float32",new Float32Array([0])),g=new Ry(u,i,h.shape.length,f.shape.length,c,d),y=t.runWebGLProgram(g,[f,h,m],f.dtype),x=te({inputs:{x:y},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(m),x}const b3={kernelName:ii,backendName:"webgl",kernelFunc:x3};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class w3{constructor(e,t,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];const a="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=L().getNumber("WEBGL_VERSION")===2?a:o,u=s==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v3(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:s,values:a}=e,{side:o}=r,i=new w3(s.shape[0],s.shape[1],a.shape[1],o),u=[[s.shape[1]]];return t.runWebGLProgram(i,[s,a],"int32",u)}const S3={kernelName:If,backendName:"webgl",kernelFunc:v3};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $3{constructor(e,t,r){this.variableNames=["c","a","b"],this.outputShape=t;let s,a;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)a="resRC",s="resRC";else{const i=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let c=0;c<t.length;c++)l.push(`${i[c]}`),c<e&&u.push(`${i[c]}`);s=u.join(),a=l.join()}const o=Ke(r);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I3(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:a}=e,o=new $3(r.shape.length,s.shape,s.shape.length);return t.runWebGLProgram(o,[r,s,a],Bn(s.dtype,a.dtype))}const T3={kernelName:il,backendName:"webgl",kernelFunc:I3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C3=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${bg};
  float scale = ${wg};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,_3=Ae({opSnippet:C3}),k3={kernelName:Tf,backendName:"webgl",kernelFunc:_3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N3=Os+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,E3=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,R3=Ae({opSnippet:N3,packedOpSnippet:E3,cpuKernelImpl:VN}),A3={kernelName:ll,backendName:"webgl",kernelFunc:R3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O3=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,F3=Ae({opSnippet:O3}),D3={kernelName:_f,backendName:"webgl",kernelFunc:F3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P3=Os+`
  return sin(x);
`,L3=Ae({opSnippet:P3}),M3={kernelName:cl,backendName:"webgl",kernelFunc:L3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B3=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,V3=Ae({opSnippet:B3}),W3={kernelName:Cf,backendName:"webgl",kernelFunc:V3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U3=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,z3=Ae({opSnippet:U3}),G3={kernelName:kf,backendName:"webgl",kernelFunc:z3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H3=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:a,paddings:o}=r;I(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const i=a.reduce((y,x)=>y*x),u=[[0,0]];u.push(...o);for(let y=1+a.length;y<s.shape.length;++y)u.push([0,0]);const l=[],c=Ny({inputs:{x:s},backend:t,attrs:{paddings:u,constantValue:0}}),p=Sa(c.shape,a,i,!1),d=$a(p.length,a.length,!1),h=Ia(c.shape,a,i,!1),f=te({inputs:{x:c},backend:t,attrs:{shape:p}}),m=Bt({inputs:{x:f},backend:t,attrs:{perm:d}}),g=te({inputs:{x:m},backend:t,attrs:{shape:h}});return l.push(c),l.push(f),l.push(m),l.forEach(y=>t.disposeIntermediateTensorInfo(y)),g},j3={kernelName:dl,backendName:"webgl",kernelFunc:H3};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q3(n){const{inputs:e,backend:t}=n,{indices:r,values:s,denseShape:a,defaultValue:o}=e;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const i=t.readSync(r.dataId),u=t.readSync(s.dataId),l=t.readSync(a.dataId),c=t.readSync(o.dataId)[0],[p,d,h,f,m]=UN(i,r.shape,r.dtype,u,s.dtype,l,c);return[t.makeTensorInfo(d,r.dtype,p),t.makeTensorInfo([d[0]],s.dtype,h),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),t.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const K3={kernelName:fl,backendName:"webgl",kernelFunc:q3};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X3(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:s,newShape:a}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const o=Array.from(t.readSync(s.dataId)),i=t.readSync(r.dataId),u=Array.from(t.readSync(a.dataId)),[l,c,p]=zN(i,r.shape,r.dtype,o,u);return[t.makeTensorInfo(c,r.dtype,l),t.makeTensorInfo([p.length],a.dtype,new Int32Array(p))]}const Y3={kernelName:li,backendName:"webgl",kernelFunc:X3};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q3(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:a}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);const o=t.readSync(r.dataId),i=t.readSync(s.dataId),u=t.readSync(a.dataId),[l,c]=ey(o,r.shape,r.dtype,i,u,!0);return t.makeTensorInfo(c,r.dtype,l)}const Z3={kernelName:ml,backendName:"webgl",kernelFunc:Q3};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J3(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:a}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);const o=t.readSync(r.dataId),i=t.readSync(s.dataId),u=t.readSync(a.dataId),[l,c]=ey(o,r.shape,r.dtype,i,u);return t.makeTensorInfo(c,r.dtype,l)}const eL={kernelName:gl,backendName:"webgl",kernelFunc:J3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tL(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:a,defaultValue:o}=e,{outputShape:i}=r,{sliceRank:u,numUpdates:l,sliceSize:c,strides:p,outputSize:d}=bi(a,s,i),h=!1;if(a.dtype==="string"){const y=t.bufferSync(s),x=t.bufferSync(a),w=bs(t.readSync(o.dataId)[0]),v=BN(y,x,i,d,c,l,u,p,w,h);return t.makeTensorInfo(i,v.dtype,v.values)}const f=new Ry(l,u,s.shape.length,a.shape.length,p,[d,1],h),m=t.runWebGLProgram(f,[a,s,o],a.dtype),g=te({inputs:{x:m},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(m),g}const nL={kernelName:Nf,backendName:"webgl",kernelFunc:tL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rL(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:a,axis:o}=r,i=ct(o,s.shape)[0],u=sp(s,a,i),l=s.shape.length,c=new Array(l).fill(0),p=s.shape.slice();return u.map(d=>{const h=[...p];h[i]=d;const f=Fs({inputs:{x:s},backend:t,attrs:{begin:c,size:h}});return c[i]+=d,f})}const sL={kernelName:hl,backendName:"webgl",kernelFunc:rL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bd="return sqrt(x);",aL=Ae({opSnippet:Bd,packedOpSnippet:Bd,cpuKernelImpl:GN}),oL={kernelName:pl,backendName:"webgl",kernelFunc:aL};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iL="return x * x;",uL=Ae({opSnippet:iL}),cL={kernelName:Ef,backendName:"webgl",kernelFunc:uL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vd="return (a - b) * (a - b);",lL=Ct({opSnippet:Vd,packedOpSnippet:Vd}),pL={kernelName:yl,backendName:"webgl",kernelFunc:lL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dL({inputs:n,attrs:e,backend:t}){const{x:r}=n,s=$n+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,a=new Kn(r.shape,s);return t.runWebGLProgram(a,[r],r.dtype)}const hL={kernelName:fi,backendName:"webgl",kernelFunc:dL};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fL{constructor(e,t,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,a=Ke(r.length),o=Ke(r.length);let i="";if(s===1)i="coords * strides + begin";else{let u=0;i=r.map((l,c)=>(u++,r.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${u-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${e});
      ${a} strides = ${a}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mL(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:a,end:o,strides:i,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:d}=r,{finalShapeSparse:h,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:x,end:w,strides:v}=Ml(s.shape,a,o,i,u,l,c,p,d);let $;if(m)$=te({inputs:{x:s},backend:t,attrs:{shape:f}});else if(g||y){I(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const k=Pl(x,w,v),R=Fs({inputs:{x:s},backend:t,attrs:{begin:x,size:k}});$=te({inputs:{x:R},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(R)}else if(t.shouldExecuteOnCPU([s])){const R=t.readSync(s.dataId),F=it(s.shape,s.dtype,R),D=HN(h,F,v,x);$=t.makeTensorInfo(f,s.dtype,D.values)}else{const R=new fL(x,v,h);$=t.runWebGLProgram(R,[s],s.dtype)}const C=te({inputs:{x:$},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo($),C}const gL={kernelName:pi,backendName:"webgl",kernelFunc:mL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yL(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:a,leftPad:o,rightPad:i,padWidth:u,preserveShortSequences:l}=r,{data:c,dataSplits:p}=e,d=t.readSync(c.dataId),h=t.readSync(p.dataId),[f,m]=jN(d,h,s,a,o,i,u,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(p.shape,"int32",m)]}const xL={kernelName:xl,backendName:"webgl",kernelFunc:yL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bL(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:s}=r,{input:a,delimiter:o}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const i=t.readSync(a.dataId),u=t.readSync(o.dataId)[0],[l,c,p]=qN(i,u,s),d=c.length;return[t.makeTensorInfo([d,2],"int32",l),t.makeTensorInfo([d],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(p))]}const wL={kernelName:bl,backendName:"webgl",kernelFunc:bL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vL(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:s}=r,{input:a}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(a.dataId),i=KN(o,s);return t.makeTensorInfo(a.shape,"int32",i)}const SL={kernelName:wl,backendName:"webgl",kernelFunc:vL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $L="return tan(x);",IL=Ae({opSnippet:$L}),TL={kernelName:Sl,backendName:"webgl",kernelFunc:IL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CL=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,_L=Ae({opSnippet:CL}),kL={kernelName:$l,backendName:"webgl",kernelFunc:_L};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NL{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[o]*t[o];this.outputShape=r,this.rank=r.length;const s=Ke(this.rank),a=EL(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}}function EL(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${t[s]}, ${n[s]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ay(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:a}=r;if(s.dtype==="string"||s.shape.length>5){const u=t.readSync(s.dataId),l=s.dtype==="string"?u.map(d=>bs(d)):u,c=it(s.shape,s.dtype,l),p=YN(c,a);return t.makeTensorInfo(p.shape,p.dtype,p.values)}const o=new NL(s.shape,a);return t.runWebGLProgram(o,[s],s.dtype)}const RL={kernelName:ga,backendName:"webgl",kernelFunc:Ay};class AL{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class OL{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _r(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function Wd(n){let e=1;for(;e<n;)e*=2;return e}function FL(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:a,sorted:o}=r,i=L().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=L().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=s.shape,c=l[l.length-1];if(t.shouldExecuteOnCPU([s])||c<i||a>u){const D=t.readSync(s.dataId),[M,U]=QN(D,l,s.dtype,a,o);return[t.makeTensorInfo(M.shape,M.dtype,M.values),t.makeTensorInfo(U.shape,U.dtype,U.values)]}if(a===0)return l[l.length-1]=0,[t.makeTensorInfo(l,s.dtype,[]),t.makeTensorInfo(l,"int32",[])];if(c===1)return[s,Ra({attrs:{shape:l,dtype:"int32",value:0},backend:t})];const p=t.texData.get(s.dataId),d=p!==null&&p.isPacked,h=d?t.unpackTensor(s):s,m=V(l)/c,g=te({inputs:{x:h},attrs:{shape:[m,c]},backend:t});d&&_r(t,h);const y=Wd(a),x=Wd(c);let w=null;const v=()=>w===null?[g,g]:[g,w],$=(D,M,U)=>{const j=v(),Y=new AL(U),ae=[[c],[w===null?1:0],[Number.NEGATIVE_INFINITY],[D],[M]],me=w;w=t.runWebGLProgram(Y,j,"int32",ae),_r(t,me)};for(let D=1;D<y;D*=2){const M=D*2;for(let U=D;U>=1;U/=2)$(M,U,[m,x])}for(let D=x;D>y;D/=2){const M=v(),U=new OL([m,D/2]),Y=[[c],[w===null?1:0],[y]],Q=w;w=t.runWebGLProgram(U,M,"int32",Y),_r(t,Q);const ae=y/2,me=ae*2;for(let le=ae;le>=1;le/=2)$(me,le,w.shape)}let C=w;w=Fs({inputs:{x:w},backend:t,attrs:{begin:0,size:[m,a]}}),_r(t,C);let k=$y({inputs:{x:g,indices:w},backend:t,attrs:{axis:1,batchDims:1}});_r(t,g);const R=l.slice(0,-1);R.push(a),C=w,w=te({inputs:{x:w},attrs:{shape:R},backend:t}),_r(t,C);const F=k;return k=te({inputs:{x:k},attrs:{shape:R},backend:t}),_r(t,F),[k,w]}const DL={kernelName:di,backendName:"webgl",kernelFunc:FL};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PL{constructor(e,t,r,s,a,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const i=r==="nearest"?1:2;let u;switch(s){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LL(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,transforms:a}=e,{interpolation:o,fillMode:i,fillValue:u,outputShape:l}=r,[c,p,d,h]=s.shape,[f,m]=l!=null?l:[p,d],g=[c,f,m,h],y=new PL(p,d,o,i,u,g);return t.runWebGLProgram(y,[s,a],"float32")}const ML={kernelName:hi,backendName:"webgl",kernelFunc:LL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BL(n){const{inputs:e,attrs:t,backend:r}=n,{axis:s}=t,{x:a}=e;Ca(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(a.dataId),{outputValues:i,outputShape:u,indices:l}=ZN(o,s,a.shape,a.dtype);return[r.makeTensorInfo(u,a.dtype,i),r.makeTensorInfo([l.length],"int32",l)]}const VL={kernelName:Rf,backendName:"webgl",kernelFunc:BL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WL(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:a}=r;a<0&&(a+=s.shape.length);const o=s,i=o.shape.length,u=s.shape[a],l=new Array(i-1);let c=0;for(let m=0;m<i;m++)m!==a&&(l[c++]=o.shape[m]);const p=[],d=new Array(i).fill(0),h=o.shape.slice();h[a]=1;const f=new Array(u);for(let m=0;m<f.length;m++){d[a]=m;const g=Fs({inputs:{x:o},backend:t,attrs:{begin:d,size:h}}),y=te({inputs:{x:g},backend:t,attrs:{shape:l}});f[m]=y,p.push(g)}return p.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}const UL={kernelName:Il,backendName:"webgl",kernelFunc:WL};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zL{constructor(e,t){this.variableNames=["x","segmentIds"];const r=e.windowSize,s=e.batchSize,a=e.inSize,o=e.numSegments,i=o*Math.ceil(a/r);this.outputShape=[s,i];const u="0.0",l="sumValue",c=Math.floor(r/4)*4,p=r%4,d=`
        sumValue += dot(values, segFilter);
    `;let h="";a%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let f="";a%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${l});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GL(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:a}=e,{numSegments:o}=r,i=s.shape.length,u=[];let l=0;const c=Ht([l],i);let p=s;c!=null&&(p=Bt({inputs:{x:s},backend:t,attrs:{perm:c}}),u.push(p),l=Tt(1,i)[0]);const d=Og(p.shape,l,o),h=V([p.shape[l]]),f=te({inputs:{x:p},backend:t,attrs:{shape:[-1,h]}});u.push(f);const m=_l(s.dtype),g=(v,$,C,k,R)=>{const F=v.shape[0],D=v.shape[1],M=Ag(D,R),U={windowSize:M,inSize:D,batchSize:F,numSegments:R},j=new zL(U,$),Y=t.compileAndRun(j,[v,C],k);if(u.push(Y),Y.shape[1]===R)return Y;const Q=Ey({backend:t,attrs:{start:0,stop:R,step:1,dtype:"float32"}}),ae=Ay({inputs:{x:Q},backend:t,attrs:{reps:[D/M]}});return u.push(Q),u.push(ae),g(Y,$,ae,k,R)},y=g(f,"unsortedSegmentSum",a,m,o),x=te({inputs:{x:y},backend:t,attrs:{shape:d}});let w=x;if(c!=null){u.push(x);const v=wa(c);w=Bt({inputs:{x:w},backend:t,attrs:{perm:v}})}return u.forEach(v=>t.disposeIntermediateTensorInfo(v)),w}const HL={kernelName:Af,backendName:"webgl",kernelFunc:GL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jL=[zE,HE,KE,QE,JE,nR,sR,oR,lR,dR,mR,xR,vR,TR,kR,ER,AR,PR,MR,VR,GR,QR,JR,tA,iA,cA,hA,CE,gA,vA,TA,RA,OA,DA,LA,BA,UA,HA,KA,YA,ZA,eO,rO,aO,cO,pO,fO,yO,bO,$O,_O,RO,FO,LO,MO,VO,UO,GO,jO,KO,ZO,tF,sF,oF,cF,dF,gF,wF,TE,SF,bA,TF,kF,RF,kE,DF,BF,WF,HF,KF,ZF,tD,aD,cD,dD,fD,xD,wD,SD,CD,kD,ED,AD,FD,MD,UD,jD,eP,RE,sP,iP,lP,hP,rA,gP,xP,wP,$P,_P,EE,NP,RP,OP,FP,sA,YD,LP,WP,HP,OE,XP,ZP,n3,a3,c3,p3,f3,y3,b3,S3,T3,k3,A3,D3,M3,W3,XR,ZD,G3,j3,K3,Y3,Z3,eL,nL,sL,oL,cL,pL,hL,gL,xL,wL,SL,QD,VE,TL,kL,RL,DL,ML,WE,VL,UL,HL,yP];for(const n of jL)Of(n);var qL={};(function(){var n;function e(T){var A=0;return function(){return A<T.length?{done:!1,value:T[A++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(T,A,_){return T==Array.prototype||T==Object.prototype||(T[A]=_.value),T};function r(T){T=[typeof globalThis=="object"&&globalThis,T,typeof window=="object"&&window,typeof self=="object"&&self,typeof wn=="object"&&wn];for(var A=0;A<T.length;++A){var _=T[A];if(_&&_.Math==Math)return _}throw Error("Cannot find global object")}var s=r(this);function a(T,A){if(A)e:{var _=s;T=T.split(".");for(var G=0;G<T.length-1;G++){var H=T[G];if(!(H in _))break e;_=_[H]}T=T[T.length-1],G=_[T],A=A(G),A!=G&&A!=null&&t(_,T,{configurable:!0,writable:!0,value:A})}}a("Symbol",function(T){function A(re){if(this instanceof A)throw new TypeError("Symbol is not a constructor");return new _(G+(re||"")+"_"+H++,re)}function _(re,B){this.g=re,t(this,"description",{configurable:!0,writable:!0,value:B})}if(T)return T;_.prototype.toString=function(){return this.g};var G="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",H=0;return A}),a("Symbol.iterator",function(T){if(T)return T;T=Symbol("Symbol.iterator");for(var A="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),_=0;_<A.length;_++){var G=s[A[_]];typeof G=="function"&&typeof G.prototype[T]!="function"&&t(G.prototype,T,{configurable:!0,writable:!0,value:function(){return o(e(this))}})}return T});function o(T){return T={next:T},T[Symbol.iterator]=function(){return this},T}function i(T){var A=typeof Symbol!="undefined"&&Symbol.iterator&&T[Symbol.iterator];return A?A.call(T):{next:e(T)}}function u(T){if(!(T instanceof Array)){T=i(T);for(var A,_=[];!(A=T.next()).done;)_.push(A.value);T=_}return T}var l;if(typeof Object.setPrototypeOf=="function")l=Object.setPrototypeOf;else{var c;e:{var p={a:!0},d={};try{d.__proto__=p,c=d.a;break e}catch(T){}c=!1}l=c?function(T,A){if(T.__proto__=A,T.__proto__!==A)throw new TypeError(T+" is not extensible");return T}:null}var h=l;function f(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function m(T){if(T.l)throw new TypeError("Generator is already running");T.l=!0}f.prototype.o=function(T){this.h=T};function g(T,A){T.j={S:A,T:!0},T.g=T.m||T.s}f.prototype.return=function(T){this.j={return:T},this.g=this.s};function y(T,A,_){return T.g=_,{value:A}}function x(T){this.g=new f,this.h=T}function w(T,A){m(T.g);var _=T.g.i;return _?v(T,"return"in _?_.return:function(G){return{value:G,done:!0}},A,T.g.return):(T.g.return(A),$(T))}function v(T,A,_,G){try{var H=A.call(T.g.i,_);if(!(H instanceof Object))throw new TypeError("Iterator result "+H+" is not an object");if(!H.done)return T.g.l=!1,H;var re=H.value}catch(B){return T.g.i=null,g(T.g,B),$(T)}return T.g.i=null,G.call(T.g,re),$(T)}function $(T){for(;T.g.g;)try{var A=T.h(T.g);if(A)return T.g.l=!1,{value:A.value,done:!1}}catch(_){T.g.h=void 0,g(T.g,_)}if(T.g.l=!1,T.g.j){if(A=T.g.j,T.g.j=null,A.T)throw A.S;return{value:A.return,done:!0}}return{value:void 0,done:!0}}function C(T){this.next=function(A){return m(T.g),T.g.i?A=v(T,T.g.i.next,A,T.g.o):(T.g.o(A),A=$(T)),A},this.throw=function(A){return m(T.g),T.g.i?A=v(T,T.g.i.throw,A,T.g.o):(g(T.g,A),A=$(T)),A},this.return=function(A){return w(T,A)},this[Symbol.iterator]=function(){return this}}function k(T,A){return A=new C(new x(A)),h&&T.prototype&&h(A,T.prototype),A}var R=typeof Object.assign=="function"?Object.assign:function(T,A){for(var _=1;_<arguments.length;_++){var G=arguments[_];if(G)for(var H in G)Object.prototype.hasOwnProperty.call(G,H)&&(T[H]=G[H])}return T};a("Object.assign",function(T){return T||R}),a("Promise",function(T){function A(B){this.h=0,this.i=void 0,this.g=[],this.o=!1;var q=this.j();try{B(q.resolve,q.reject)}catch(ee){q.reject(ee)}}function _(){this.g=null}function G(B){return B instanceof A?B:new A(function(q){q(B)})}if(T)return T;_.prototype.h=function(B){if(this.g==null){this.g=[];var q=this;this.i(function(){q.l()})}this.g.push(B)};var H=s.setTimeout;_.prototype.i=function(B){H(B,0)},_.prototype.l=function(){for(;this.g&&this.g.length;){var B=this.g;this.g=[];for(var q=0;q<B.length;++q){var ee=B[q];B[q]=null;try{ee()}catch(ue){this.j(ue)}}}this.g=null},_.prototype.j=function(B){this.i(function(){throw B})},A.prototype.j=function(){function B(ue){return function(ye){ee||(ee=!0,ue.call(q,ye))}}var q=this,ee=!1;return{resolve:B(this.B),reject:B(this.l)}},A.prototype.B=function(B){if(B===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(B instanceof A)this.D(B);else{e:switch(typeof B){case"object":var q=B!=null;break e;case"function":q=!0;break e;default:q=!1}q?this.A(B):this.m(B)}},A.prototype.A=function(B){var q=void 0;try{q=B.then}catch(ee){this.l(ee);return}typeof q=="function"?this.F(q,B):this.m(B)},A.prototype.l=function(B){this.s(2,B)},A.prototype.m=function(B){this.s(1,B)},A.prototype.s=function(B,q){if(this.h!=0)throw Error("Cannot settle("+B+", "+q+"): Promise already settled in state"+this.h);this.h=B,this.i=q,this.h===2&&this.C(),this.u()},A.prototype.C=function(){var B=this;H(function(){if(B.v()){var q=s.console;typeof q!="undefined"&&q.error(B.i)}},1)},A.prototype.v=function(){if(this.o)return!1;var B=s.CustomEvent,q=s.Event,ee=s.dispatchEvent;return typeof ee=="undefined"?!0:(typeof B=="function"?B=new B("unhandledrejection",{cancelable:!0}):typeof q=="function"?B=new q("unhandledrejection",{cancelable:!0}):(B=s.document.createEvent("CustomEvent"),B.initCustomEvent("unhandledrejection",!1,!0,B)),B.promise=this,B.reason=this.i,ee(B))},A.prototype.u=function(){if(this.g!=null){for(var B=0;B<this.g.length;++B)re.h(this.g[B]);this.g=null}};var re=new _;return A.prototype.D=function(B){var q=this.j();B.I(q.resolve,q.reject)},A.prototype.F=function(B,q){var ee=this.j();try{B.call(q,ee.resolve,ee.reject)}catch(ue){ee.reject(ue)}},A.prototype.then=function(B,q){function ee(fe,ve){return typeof fe=="function"?function(ie){try{ue(fe(ie))}catch(ge){ye(ge)}}:ve}var ue,ye,_e=new A(function(fe,ve){ue=fe,ye=ve});return this.I(ee(B,ue),ee(q,ye)),_e},A.prototype.catch=function(B){return this.then(void 0,B)},A.prototype.I=function(B,q){function ee(){switch(ue.h){case 1:B(ue.i);break;case 2:q(ue.i);break;default:throw Error("Unexpected state: "+ue.h)}}var ue=this;this.g==null?re.h(ee):this.g.push(ee),this.o=!0},A.resolve=G,A.reject=function(B){return new A(function(q,ee){ee(B)})},A.race=function(B){return new A(function(q,ee){for(var ue=i(B),ye=ue.next();!ye.done;ye=ue.next())G(ye.value).I(q,ee)})},A.all=function(B){var q=i(B),ee=q.next();return ee.done?G([]):new A(function(ue,ye){function _e(ie){return function(ge){fe[ie]=ge,ve--,ve==0&&ue(fe)}}var fe=[],ve=0;do fe.push(void 0),ve++,G(ee.value).I(_e(fe.length-1),ye),ee=q.next();while(!ee.done)})},A});function F(T,A){T instanceof String&&(T+="");var _=0,G=!1,H={next:function(){if(!G&&_<T.length){var re=_++;return{value:A(re,T[re]),done:!1}}return G=!0,{done:!0,value:void 0}}};return H[Symbol.iterator]=function(){return H},H}a("Array.prototype.keys",function(T){return T||function(){return F(this,function(A){return A})}});var D=this||self;function M(T,A){T=T.split(".");var _=D;T[0]in _||typeof _.execScript=="undefined"||_.execScript("var "+T[0]);for(var G;T.length&&(G=T.shift());)T.length||A===void 0?_[G]&&_[G]!==Object.prototype[G]?_=_[G]:_=_[G]={}:_[G]=A}function U(T,A){var _=void 0;return new(_||(_=Promise))(function(G,H){function re(ee){try{q(A.next(ee))}catch(ue){H(ue)}}function B(ee){try{q(A.throw(ee))}catch(ue){H(ue)}}function q(ee){ee.done?G(ee.value):new _(function(ue){ue(ee.value)}).then(re,B)}q((A=A.apply(T,void 0)).next())})}function j(T,A,_){if(_=T.createShader(_===0?T.VERTEX_SHADER:T.FRAGMENT_SHADER),T.shaderSource(_,A),T.compileShader(_),!T.getShaderParameter(_,T.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+T.getShaderInfoLog(_));return _}function Y(T,A,_){this.h=T,this.g=A,this.u=_,this.l=0}function Q(T){return typeof T.g.canvas.transferToImageBitmap=="function"?Promise.resolve(T.g.canvas.transferToImageBitmap()):T.u?Promise.resolve(T.g.canvas):typeof createImageBitmap=="function"?createImageBitmap(T.g.canvas):(T.j===void 0&&(T.j=document.createElement("img")),new Promise(function(A){T.j.onload=function(){requestAnimationFrame(function(){A(T.j)})},T.j.src=T.g.canvas.toDataURL()}))}function ae(T,A){var _=T.g;if(T.m===void 0){var G=j(_,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),H=j(_,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),re=_.createProgram();if(_.attachShader(re,G),_.attachShader(re,H),_.linkProgram(re),!_.getProgramParameter(re,_.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+_.getProgramInfoLog(re));G=T.m=re,_.useProgram(G),H=_.getUniformLocation(G,"sampler0"),T.i={H:_.getAttribLocation(G,"aVertex"),G:_.getAttribLocation(G,"aTex"),V:H},T.s=_.createBuffer(),_.bindBuffer(_.ARRAY_BUFFER,T.s),_.enableVertexAttribArray(T.i.H),_.vertexAttribPointer(T.i.H,2,_.FLOAT,!1,0,0),_.bufferData(_.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),_.STATIC_DRAW),_.bindBuffer(_.ARRAY_BUFFER,null),T.o=_.createBuffer(),_.bindBuffer(_.ARRAY_BUFFER,T.o),_.enableVertexAttribArray(T.i.G),_.vertexAttribPointer(T.i.G,2,_.FLOAT,!1,0,0),_.bufferData(_.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),_.STATIC_DRAW),_.bindBuffer(_.ARRAY_BUFFER,null),_.uniform1i(H,0)}G=T.i,_.useProgram(T.m),_.canvas.width=A.width,_.canvas.height=A.height,_.viewport(0,0,A.width,A.height),_.activeTexture(_.TEXTURE0),T.h.bindTexture2d(A.glName),_.enableVertexAttribArray(G.H),_.bindBuffer(_.ARRAY_BUFFER,T.s),_.vertexAttribPointer(G.H,2,_.FLOAT,!1,0,0),_.enableVertexAttribArray(G.G),_.bindBuffer(_.ARRAY_BUFFER,T.o),_.vertexAttribPointer(G.G,2,_.FLOAT,!1,0,0),_.bindFramebuffer(_.DRAW_FRAMEBUFFER?_.DRAW_FRAMEBUFFER:_.FRAMEBUFFER,null),_.clearColor(0,0,0,0),_.clear(_.COLOR_BUFFER_BIT),_.colorMask(!0,!0,!0,!0),_.drawArrays(_.TRIANGLE_FAN,0,4),_.disableVertexAttribArray(G.H),_.disableVertexAttribArray(G.G),_.bindBuffer(_.ARRAY_BUFFER,null),T.h.bindTexture2d(0)}function me(T){this.g=T}var le=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function De(T,A){return A+T}function Xe(T,A){window[T]=A}function lt(T){var A=document.createElement("script");return A.setAttribute("src",T),A.setAttribute("crossorigin","anonymous"),document.body.appendChild(A),new Promise(function(_){A.addEventListener("load",function(){_()},!1)})}function wt(T){for(var A=[],_=T.size(),G=0;G<_;++G){var H=T.get(G);A.push({x:H.x,y:H.y,z:H.z,visibility:H.hasVisibility?H.visibility:void 0}),H.delete()}return A}function Je(T){for(var A=[],_=T.size(),G=0;G<_;++G){var H=T.get(G);A.push({index:H.index,score:H.score,label:H.hasLabel?H.label:void 0,displayName:H.hasDisplayName?H.displayName:void 0})}return A}function Nn(){return U(this,function T(){return k(T,function(A){switch(A.g){case 1:return A.m=2,y(A,WebAssembly.instantiate(le),4);case 4:A.g=3,A.m=0;break;case 2:return A.m=0,A.j=null,A.return(!1);case 3:return A.return(!0)}})})}function jt(T){if(this.g=T,this.listeners={},this.l={},this.B={},this.m={},this.s={},this.v=this.o=this.O=!0,this.F=Promise.resolve(),this.N="",this.u={},this.locateFile=T&&T.locateFile||De,typeof window=="object")T=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location!="undefined")T=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");this.P=T}n=jt.prototype,n.close=function(){return this.i&&this.i.delete(),Promise.resolve()};function En(T,A){return T.g.files===void 0?[]:typeof T.g.files=="function"?T.g.files(A):T.g.files}function Ir(T){return U(T,function A(){var _=this,G,H,re,B,q,ee,ue,ye,_e,fe,ve;return k(A,function(ie){switch(ie.g){case 1:return G=_,_.O?(H=En(_,_.l),y(ie,Nn(),2)):ie.return();case 2:if(re=ie.h,typeof window=="object")return Xe("createMediapipeSolutionsWasm",{locateFile:_.locateFile}),Xe("createMediapipeSolutionsPackedAssets",{locateFile:_.locateFile}),ee=H.filter(function(ge){return ge.data!==void 0}),ue=H.filter(function(ge){return ge.data===void 0}),ye=Promise.all(ee.map(function(ge){return Wn(G,ge.url)})),_e=Promise.all(ue.map(function(ge){return ge.simd===void 0||ge.simd&&re||!ge.simd&&!re?lt(G.locateFile(ge.url,G.P)):Promise.resolve()})).then(function(){return U(G,function ge(){var Se,Te,rt=this;return k(ge,function($e){if($e.g==1)return Se=window.createMediapipeSolutionsWasm,Te=window.createMediapipeSolutionsPackedAssets,y($e,Se(Te),2);rt.h=$e.h,$e.g=0})})}),fe=function(){return U(G,function ge(){var Se=this;return k(ge,function(Te){return Se.g.graph&&Se.g.graph.url?Te=y(Te,Wn(Se,Se.g.graph.url),0):(Te.g=0,Te=void 0),Te})})}(),y(ie,Promise.all([_e,ye,fe]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return B=H.filter(function(ge){return ge.simd===void 0||ge.simd&&re||!ge.simd&&!re}).map(function(ge){return G.locateFile(ge.url,G.P)}),importScripts.apply(null,u(B)),y(ie,createMediapipeSolutionsWasm(Module),6);case 6:_.h=ie.h,_.j=new OffscreenCanvas(1,1),_.h.canvas=_.j,q=_.h.GL.createContext(_.j,{antialias:!1,alpha:!1,U:typeof WebGL2RenderingContext!="undefined"?2:1}),_.h.GL.makeContextCurrent(q),ie.g=4;break;case 7:if(_.j=document.createElement("canvas"),ve=_.j.getContext("webgl2",{}),!ve&&(ve=_.j.getContext("webgl",{}),!ve))return alert("Failed to create WebGL canvas context when passing video frame."),ie.return();_.A=ve,_.h.canvas=_.j,_.h.createContext(_.j,!0,!0,{});case 4:_.i=new _.h.SolutionWasm,_.O=!1,ie.g=0}})})}function nt(T){return U(T,function A(){var _=this,G,H,re,B,q,ee,ue,ye;return k(A,function(_e){if(_e.g==1){if(_.g.graph&&_.g.graph.url&&_.N===_.g.graph.url)return _e.return();if(_.o=!0,!_.g.graph||!_.g.graph.url){_e.g=2;return}return _.N=_.g.graph.url,y(_e,Wn(_,_.g.graph.url),3)}for(_e.g!=2&&(G=_e.h,_.i.loadGraph(G)),H=i(Object.keys(_.u)),re=H.next();!re.done;re=H.next())B=re.value,_.i.overrideFile(B,_.u[B]);if(_.u={},_.g.listeners)for(q=i(_.g.listeners),ee=q.next();!ee.done;ee=q.next())ue=ee.value,ts(_,ue);ye=_.l,_.l={},_.setOptions(ye),_e.g=0})})}n.reset=function(){return U(this,function T(){var A=this;return k(T,function(_){A.i&&(A.i.reset(),A.m={},A.s={}),_.g=0})})},n.setOptions=function(T){var A=this;if(this.g.options){for(var _=[],G=[],H={},re=i(Object.keys(T)),B=re.next();!B.done;H={J:H.J,K:H.K},B=re.next()){var q=B.value;!(q in this.l&&this.l[q]===T[q])&&(this.l[q]=T[q],B=this.g.options[q])&&(B.onChange&&(H.J=B.onChange,H.K=T[q],_.push(function(ee){return function(){return U(A,function ue(){var ye,_e=this;return k(ue,function(fe){if(fe.g==1)return y(fe,ee.J(ee.K),2);ye=fe.h,ye===!0&&(_e.o=!0),fe.g=0})})}}(H))),B.graphOptionXref&&(q={valueNumber:B.type===0?T[q]:0,valueBoolean:B.type===1?T[q]:!1},B=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),B.graphOptionXref),q),G.push(B)))}(_.length!==0||G.length!==0)&&(this.o=!0,this.C=G,this.D=_)}};function Rn(T){return U(T,function A(){var _=this,G,H,re,B,q,ee,ue;return k(A,function(ye){switch(ye.g){case 1:if(!_.o)return ye.return();if(!_.D){ye.g=2;break}G=i(_.D),H=G.next();case 3:if(H.done){ye.g=5;break}return re=H.value,y(ye,re(),4);case 4:H=G.next(),ye.g=3;break;case 5:_.D=void 0;case 2:if(_.C){for(B=new _.h.GraphOptionChangeRequestList,q=i(_.C),ee=q.next();!ee.done;ee=q.next())ue=ee.value,B.push_back(ue);_.i.changeOptions(B),B.delete(),_.C=void 0}_.o=!1,ye.g=0}})})}n.initialize=function(){return U(this,function T(){var A=this;return k(T,function(_){return _.g==1?y(_,Ir(A),2):_.g!=3?y(_,nt(A),3):y(_,Rn(A),0)})})};function Wn(T,A){return U(T,function _(){var G=this,H,re;return k(_,function(B){return A in G.B?B.return(G.B[A]):(H=G.locateFile(A,""),re=fetch(H).then(function(q){return q.arrayBuffer()}),G.B[A]=re,B.return(re))})})}n.overrideFile=function(T,A){this.i?this.i.overrideFile(T,A):this.u[T]=A},n.clearOverriddenFiles=function(){this.u={},this.i&&this.i.clearOverriddenFiles()},n.send=function(T,A){return U(this,function _(){var G=this,H,re,B,q,ee,ue,ye,_e,fe;return k(_,function(ve){if(ve.g==1)return G.g.inputs?(H=1e3*(A==null?performance.now():A),y(ve,G.F,2)):ve.return();if(ve.g!=3)return y(ve,G.initialize(),3);for(re=new G.h.PacketDataList,B=i(Object.keys(T)),q=B.next();!q.done;q=B.next())if(ee=q.value,ue=G.g.inputs[ee]){e:{var ie=G,ge=T[ee];switch(ue.type){case"video":var Se=ie.m[ue.stream];if(Se||(Se=new Y(ie.h,ie.A,ie.v),ie.m[ue.stream]=Se),ie=Se,ie.l===0&&(ie.l=ie.h.createTexture()),typeof HTMLVideoElement!="undefined"&&ge instanceof HTMLVideoElement){var Te=ge.videoWidth;Se=ge.videoHeight}else typeof HTMLImageElement!="undefined"&&ge instanceof HTMLImageElement?(Te=ge.naturalWidth,Se=ge.naturalHeight):(Te=ge.width,Se=ge.height);Se={glName:ie.l,width:Te,height:Se},Te=ie.g,Te.canvas.width=Se.width,Te.canvas.height=Se.height,Te.activeTexture(Te.TEXTURE0),ie.h.bindTexture2d(ie.l),Te.texImage2D(Te.TEXTURE_2D,0,Te.RGBA,Te.RGBA,Te.UNSIGNED_BYTE,ge),ie.h.bindTexture2d(0),ie=Se;break e;case"detections":for(Se=ie.m[ue.stream],Se||(Se=new me(ie.h),ie.m[ue.stream]=Se),ie=Se,ie.data||(ie.data=new ie.g.DetectionListData),ie.data.reset(ge.length),Se=0;Se<ge.length;++Se){if(Te=ge[Se],ie.data.setBoundingBox(Se,Te.R),Te.M)for(var rt=0;rt<Te.M.length;++rt){var $e=Te.M[rt],vt=!!$e.visibility;ie.data.addNormalizedLandmark(Se,Object.assign(Object.assign({},$e),{hasVisibility:vt,visibility:vt?$e.visibility:0}))}if(Te.L)for(rt=0;rt<Te.L.length;++rt){$e=Te.L[rt],vt=!!$e.index;var nn=!!$e.label,An=!!$e.displayName;ie.data.addClassification(Se,{score:$e.score,hasIndex:vt,index:vt?$e.index:-1,hasLabel:nn,label:nn?$e.label:"",hasDisplayName:An,displayName:An?$e.displayName:""})}}ie=ie.data;break e;default:ie={}}}switch(ye=ie,_e=ue.stream,ue.type){case"video":re.pushTexture2d(Object.assign(Object.assign({},ye),{stream:_e,timestamp:H}));break;case"detections":fe=ye,fe.stream=_e,fe.timestamp=H,re.pushDetectionList(fe);break;default:throw Error("Unknown input config type: '"+ue.type+"'")}}G.i.send(re),re.delete(),ve.g=0})})};function es(T,A,_){return U(T,function G(){var H,re,B,q,ee,ue,ye=this,_e,fe,ve,ie,ge,Se,Te,rt,$e,vt,nn,An,Tr;return k(G,function(je){switch(je.g){case 1:if(!_)return je.return(A);for(H={},re=0,B=i(Object.keys(_)),q=B.next();!q.done;q=B.next())ee=q.value,ue=_[ee],typeof ue!="string"&&ue.type==="texture"&&++re;1<re&&(ye.v=!1),_e=i(Object.keys(_)),q=_e.next();case 2:if(q.done){je.g=4;break}if(fe=q.value,ve=_[fe],typeof ve=="string")return An=H,Tr=fe,y(je,Un(ye,fe,A[ve]),15);if(ie=A[ve.stream],ie===void 0){je.g=3;break}if(ve.type==="detection_list"){var Le=ie.getRectList(),Et=ie.getLandmarksList(),et=ie.getClassificationsList(),ht=[];if(Le)for(var rn=0;rn<Le.size();++rn){var W={R:Le.get(rn),M:wt(Et.get(rn)),L:Je(et.get(rn))};ht.push(W)}H[fe]=ht,je.g=7;break}if(ve.type==="landmarks"){ge=ie.getLandmarks(),H[fe]=ge?wt(ge):void 0,je.g=7;break}if(ve.type==="landmarks_list"){if(Se=ie.getLandmarksList())for(Le=[],Et=Se.size(),et=0;et<Et;++et)ht=Se.get(et),Le.push(wt(ht)),ht.delete();else Le=void 0;H[fe]=Le,je.g=7;break}if(ve.type==="rect_list"){if(Te=ie.getRectList())for(Le=[],Et=Te.size(),et=0;et<Et;++et)ht=Te.get(et),Le.push(ht);else Le=void 0;H[fe]=Le,je.g=7;break}if(ve.type==="classifications_list"){if(rt=ie.getClassificationsList())for(Le=[],Et=rt.size(),et=0;et<Et;++et)ht=rt.get(et),Le.push(Je(ht));else Le=void 0;H[fe]=Le,je.g=7;break}if(ve.type==="object_detection_list"){if($e=ie.getObjectDetectionList())for(Le=[],Et=$e.size(),et=0;et<Et;++et){ht=$e.get(et),rn=Le,W=rn.push;for(var X=ht.id,de=ht.keypoints,J=[],We=de.size(),Ue=0;Ue<We;++Ue){var xe=de.get(Ue);J.push({id:xe.id,point3d:{x:xe.point3d.x,y:xe.point3d.y,z:xe.point3d.z},point2d:{x:xe.point2d.x,y:xe.point2d.y,depth:xe.point2d.depth}})}W.call(rn,{id:X,keypoints:J,visibility:ht.visibility})}else Le=void 0;H[fe]=Le,je.g=7;break}if(ve.type!=="texture")throw Error("Unknown output config type: '"+ve.type+"'");return vt=ye.s[fe],vt||(vt=new Y(ye.h,ye.A,ye.v),ye.s[fe]=vt),Le=vt,Et=ie.getTexture2d(),ae(Le,Et),Le=Q(Le),y(je,Le,14);case 14:nn=je.h,H[fe]=nn;case 7:ve.transform&&H[fe]&&(H[fe]=ve.transform(H[fe])),je.g=3;break;case 15:An[Tr]=je.h;case 3:q=_e.next(),je.g=2;break;case 4:return je.return(H)}})})}function Un(T,A,_){return U(T,function G(){var H=this,re;return k(G,function(B){if(_.isNumber())return B.return(_.getNumber());if(_.isRect())return B.return(_.getRect());if(_.isLandmarks())return B.return(_.getLandmarks());if(_.isLandmarksList())return B.return(_.getLandmarksList());if(_.isClassificationsList())return B.return(_.getClassificationsList());if(_.isObjectDetectionList())return B.return(_.getObjectDetectionList());if(_.isTexture2d()){re=H.s[A],re||(re=new Y(H.h,H.A,H.v),H.s[A]=re);var q=B.return,ee=re,ue=_.getTexture2d();return ae(ee,ue),ee=Q(ee),q.call(B,ee)}return B.return(void 0)})})}function ts(T,A){for(var _=A.name||"$",G=[].concat(u(A.wants)),H=new T.h.StringList,re=i(A.wants),B=re.next();!B.done;B=re.next())H.push_back(B.value);re=T.h.PacketListener.implement({onResults:function(q){return U(T,function ee(){var ue=this,ye,_e,fe,ve,ie;return k(ee,function(ge){for(ye=ue,_e={},fe=0;fe<A.wants.length;++fe)_e[G[fe]]=q.get(fe);if(ve=es(ue,_e,A.outs),ie=ue.listeners[_])return ge.return(ue.F.then(function(){return ve}).then(function(Se){return U(ye,function Te(){var rt,$e,vt=this;return k(Te,function(nn){for(rt=ie(Se),$e=0;$e<A.wants.length;++$e)_e[G[$e]].delete();if(rt)return vt.F=rt,nn.return(rt);nn.g=0})})}));ge.g=0})})}}),T.i.attachMultiListener(H,re),H.delete()}n.onResults=function(T,A){this.listeners[A||"$"]=T},M("Solution",jt),M("OptionType",{NUMBER:0,BOOL:1,0:"NUMBER",1:"BOOL"});function tn(T){switch(T===void 0&&(T=0),T){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function ar(T){var A=this;T=T||{},this.g=new jt({locateFile:T.locateFile,files:function(_){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:tn(_.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","image_transformed"],outs:{image:"image_transformed",poseLandmarks:{type:"landmarks",stream:"pose_landmarks"},worldLandmarks:{type:"landmarks",stream:"world_landmarks"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{selfieMode:{type:1,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(_){return U(A,function G(){var H,re,B=this,q;return k(G,function(ee){return ee.g==1?(H=tn(_),re="third_party/mediapipe/modules/pose_landmark/"+H,y(ee,Wn(B.g,H),2)):(q=ee.h,B.g.overrideFile(re,q),ee.return(!0))})})}},smoothLandmarks:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},minDetectionConfidence:{type:0,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:0,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__poselandmarkbyroipostprocessing__ThresholdingCalculator",fieldName:"threshold"}}}})}n=ar.prototype,n.reset=function(){this.g.reset()},n.close=function(){return this.g.close(),Promise.resolve()},n.onResults=function(T){this.g.onResults(T)},n.initialize=function(){return U(this,function T(){var A=this;return k(T,function(_){return y(_,A.g.initialize(),0)})})},n.send=function(T,A){return U(this,function _(){var G=this;return k(_,function(H){return y(H,G.g.send(T,A),0)})})},n.setOptions=function(T){this.g.setOptions(T)},M("Pose",ar),M("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),M("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),M("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),M("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),M("POSE_LANDMARKS_NEUTRAL",{NOSE:0})}).call(wn);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KL=L();KL.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var dn;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(dn||(dn={}));var Ud;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(Ud||(Ud={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XL={};function Oy(n){return XL[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b(n,e,t,r,s){const a=e.inputParams[n];if(a&&a.inputIndexStart!==void 0){const i=a.inputIndexStart,u=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?i+1:a.inputIndexEnd;if(a.type==="tensor")return Lt(e.inputNames[a.inputIndexStart],t,r,s);if(a.type==="tensors")return e.inputNames.slice(i,u).map(d=>Lt(d,t,r,s));const l=Lt(e.inputNames.slice(i)[0],t,r,s),c=l.dataSync();return a.type==="number"?c[0]:gu(l.shape,c)}const o=e.attrParams[n];return o&&o.value}function Lt(n,e,t,r){const[s,a]=Kt(n);if(r!=null){const i=r.getHashTableHandleByName(s);if(i!=null)return i}const o=t.currentContextIds.find(i=>!!e[xo(s,i)]);return o!==void 0?e[xo(s,o)][a]:void 0}function YL(n,e,t){return e[xo(n,t.currentContextId)]}function Fn(n,e){const[t,r,s]=Kt(n);return[xo(t,e&&e.currentContextId),r,s]}function xo(n,e){return e?`${n}-${e}`:n}function Kt(n){const e=n.split(":");if(e.length===1)return[n,0,void 0];const t=e[0],r=e.length===3?e[1]:void 0,s=Number(e[e.length-1]);return[t,s,r]}function Ja(n,e,t){let r=b("pad",n,e,t);if(r==="explicit"){r=b("explicitPaddings",n,e,t);const s=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)s[a][0]=r[a*2],s[a][1]=r[a*2+1];return s}return r}function jn(n){return n.kept?n:pr(n)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QL=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ZL=Object.freeze(Object.defineProperty({__proto__:null,json:QL},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JL=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],eM=Object.freeze(Object.defineProperty({__proto__:null,json:JL},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tM=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],nM=Object.freeze(Object.defineProperty({__proto__:null,json:tM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rM=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],sM=Object.freeze(Object.defineProperty({__proto__:null,json:rM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aM=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],oM=Object.freeze(Object.defineProperty({__proto__:null,json:aM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iM=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],uM=Object.freeze(Object.defineProperty({__proto__:null,json:iM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cM=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],lM=Object.freeze(Object.defineProperty({__proto__:null,json:cM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pM=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],dM=Object.freeze(Object.defineProperty({__proto__:null,json:pM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hM=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],fM=Object.freeze(Object.defineProperty({__proto__:null,json:hM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mM=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],gM=Object.freeze(Object.defineProperty({__proto__:null,json:mM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yM=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],xM=Object.freeze(Object.defineProperty({__proto__:null,json:yM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bM=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],wM=Object.freeze(Object.defineProperty({__proto__:null,json:bM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vM=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],SM=Object.freeze(Object.defineProperty({__proto__:null,json:vM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $M=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],IM=Object.freeze(Object.defineProperty({__proto__:null,json:$M},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TM=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],CM=Object.freeze(Object.defineProperty({__proto__:null,json:TM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _M=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],kM=Object.freeze(Object.defineProperty({__proto__:null,json:_M},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NM=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],EM=Object.freeze(Object.defineProperty({__proto__:null,json:NM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RM=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],AM=Object.freeze(Object.defineProperty({__proto__:null,json:RM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OM=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],FM=Object.freeze(Object.defineProperty({__proto__:null,json:OM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zd{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[ZL,eM,nM,sM,oM,uM,lM,dM,fM,gM,xM,wM,SM,IM,CM,kM,EM,AM,FM],t=[].concat(...e.map(r=>r.json));this.opMappers=t.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,t={}){const r=e.node,s=[],a=[],o=[],i=r.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?s.push(m[g.name]):g.op==="Const"?a.push(m[g.name]):(g.input==null||g.input.length===0)&&o.push(m[g.name]),m),{});let u=[];const l=[];let c={},p={};t!=null&&(c=this.mapSignatureEntries(t.inputs),p=this.mapSignatureEntries(t.outputs));const d=Object.keys(i);d.forEach(m=>{const g=i[m];g.inputNames.forEach((y,x)=>{const[w,,v]=Fn(y),$=i[w];if($.outputs!=null){const C=$.outputs.indexOf(v);if(C!==-1){const k=`${w}:${C}`;g.inputNames[x]=k}}g.inputs.push($),$.children.push(g)})}),Object.keys(p).length===0?d.forEach(m=>{const g=i[m];g.children.length===0&&l.push(g)}):Object.keys(p).forEach(m=>{const[g]=Fn(m),y=i[g];y!=null&&(y.signatureKey=p[m],l.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(m=>{const[g]=Fn(m),y=i[g];y&&(y.signatureKey=c[m],u.push(y))}):u=s;let h={};e.library!=null&&e.library.function!=null&&(h=e.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const f={nodes:i,inputs:u,outputs:l,weights:a,placeholders:s,signature:t,functions:h};return o.length>0&&(f.initNodes=o),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,r)=>(t[e[r].name]=r,t),{})}mapNode(e){const t=Oy(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(r.inputParams=t.inputs.reduce((s,a)=>(s[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},s),{})),t.attrs!=null&&(r.attrParams=t.attrs.reduce((s,a)=>{const o=a.type;let i;switch(a.type){case"string":i=Zu(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Zu(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":i=ac(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=ac(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":i=ec(e.attr,a.tfName,a.defaultValue||0),i===void 0&&a.tfDeprecatedName&&(i=ec(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":i=sc(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=sc(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":i=Ju(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Ju(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":i=ic(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=ic(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":i=rc(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=rc(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":i=oc(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=oc(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":i=tc(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=tc(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":i=nc(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=nc(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":i=Gd(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Gd(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return s[a.name]={value:i,type:o},s},{})),r}mapFunction(e){const t=e.nodeDef,r=[],s=[];let a={};t!=null&&(a=t.reduce((p,d)=>(p[d.name]=this.mapNode(d),d.op==="Const"&&s.push(p[d.name]),p),{}));const o=[],i=[];e.signature.inputArg.forEach(p=>{const[d]=Fn(p.name),h={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Cp(p.type),type:"dtype"}},children:[]};h.signatureKey=p.name,o.push(h),a[d]=h}),Object.keys(a).forEach(p=>{const d=a[p];d.inputNames.forEach((h,f)=>{const[m,,g]=Fn(h),y=a[m];if(y.outputs!=null){const x=y.outputs.indexOf(g);if(x!==-1){const w=`${m}:${x}`;d.inputNames[f]=w}}d.inputs.push(y),y.children.push(d)})});const l=e.ret;e.signature.outputArg.forEach(p=>{const[d,h]=Fn(l[p.name]),f=a[d];f!=null&&(f.defaultOutput=h,i.push(f))});const c=this.mapArgsToSignature(e);return{nodes:a,inputs:o,outputs:i,weights:s,placeholders:r,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r),t),{}),outputs:e.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,e.ret),t),{})}}mapArgToTensorInfo(e,t){let r=e.name;return t!=null&&(r=t[r]),{name:r,dtype:e.type}}}function DM(n){const e=L().global;if(typeof e.atob!="undefined")return e.atob(n);if(typeof Buffer!="undefined")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Fy(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):DM(n);return e?t:t.toLowerCase()}function Zu(n,e,t,r=!1){const s=n[e];return s!=null?Fy(s.s,r):t}function Ju(n,e,t){const r=n[e];return r?r.b:t}function ec(n,e,t){const r=n[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:t;return typeof s=="number"?s:parseInt(s,10)}function Cp(n){switch(typeof n=="string"&&(n=dn[n]),n){case dn.DT_FLOAT:case dn.DT_HALF:return"float32";case dn.DT_INT32:case dn.DT_INT64:case dn.DT_INT8:case dn.DT_UINT8:return"int32";case dn.DT_BOOL:return"bool";case dn.DT_DOUBLE:return"float32";case dn.DT_STRING:return"string";default:return null}}function Gd(n,e,t){const r=n[e];return r&&r.func?r.func.name:t}function tc(n,e,t){const r=n[e];return r&&r.type?Cp(r.type):t}function nc(n,e,t){const r=n[e];return r&&r.list&&r.list.type?r.list.type.map(s=>Cp(s)):t}function Dy(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function rc(n,e,t){const r=n[e];return r&&r.shape?Dy(r.shape):t}function sc(n,e,t){const r=n[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):t}function ac(n,e,t,r=!1){const s=n[e];return s&&s.list&&s.list.s?s.list.s.map(a=>Fy(a,r)):t}function oc(n,e,t){const r=n[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>Dy(s)):t}function ic(n,e,t){const r=n[e];return r&&r.list&&r.list.b?r.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PM{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,a)=>(s[a]=this.getAttr(a),s),{}))}getInput(e){return Lt(e,this.tensorMap,this.context)}getAttr(e,t){const r=this.node.rawAttrs[e];if(r.tensor!=null)return Lt(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return ec(this.node.rawAttrs,e,t);if(r.s!=null)return Zu(this.node.rawAttrs,e,t);if(r.b!=null)return Ju(this.node.rawAttrs,e,t);if(r.shape!=null)return rc(this.node.rawAttrs,e,t);if(r.type!=null)return tc(this.node.rawAttrs,e,t);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return sc(this.node.rawAttrs,e,t);if(r.list.s!=null)return ac(this.node.rawAttrs,e,t);if(r.list.shape!=null)return oc(this.node.rawAttrs,e,t);if(r.list.b!=null)return ic(this.node.rawAttrs,e,t);if(r.list.type!=null)return nc(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nt=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:Kf,abs:hn,acos:q1,acosh:X1,add:Pe,addN:Q1,all:J1,any:tw,argMax:km,argMin:sw,asin:ow,asinh:uw,atan:lw,atan2:dw,atanh:fw,avgPool:Em,avgPool3d:Sw,basicLSTMCell:kw,batchNorm:Si,batchNorm2d:Ow,batchNorm3d:Dw,batchNorm4d:Lw,batchToSpaceND:Rm,bincount:Am,booleanMaskAsync:i2,broadcastArgs:Vw,broadcastTo:Ks,buffer:it,cast:tt,ceil:zw,clipByValue:Om,clone:pr,complex:hr,concat:xt,concat1d:jw,concat2d:Kw,concat3d:Yw,concat4d:Zw,conv1d:tv,conv2d:Ii,conv2dTranspose:sv,conv3d:ov,conv3dTranspose:lv,cos:dv,cosh:fv,cosineWindow:Ql,cumprod:gv,cumsum:xv,denseBincount:wv,depthToSpace:Sv,depthwiseConv2d:Vl,diag:Tv,dilation2d:_v,div:Me,divNoNan:Av,dot:Fv,dropout:b2,einsum:Pv,elu:Pm,enclosingPowerOfTwo:cg,equal:Dm,erf:Bv,euclideanNorm:Kv,exp:Jn,expandDims:mn,expm1:Zv,eye:Bm,fft:Xl,fill:$i,floor:Vm,floorDiv:_m,fused:F2,gather:Wm,gatherND:g2,greater:Ci,greaterEqual:Um,ifft:po,imag:xi,image:Qn,inTopKAsync:v2,irfft:sg,isFinite:oS,isInf:uS,isNaN:lS,leakyRelu:zm,less:hS,lessEqual:Gl,linalg:cC,linspace:mS,localResponseNormalization:yS,log:sa,log1p:Gm,logSigmoid:SS,logSoftmax:TS,logSumExp:jm,logicalAnd:co,logicalNot:qm,logicalOr:Km,logicalXor:RS,losses:lC,lowerBound:OS,matMul:Ge,max:fs,maxPool:Xm,maxPool3d:PS,maxPoolWithArgmax:MS,maximum:VS,mean:lo,meshgrid:US,min:Lu,minimum:jl,mirrorPad:Ym,mod:jS,moments:KS,movingAverage:c2,mul:pe,multiRNNCell:YS,multinomial:ZS,neg:Xn,norm:Ti,notEqual:Qm,oneHot:C1,ones:Dr,onesLike:t$,op:E,outerProduct:r$,pad:mr,pad1d:o$,pad2d:u$,pad3d:l$,pad4d:d$,pool:y$,pow:zl,prelu:Jm,print:om,prod:w$,raggedGather:S$,raggedTensorToTensor:I$,rand:C$,randomGamma:z$,randomNormal:eg,randomStandardNormal:j$,randomUniform:tg,range:aa,real:na,reciprocal:X$,relu:_i,relu6:ng,reshape:z,reverse:Gr,reverse1d:eI,reverse2d:nI,reverse3d:sI,reverse4d:oI,rfft:Yl,round:rg,rsqrt:cI,scalar:Re,scatterND:p2,searchSorted:Hl,selu:pI,separableConv2d:hI,setdiff1dAsync:mI,sigmoid:Yn,sign:yI,signal:uC,sin:bI,sinh:vI,slice:Ie,slice1d:$I,slice2d:TI,slice3d:_I,slice4d:NI,softmax:RI,softplus:Hm,spaceToBatchND:Zm,sparse:pC,sparseToDense:f2,spectral:iC,split:oa,sqrt:Mu,square:va,squaredDifference:ag,squeeze:ze,stack:tr,step:og,stridedSlice:UI,string:dC,sub:ke,sum:Ye,tan:GI,tanh:Pu,tensor:Dn,tensor1d:Mt,tensor2d:vn,tensor3d:mm,tensor4d:HI,tensor5d:jI,tensor6d:qI,tile:Xs,topk:XI,transpose:Ou,truncatedNormal:QI,unique:JI,unsortedSegmentSum:t2,unstack:Yr,upperBound:r2,variable:s2,where:vs,whereAsync:ug,zeros:fr,zerosLike:Wl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LM=(n,e,t,r=Nt)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(b("a",n,e,t),b("b",n,e,t))];case"AddN":return[r.addN(b("tensors",n,e,t))];case"FloorMod":case"Mod":return[r.mod(b("a",n,e,t),b("b",n,e,t))];case"Mul":return[r.mul(b("a",n,e,t),b("b",n,e,t))];case"RealDiv":case"Div":return[r.div(b("a",n,e,t),b("b",n,e,t))];case"DivNoNan":return[r.divNoNan(b("a",n,e,t),b("b",n,e,t))];case"FloorDiv":return[r.floorDiv(b("a",n,e,t),b("b",n,e,t))];case"Sub":return[r.sub(b("a",n,e,t),b("b",n,e,t))];case"Minimum":return[r.minimum(b("a",n,e,t),b("b",n,e,t))];case"Maximum":return[r.maximum(b("a",n,e,t),b("b",n,e,t))];case"Pow":return[r.pow(b("a",n,e,t),b("b",n,e,t))];case"SquaredDifference":return[r.squaredDifference(b("a",n,e,t),b("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MM=(n,e,t,r=Nt)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(b("x",n,e,t))];case"Acos":return[r.acos(b("x",n,e,t))];case"Acosh":return[r.acosh(b("x",n,e,t))];case"Asin":return[r.asin(b("x",n,e,t))];case"Asinh":return[r.asinh(b("x",n,e,t))];case"Atan":return[r.atan(b("x",n,e,t))];case"Atan2":return[r.atan2(b("x",n,e,t),b("y",n,e,t))];case"Atanh":return[r.atanh(b("x",n,e,t))];case"Ceil":return[r.ceil(b("x",n,e,t))];case"Complex":return[r.complex(b("real",n,e,t),b("imag",n,e,t))];case"Cos":return[r.cos(b("x",n,e,t))];case"Cosh":return[r.cosh(b("x",n,e,t))];case"Elu":return[r.elu(b("x",n,e,t))];case"Erf":return[r.erf(b("x",n,e,t))];case"Exp":return[r.exp(b("x",n,e,t))];case"Expm1":return[r.expm1(b("x",n,e,t))];case"Floor":return[r.floor(b("x",n,e,t))];case"Log":return[r.log(b("x",n,e,t))];case"Log1p":return[r.log1p(b("x",n,e,t))];case"Imag":return[r.imag(b("x",n,e,t))];case"Neg":return[r.neg(b("x",n,e,t))];case"Reciprocal":return[r.reciprocal(b("x",n,e,t))];case"Real":return[r.real(b("x",n,e,t))];case"Relu":return[r.relu(b("x",n,e,t))];case"Round":return[r.round(b("x",n,e,t))];case"Selu":return[r.selu(b("x",n,e,t))];case"Sigmoid":return[r.sigmoid(b("x",n,e,t))];case"Sin":return[r.sin(b("x",n,e,t))];case"Sign":return[r.sign(b("x",n,e,t))];case"Sinh":return[r.sinh(b("x",n,e,t))];case"Softplus":return[r.softplus(b("x",n,e,t))];case"Sqrt":return[r.sqrt(b("x",n,e,t))];case"Square":return[r.square(b("x",n,e,t))];case"Tanh":return[r.tanh(b("x",n,e,t))];case"Tan":return[r.tan(b("x",n,e,t))];case"ClipByValue":return[r.clipByValue(b("x",n,e,t),b("clipValueMin",n,e,t),b("clipValueMax",n,e,t))];case"Relu6":return[r.relu6(b("x",n,e,t))];case"Rsqrt":return[r.rsqrt(Lt(n.inputNames[0],e,t))];case"Prod":return[r.prod(b("x",n,e,t),b("axes",n,e,t))];case"LeakyRelu":return[r.leakyRelu(b("x",n,e,t),b("alpha",n,e,t))];case"Prelu":return[r.prelu(b("x",n,e,t),b("alpha",n,e,t))];case"IsNan":return[r.isNaN(Lt(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fn(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){I(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let r=0;r<n.length;r++){const s=n[r],a=e[r];I(s<0||a<0||s===a,()=>t+` Shapes ${n} and ${e} must match`)}}}function Hd(n){return!(typeof n=="number"||n.some(e=>e<0))}function Ws(n,e,t){let r=uc(n,t);const s=!Hd(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(a=>{r=uc(a.shape,r)}),!Hd(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function uc(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let r=0;r<n.length;++r){const s=n[r],a=e[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[r]=s>=0?s:a}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BM{constructor(e,t,r,s,a,o,i){this.name=e,this.dtype=t,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=a,this.dynamicSize=o,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=Re(0),ur(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),fn(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=t,ur(t),r.written=!0,this.tensors[e]=r}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((r,s)=>this.write(r,t[s]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return Dn([],[0].concat(this.elementShape));const r=this.readMany(e);return fn(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),tr(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Dn([],[0].concat(this.elementShape));const t=[];for(let s=0;s<this.size();s++)t.push(s);const r=this.readMany(t);return fn(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),xt(r,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,Yr(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0;const s=e.map(u=>(r+=u,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const a=r===0?0:t.size/r,o=[];Be(()=>{t=z(t,[1,r,a]);for(let u=0;u<e.length;++u){const c=[0,u===0?0:s[u-1],0],p=[1,e[u],a];o[u]=z(Ie(t,c,p),this.elementShape)}return o});const i=[];for(let u=0;u<e.length;u++)i[u]=u;this.writeMany(i,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hr{constructor(e,t,r,s=-1){this.tensors=e,this.elementShape=t,this.elementDtype=r,e!=null&&e.forEach(a=>{if(r!==a.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${a.dtype}`);fn(t,a.shape,"TensorList shape mismatch: "),ur(a)}),this.idTensor=Re(0),this.maxNumElements=s,ur(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Hr([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,r=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);fn(e,this.elementShape,"TensorList shape mismatch: ");const s=Ws(this.elementShape,this.tensors,e);return Be(()=>{const a=this.tensors.map(o=>z(o,s));return tr(a,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=Ws(this.elementShape,this.tensors,e),s=this.tensors.pop();return s.kept=!1,fn(s.shape,e,"TensorList shape mismatch: "),z(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(fn(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ur(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Hr([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)t.tensors[r]=this.tensors[r];return t}getItem(e,t,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);fn(this.tensors[e].shape,t,"TensorList shape mismatch: ");const s=Ws(this.elementShape,this.tensors,t);return z(this.tensors[e],s)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);fn(this.elementShape,t.shape,"TensorList shape mismatch: "),ur(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,r){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);fn(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=Ws(this.elementShape,this.tensors,r);return e.length===0?Dn([],[0].concat(s)):Be(()=>{const a=e.map(o=>z(this.tensors[o],s));return tr(a,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);fn(this.elementShape,t,"TensorList shape mismatch: ");const r=Ws(this.elementShape,this.tensors,t);return this.size()===0?Dn([],[0].concat(r)):Be(()=>{const s=this.tensors.map(a=>z(a,r));return xt(s,0)})}}function VM(n,e,t){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const s=n.shape.slice(1);fn(s,e,"TensorList shape mismatch: ");const a=Yr(n);return new Hr(a,e,r)}function WM(n,e,t,r){return new Hr([],n,e,r)}function UM(n,e,t,r){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new Hr([],t,n.dtype,r),o=Yr(n,0);return e.forEach((i,u)=>{a.setItem(i,o[u])}),a}function zM(n,e,t){let r=0;const s=e.map(c=>(r+=c,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);const a=n.shape.slice(1),o=uc(a,t),i=r===0?0:n.size/r,u=Be(()=>{const c=[];n=z(n,[1,r,i]);for(let p=0;p<e.length;++p){const h=[0,p===0?0:s[p-1],0],f=[1,e[p],i];c[p]=z(Ie(n,h,f),o)}return n.dispose(),c}),l=new Hr([],t,n.dtype,e.length);for(let c=0;c<u.length;c++)l.setItem(c,u[c]);return l}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GM=(n,e,t)=>se(void 0,null,function*(){switch(n.op){case"If":case"StatelessIf":{const r=b("thenBranch",n,e,t),s=b("elseBranch",n,e,t),a=b("cond",n,e,t),o=b("args",n,e,t);return(yield a.data())[0]?t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const r=b("body",n,e,t),s=b("cond",n,e,t),a=b("args",n,e,t),o=yield t.functionMap[s].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap),i=a.map(c=>c.id);let u=yield o[0].data();o.forEach(c=>{!c.kept&&i.indexOf(c.id)===-1&&c.dispose()});let l=a;for(;u[0];){const c=l;l=yield t.functionMap[r].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);const p=l.map(h=>h.id);c.forEach(h=>{!h.kept&&i.indexOf(h.id)===-1&&p.indexOf(h.id)===-1&&h.dispose()});const d=yield t.functionMap[s].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);u=yield d[0].data(),d.forEach(h=>{!h.kept&&i.indexOf(h.id)===-1&&p.indexOf(h.id)===-1&&h.dispose()})}return l}case"LoopCond":{const r=b("pred",n,e,t);return[jn(r)]}case"Switch":{const r=b("pred",n,e,t);let s=b("data",n,e,t);return s.kept||(s=jn(s)),(yield r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=n.inputNames.find(s=>Lt(s,e,t)!==void 0);if(r){const s=Lt(r,e,t);return[jn(s)]}return}case"Enter":{const r=b("frameName",n,e,t),s=b("tensor",n,e,t);return t.enterFrame(r),[jn(s)]}case"Exit":{const r=b("tensor",n,e,t);return t.exitFrame(),[jn(r)]}case"NextIteration":{const r=b("tensor",n,e,t);return t.nextIteration(),[jn(r)]}case"TensorArrayV3":{const r=b("size",n,e,t),s=b("dtype",n,e,t),a=b("elementShape",n,e,t),o=b("dynamicSize",n,e,t),i=b("clearAfterRead",n,e,t),u=b("identicalElementShapes",n,e,t),l=b("name",n,e,t),c=new BM(l,s,r,a,u,o,i);return t.addTensorArray(c),[c.idTensor,Re(1)]}case"TensorArrayWriteV3":{const r=b("tensorArrayId",n,e,t),s=b("index",n,e,t),a=b("tensor",n,e,t),o=t.getTensorArray(r.id);return o.write(s,a),[o.idTensor]}case"TensorArrayReadV3":{const r=b("tensorArrayId",n,e,t),s=b("index",n,e,t);return[t.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=b("tensorArrayId",n,e,t),s=b("indices",n,e,t),a=b("dtype",n,e,t);return[t.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{const r=b("tensorArrayId",n,e,t),s=b("indices",n,e,t),a=b("tensor",n,e,t),o=t.getTensorArray(r.id);return o.scatter(s,a),[o.idTensor]}case"TensorArrayConcatV3":{const r=b("tensorArrayId",n,e,t),s=t.getTensorArray(r.id),a=b("dtype",n,e,t);return[s.concat(a)]}case"TensorArraySplitV3":{const r=b("tensorArrayId",n,e,t),s=b("tensor",n,e,t),a=b("lengths",n,e,t),o=t.getTensorArray(r.id);return o.split(a,s),[o.idTensor]}case"TensorArraySizeV3":{const r=b("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return[Re(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=b("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=b("tensorListId",n,e,t),s=b("index",n,e,t),a=b("tensor",n,e,t),o=t.getTensorList(r.id);return o.setItem(s,a),[o.idTensor]}case"TensorListGetItem":{const r=b("tensorListId",n,e,t),s=b("index",n,e,t),a=b("elementShape",n,e,t),o=b("elementDType",n,e,t);return[t.getTensorList(r.id).getItem(s,a,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=b("indices",n,e,t),s=b("tensor",n,e,t),a=b("elementShape",n,e,t),o=b("numElements",n,e,t),i=UM(s,r,a,o);return t.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=b("elementShape",n,e,t),s=b("elementDType",n,e,t);let a;n.op==="TensorListReserve"?a="numElements":a="maxNumElements";const o=b(a,n,e,t),i=n.op==="TensorListReserve"?-1:o,u=WM(r,s,o,i);return t.addTensorList(u),[u.idTensor]}case"TensorListGather":{const r=b("tensorListId",n,e,t),s=b("indices",n,e,t),a=b("elementShape",n,e,t),o=b("elementDType",n,e,t);return[t.getTensorList(r.id).gather(s,o,a)]}case"TensorListStack":{const r=b("tensorListId",n,e,t),s=b("elementShape",n,e,t),a=b("elementDType",n,e,t),o=b("numElements",n,e,t);return[t.getTensorList(r.id).stack(s,a,o)]}case"TensorListFromTensor":{const r=b("tensor",n,e,t),s=b("elementShape",n,e,t),a=b("elementDType",n,e,t),o=VM(r,s,a);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=b("tensorListId",n,e,t),s=t.getTensorList(r.id),a=b("dtype",n,e,t),o=b("elementShape",n,e,t);return[s.concat(a,o)]}case"TensorListPushBack":{const r=b("tensorListId",n,e,t),s=b("tensor",n,e,t),a=t.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=b("tensorListId",n,e,t),s=b("elementShape",n,e,t),a=b("elementDType",n,e,t);return[t.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{const r=b("tensor",n,e,t),s=b("elementShape",n,e,t),a=b("lengths",n,e,t),o=zM(r,a,s);return t.addTensorList(o),[o.idTensor]}case"TensorListLength":{const r=b("tensorListId",n,e,t),s=t.getTensorList(r.id);return[Re(s.size(),"int32")]}case"TensorListResize":{const r=b("tensorListId",n,e,t),s=b("size",n,e,t),o=t.getTensorList(r.id).resize(s);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jd(n,e,t){const[r,s]=b("fusedOps",n,e,t),a=r==="biasadd",o=!a,i=s==="prelu",u=r==="fusedbatchnorm",l=b("numArgs",n,e,t);if(a){if(i&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&a&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=b("strides",n,e,t),p=Ja(n,e,t),d=b("dataFormat",n,e,t).toUpperCase(),h=b("dilations",n,e,t);let[f,m]=b("args",n,e,t);o&&(m=f,f=void 0);const g=b("leakyreluAlpha",n,e,t);return{stride:c,pad:p,dataFormat:d,dilations:h,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:g}}const HM=(n,e,t,r=Nt)=>{switch(n.op){case"Conv1D":{const s=b("stride",n,e,t),a=b("pad",n,e,t),o=b("dataFormat",n,e,t).toUpperCase(),i=b("dilation",n,e,t);return[r.conv1d(b("x",n,e,t),b("filter",n,e,t),s,a,o,i)]}case"Conv2D":{const s=b("strides",n,e,t),a=Ja(n,e,t),o=b("dataFormat",n,e,t).toUpperCase(),i=b("dilations",n,e,t);return[r.conv2d(b("x",n,e,t),b("filter",n,e,t),[s[1],s[2]],a,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:s,pad:a,dataFormat:o,dilations:i,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:p}=jd(n,e,t);return[r.fused.conv2d({x:b("x",n,e,t),filter:b("filter",n,e,t),strides:[s[1],s[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:a,dataFormat:o,dilations:i,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:p}=jd(n,e,t);return[r.fused.depthwiseConv2d({x:b("x",n,e,t),filter:b("filter",n,e,t),strides:[s[1],s[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=b("outputShape",n,e,t),a=b("strides",n,e,t),o=Ja(n,e,t);return[r.conv2dTranspose(b("x",n,e,t),b("filter",n,e,t),s,[a[1],a[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=b("strides",n,e,t),a=Ja(n,e,t),o=b("dilations",n,e,t),i=b("dataFormat",n,e,t).toUpperCase();return[r.depthwiseConv2d(b("input",n,e,t),b("filter",n,e,t),[s[1],s[2]],a,i,[o[1],o[2]])]}case"Conv3D":{const s=b("strides",n,e,t),a=b("pad",n,e,t),o=b("dataFormat",n,e,t).toUpperCase(),i=b("dilations",n,e,t);return[r.conv3d(b("x",n,e,t),b("filter",n,e,t),[s[1],s[2],s[3]],a,o,[i[1],i[2],i[3]])]}case"AvgPool":{const s=b("strides",n,e,t),a=b("pad",n,e,t),o=b("kernelSize",n,e,t);return[r.avgPool(b("x",n,e,t),[o[1],o[2]],[s[1],s[2]],a)]}case"MaxPool":{const s=b("strides",n,e,t),a=b("pad",n,e,t),o=b("kernelSize",n,e,t);return[r.maxPool(b("x",n,e,t),[o[1],o[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{const s=b("strides",n,e,t),a=b("pad",n,e,t),o=b("kernelSize",n,e,t),i=b("includeBatchInIndex",n,e,t),{result:u,indexes:l}=r.maxPoolWithArgmax(b("x",n,e,t),[o[1],o[2]],[s[1],s[2]],a,i);return[u,l]}case"AvgPool3D":{const s=b("strides",n,e,t),a=b("pad",n,e,t),o=b("kernelSize",n,e,t);return[r.avgPool3d(b("x",n,e,t),[o[1],o[2],o[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{const s=b("strides",n,e,t),a=b("pad",n,e,t),o=b("kernelSize",n,e,t);return[r.maxPool3d(b("x",n,e,t),[o[1],o[2],o[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{const s=b("strides",n,e,t),a=b("pad",n,e,t),o=b("dilations",n,e,t),i=s[1],u=s[2],l=o[1],c=o[2];return[r.dilation2d(b("x",n,e,t),b("filter",n,e,t),[i,u],a,[l,c],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jM=(n,e,t,r=Nt)=>{switch(n.op){case"Fill":{const s=b("shape",n,e,t),a=b("dtype",n,e,t),o=b("value",n,e,t);return[r.fill(s,o,a)]}case"LinSpace":{const s=b("start",n,e,t),a=b("stop",n,e,t),o=b("num",n,e,t);return[r.linspace(s,a,o)]}case"Multinomial":{const s=b("logits",n,e,t),a=b("numSamples",n,e,t),o=b("seed",n,e,t);return[r.multinomial(s,a,o)]}case"OneHot":{const s=b("indices",n,e,t),a=b("depth",n,e,t),o=b("onValue",n,e,t),i=b("offValue",n,e,t),u=b("dtype",n,e,t);return[r.oneHot(s,a,o,i,u)]}case"Ones":return[r.ones(b("shape",n,e,t),b("dtype",n,e,t))];case"OnesLike":return[r.onesLike(b("x",n,e,t))];case"RandomStandardNormal":return[r.randomStandardNormal(b("shape",n,e,t),b("dtype",n,e,t),b("seed",n,e,t))];case"RandomUniform":return[r.randomUniform(b("shape",n,e,t),b("minval",n,e,t),b("maxval",n,e,t),b("dtype",n,e,t))];case"Range":{const s=b("start",n,e,t),a=b("stop",n,e,t),o=b("step",n,e,t);return[r.range(s,a,o,b("dtype",n,e,t))]}case"TruncatedNormal":{const s=b("shape",n,e,t),a=b("mean",n,e,t),o=b("stdDev",n,e,t),i=b("seed",n,e,t);return[r.truncatedNormal(s,a,o,b("dtype",n,e,t),i)]}case"Zeros":return[r.zeros(b("shape",n,e,t),b("dtype",n,e,t))];case"ZerosLike":return[r.zerosLike(b("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function su(n,e,t){const r=b("boxes",n,e,t),s=b("scores",n,e,t),a=b("maxOutputSize",n,e,t),o=b("iouThreshold",n,e,t),i=b("scoreThreshold",n,e,t),u=b("softNmsSigma",n,e,t);return{boxes:r,scores:s,maxOutputSize:a,iouThreshold:o,scoreThreshold:i,softNmsSigma:u}}const qM=(a,o,i,u,...l)=>se(void 0,[a,o,i,u,...l],function*(n,e,t,r,s=Nt){switch(n.op){case"NonMaxSuppressionV5":{const{boxes:c,scores:p,maxOutputSize:d,iouThreshold:h,scoreThreshold:f,softNmsSigma:m}=su(n,e,t),g=yield s.image.nonMaxSuppressionWithScoreAsync(c,p,d,h,f,m);return[g.selectedIndices,g.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:c,scores:p,maxOutputSize:d,iouThreshold:h,scoreThreshold:f}=su(n,e,t),m=b("padToMaxOutputSize",n,e,t),g=yield s.image.nonMaxSuppressionPaddedAsync(c,p,d,h,f,m);return[g.selectedIndices,g.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:c,scores:p,maxOutputSize:d,iouThreshold:h,scoreThreshold:f}=su(n,e,t);return[yield s.image.nonMaxSuppressionAsync(c,p,d,h,f)]}case"Where":{const c=s.cast(b("condition",n,e,t),"bool"),p=[yield s.whereAsync(c)];return c.dispose(),p}case"ListDiff":return s.setdiff1dAsync(b("x",n,e,t),b("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KM=(n,e,t,r=Nt)=>{switch(n.op){case"LowerBound":{const s=b("sortedSequence",n,e,t),a=b("values",n,e,t);return[r.lowerBound(s,a)]}case"TopKV2":{const s=b("x",n,e,t),a=b("k",n,e,t),o=b("sorted",n,e,t),i=r.topk(s,a,o);return[i.values,i.indices]}case"UpperBound":{const s=b("sortedSequence",n,e,t),a=b("values",n,e,t);return[r.upperBound(s,a)]}case"Unique":{const s=b("x",n,e,t),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{const s=b("x",n,e,t),a=b("axis",n,e,t),o=r.unique(s,a);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XM=(n,e,t,r=Nt)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const s=b("default",n,e,t);return[Lt(n.name,e,t)||s];case"Placeholder":return[Lt(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=b("x",n,e,t);return[jn(c)]}case"IdentityN":return b("x",n,e,t).map(c=>jn(c));case"Snapshot":const a=b("x",n,e,t);return[jn(a)];case"Shape":return[r.tensor1d(b("x",n,e,t).shape,"int32")];case"ShapeN":return b("x",n,e,t).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(b("x",n,e,t).size,"int32")];case"Rank":return[r.scalar(b("x",n,e,t).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=b("x",n,e,t),i=b("data",n,e,t),u=b("message",n,e,t),l=b("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let c=0;c<i.length;c++)console.log(Array.prototype.slice.call(i[c].dataSync()).slice(0,l));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YM{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Re(0),this.tensorMap=new Map,ur(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Re(this.size(),"int32")}import(e,t){return se(this,null,function*(){this.checkKeyAndValueTensor(e,t);const r=yield e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),Be(()=>{const s=Yr(t),a=r.length,o=s.length;I(a===o,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${o} elements.`);for(let i=0;i<a;i++){const u=r[i],l=s[i];ur(l),this.tensorMap.set(u,l)}return this.handle})})}find(e,t){return se(this,null,function*(){this.checkKeyAndValueTensor(e,t);const r=yield e.data();return Be(()=>{const s=[];for(let a=0;a<r.length;a++){const o=r[a],i=this.findWithDefault(o,t);s.push(i)}return tr(s)})})}findWithDefault(e,t){const r=this.tensorMap.get(e);return r!=null?r:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QM=(n,e,t,r)=>se(void 0,null,function*(){switch(n.op){case"HashTable":case"HashTableV2":{const s=b("keyDType",n,e,t),a=b("valueDType",n,e,t),o=new YM(s,a);return r.addHashTable(n.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=b("tableHandle",n,e,t,r),a=b("keys",n,e,t),o=b("values",n,e,t);return[yield r.getHashTableById(s.id).import(a,o)]}case"LookupTableFind":case"LookupTableFindV2":{const s=b("tableHandle",n,e,t,r),a=b("keys",n,e,t),o=b("defaultValue",n,e,t);return[yield r.getHashTableById(s.id).find(a,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=b("tableHandle",n,e,t,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZM=(n,e,t,r=Nt)=>{switch(n.op){case"ResizeBilinear":{const s=b("images",n,e,t),a=b("size",n,e,t),o=b("alignCorners",n,e,t),i=b("halfPixelCenters",n,e,t);return[r.image.resizeBilinear(s,[a[0],a[1]],o,i)]}case"ResizeNearestNeighbor":{const s=b("images",n,e,t),a=b("size",n,e,t),o=b("alignCorners",n,e,t),i=b("halfPixelCenters",n,e,t);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],o,i)]}case"CropAndResize":{const s=b("image",n,e,t),a=b("boxes",n,e,t),o=b("boxInd",n,e,t),i=b("cropSize",n,e,t),u=b("method",n,e,t),l=b("extrapolationValue",n,e,t);return[r.image.cropAndResize(s,a,o,i,u,l)]}case"ImageProjectiveTransformV3":{const s=b("images",n,e,t),a=b("transforms",n,e,t),o=b("outputShape",n,e,t),i=b("fillValue",n,e,t),u=b("interpolation",n,e,t),l=b("fillMode",n,e,t);return[r.image.transform(s,a,u.toLowerCase(),l.toLowerCase(),i,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JM=(n,e,t,r=Nt)=>{switch(n.op){case"Equal":return[r.equal(b("a",n,e,t),b("b",n,e,t))];case"NotEqual":return[r.notEqual(b("a",n,e,t),b("b",n,e,t))];case"Greater":return[r.greater(b("a",n,e,t),b("b",n,e,t))];case"GreaterEqual":return[r.greaterEqual(b("a",n,e,t),b("b",n,e,t))];case"Less":return[r.less(b("a",n,e,t),b("b",n,e,t))];case"LessEqual":return[r.lessEqual(b("a",n,e,t),b("b",n,e,t))];case"LogicalAnd":return[r.logicalAnd(b("a",n,e,t),b("b",n,e,t))];case"LogicalNot":return[r.logicalNot(b("a",n,e,t))];case"LogicalOr":return[r.logicalOr(b("a",n,e,t),b("b",n,e,t))];case"Select":case"SelectV2":return[r.where(b("condition",n,e,t),b("a",n,e,t),b("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eB=(n,e,t,r=Nt)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(b("a",n,e,t),b("b",n,e,t),b("transposeA",n,e,t),b("transposeB",n,e,t))];case"Einsum":return[r.einsum(b("equation",n,e,t),...b("tensors",n,e,t))];case"Transpose":return[r.transpose(b("x",n,e,t),b("perm",n,e,t))];case"_FusedMatMul":const[s,a]=b("fusedOps",n,e,t),o=s==="biasadd",i=a==="prelu",u=b("numArgs",n,e,t),l=b("leakyreluAlpha",n,e,t);if(o){if(i&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,p]=b("args",n,e,t);return[r.fused.matMul({a:b("a",n,e,t),b:b("b",n,e,t),transposeA:b("transposeA",n,e,t),transposeB:b("transposeB",n,e,t),bias:c,activation:a,preluActivationWeights:p,leakyreluAlpha:l})];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tB=(n,e,t,r=Nt)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(b("x",n,e,t),b("axis",n,e,t),b("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(b("x",n,e,t),b("mean",n,e,t),b("variance",n,e,t),b("offset",n,e,t),b("scale",n,e,t),b("epsilon",n,e,t))];case"FusedBatchNormV3":return[r.batchNorm(b("x",n,e,t),b("mean",n,e,t),b("variance",n,e,t),b("offset",n,e,t),b("scale",n,e,t),b("epsilon",n,e,t))];case"LRN":return[r.localResponseNormalization(b("x",n,e,t),b("radius",n,e,t),b("bias",n,e,t),b("alpha",n,e,t),b("beta",n,e,t))];case"Softmax":return[r.softmax(b("x",n,e,t))];case"LogSoftmax":return[r.logSoftmax(b("x",n,e,t))];case"SparseToDense":return[r.sparseToDense(b("sparseIndices",n,e,t),b("outputShape",n,e,t),b("sparseValues",n,e,t),b("defaultValue",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nB=(n,e,t,r=Nt)=>{switch(n.op){case"Max":{const i=b("axis",n,e,t),u=b("keepDims",n,e,t);return[r.max(b("x",n,e,t),i,u)]}case"Mean":{const i=b("axis",n,e,t),u=b("keepDims",n,e,t);return[r.mean(b("x",n,e,t),i,u)]}case"Min":{const i=b("axis",n,e,t),u=b("keepDims",n,e,t);return[r.min(b("x",n,e,t),i,u)]}case"Sum":{const i=b("axis",n,e,t),u=b("keepDims",n,e,t);return[r.sum(b("x",n,e,t),i,u)]}case"All":{const i=b("axis",n,e,t),u=b("keepDims",n,e,t);return[r.all(b("x",n,e,t),i,u)]}case"Any":{const i=b("axis",n,e,t),u=b("keepDims",n,e,t);return[r.any(b("x",n,e,t),i,u)]}case"ArgMax":{const i=b("axis",n,e,t);return[r.argMax(b("x",n,e,t),i)]}case"ArgMin":{const i=b("axis",n,e,t);return[r.argMin(b("x",n,e,t),i)]}case"Prod":{const i=b("axis",n,e,t),u=b("keepDims",n,e,t);return[r.prod(b("x",n,e,t),i,u)]}case"Cumprod":{const i=b("axis",n,e,t),u=b("exclusive",n,e,t),l=b("reverse",n,e,t);return[r.cumprod(b("x",n,e,t),i,u,l)]}case"Cumsum":{const i=b("axis",n,e,t),u=b("exclusive",n,e,t),l=b("reverse",n,e,t);return[r.cumsum(b("x",n,e,t),i,u,l)]}case"Bincount":const s=b("x",n,e,t),a=b("weights",n,e,t),o=b("size",n,e,t);return[r.bincount(s,a,o)];case"DenseBincount":{const i=b("x",n,e,t),u=b("weights",n,e,t),l=b("size",n,e,t),c=b("binaryOutput",n,e,t);return[r.denseBincount(i,u,l,c)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rB=(n,e,t,r=Nt)=>{switch(n.op){case"ConcatV2":case"Concat":{const s=b("n",n,e,t),a=b("axis",n,e,t);let o=b("tensors",n,e,t);return o=o.slice(0,s),[r.concat(o,a)]}case"Gather":{const s=b("x",n,e,t),a=b("indices",n,e,t);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{const s=b("axis",n,e,t),a=b("batchDims",n,e,t),o=b("x",n,e,t),i=b("indices",n,e,t);return[r.gather(o,r.cast(i,"int32"),s,a)]}case"Reverse":{const s=b("dims",n,e,t),a=[];for(let i=0;i<s.length;i++)s[i]&&a.push(i);const o=b("x",n,e,t);return[r.reverse(o,a)]}case"ReverseV2":{const s=b("axis",n,e,t),a=b("x",n,e,t);return[r.reverse(a,s)]}case"Slice":{const s=b("begin",n,e,t),a=b("size",n,e,t);return[r.slice(b("x",n,e,t),s,a)]}case"StridedSlice":{const s=b("begin",n,e,t),a=b("end",n,e,t),o=b("strides",n,e,t),i=b("beginMask",n,e,t),u=b("endMask",n,e,t),l=b("ellipsisMask",n,e,t),c=b("newAxisMask",n,e,t),p=b("shrinkAxisMask",n,e,t),d=b("x",n,e,t);return[r.stridedSlice(d,s,a,o,i,u,l,c,p)]}case"Pack":return Be(()=>{const s=b("axis",n,e,t),a=b("tensors",n,e,t),o=a[0].shape,i=r.squeeze(a[0]).shape,u=a.map(l=>{const c=pt(l.shape,o);if(!c&&!pt(r.squeeze(l).shape,i))throw new Error("the input tensors shape does not match");return c?l:r.reshape(l,o)});return[r.stack(u,s)]});case"Unpack":{const s=b("axis",n,e,t),a=b("tensor",n,e,t);return r.unstack(a,s)}case"Tile":{const s=b("reps",n,e,t);return[r.tile(b("x",n,e,t),s)]}case"Split":case"SplitV":{const s=b("axis",n,e,t),a=b("numOrSizeSplits",n,e,t),o=b("x",n,e,t);return r.split(o,a,s)}case"ScatterNd":{const s=b("indices",n,e,t),a=b("values",n,e,t),o=b("shape",n,e,t);return[r.scatterND(s,a,o)]}case"GatherNd":{const s=b("x",n,e,t),a=b("indices",n,e,t);return[r.gatherND(s,a)]}case"SparseToDense":{const s=b("sparseIndices",n,e,t),a=b("outputShape",n,e,t),o=b("sparseValues",n,e,t),i=b("defaultValue",n,e,t);return[r.sparseToDense(s,o,a,o.dtype===i.dtype?i:r.cast(i,o.dtype))]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sB=(n,e,t,r=Nt)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:o,reverseIndexMap:i}=r.sparse.sparseFillEmptyRows(b("indices",n,e,t),b("values",n,e,t),b("denseShape",n,e,t),b("defaultValue",n,e,t));return[s,a,o,i]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(b("inputIndices",n,e,t),b("inputShape",n,e,t),b("newShape",n,e,t));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(b("data",n,e,t),b("indices",n,e,t),b("segmentIds",n,e,t))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(b("data",n,e,t),b("indices",n,e,t),b("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aB=(n,e,t,r=Nt)=>{switch(n.op){case"FFT":return[r.fft(b("x",n,e,t))];case"IFFT":return[r.ifft(b("x",n,e,t))];case"RFFT":return[r.rfft(b("x",n,e,t))];case"IRFFT":return[r.irfft(b("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oB=(n,e,t,r=Nt)=>{switch(n.op){case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(b("data",n,e,t),b("dataSplits",n,e,t),b("separator",n,e,t),b("nGramWidths",n,e,t),b("leftPad",n,e,t),b("rightPad",n,e,t),b("padWidth",n,e,t),b("preserveShortSequences",n,e,t));return[s,a]}case"StringSplit":{const{indices:s,values:a,shape:o}=r.string.stringSplit(b("input",n,e,t),b("delimiter",n,e,t),b("skipEmpty",n,e,t));return[s,a,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(b("input",n,e,t),b("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iB=(n,e,t,r=Nt)=>{switch(n.op){case"Cast":return[r.cast(b("x",n,e,t),b("dtype",n,e,t))];case"ExpandDims":{const s=b("axis",n,e,t);return[r.expandDims(b("x",n,e,t),s)]}case"Squeeze":{const s=b("axis",n,e,t);return[r.squeeze(b("x",n,e,t),s)]}case"Reshape":return[r.reshape(b("x",n,e,t),b("shape",n,e,t))];case"MirrorPad":return[r.mirrorPad(b("x",n,e,t),b("padding",n,e,t),b("mode",n,e,t))];case"PadV2":case"Pad":return[r.pad(b("x",n,e,t),b("padding",n,e,t),b("constantValue",n,e,t))];case"SpaceToBatchND":{const s=b("blockShape",n,e,t),a=b("paddings",n,e,t);return[r.spaceToBatchND(b("x",n,e,t),s,a)]}case"BatchToSpaceND":{const s=b("blockShape",n,e,t),a=b("crops",n,e,t);return[r.batchToSpaceND(b("x",n,e,t),s,a)]}case"DepthToSpace":{const s=b("blockSize",n,e,t),a=b("dataFormat",n,e,t).toUpperCase();return[r.depthToSpace(b("x",n,e,t),s,a)]}case"BroadcastTo":return[r.broadcastTo(b("x",n,e,t),b("shape",n,e,t))];case"BroadcastArgs":return[r.broadcastArgs(b("s0",n,e,t),b("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qd(n,e,t,r,s=Be){const a=((o,i,u)=>{switch(o.category){case"arithmetic":return s(()=>LM(o,i,u));case"basic_math":return s(()=>MM(o,i,u));case"control":return GM(o,i,u);case"convolution":return s(()=>HM(o,i,u));case"creation":return s(()=>jM(o,i,u));case"dynamic":return qM(o,i,u);case"evaluation":return s(()=>KM(o,i,u));case"image":return s(()=>ZM(o,i,u));case"graph":return s(()=>XM(o,i,u));case"logical":return s(()=>JM(o,i,u));case"matrices":return s(()=>eB(o,i,u));case"normalization":return s(()=>tB(o,i,u));case"reduction":return s(()=>nB(o,i,u));case"slice_join":return s(()=>rB(o,i,u));case"sparse":return s(()=>sB(o,i,u));case"spectral":return s(()=>aB(o,i,u));case"string":return s(()=>oB(o,i,u));case"transformation":return s(()=>iB(o,i,u));case"hash_table":return QM(o,i,u,r);case"custom":const l=Oy(o.op);if(l&&l.customExecutor)return l.customExecutor(new PM(o,i,u));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return ys(a)?a.then(o=>[].concat(o)):[].concat(a)}class Kd{constructor(e={},t={},r={},s={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const r=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xd(n,e,t,r){const s=new Set,a=[];let o=null,i=null;const u=new Set,l=Object.keys(n).map(d=>Kt(d)[0]);let c=[];r!=null&&(c=r.map(d=>Kt(d.name)[0]));const p=[...e];for(;p.length>0;){const d=p.pop();if((Py(d)||dB(d)||hB(d))&&o==null&&(o=d,i=o.children.map(h=>h.name).filter(h=>s.has(h))),s.add(d.name),t[d.name]==null&&l.indexOf(d.name)===-1&&c.indexOf(d.name)===-1){if(d.inputs.length===0){a.push(d.name);continue}d.inputs.forEach(h=>{u.has(h.name)||(u.add(h.name),p.push(h))})}}return{inputs:n,outputs:e,usedNodes:s,missingInputs:a,dynamicNode:o,syncInputs:i}}function uB(n,e,t){const{usedNodes:r,inputs:s}=t,a=[],o=Object.keys(s).map(c=>Kt(c)[0]).map(c=>n.nodes[c]),i=n.initNodes;o.forEach(c=>{r.has(c.name)&&a.push(c)}),n.weights.forEach(c=>{r.has(c.name)&&a.push(c)}),i!=null&&i.forEach(c=>{r.has(c.name)&&a.push(c)});const u=new Set,l=[];for(;a.length>0;){const c=a.pop();u.add(c.name),e[c.name]||l.push(c),c.children.forEach(p=>{!u.has(p.name)&&r.has(p.name)&&p.inputs.every(d=>u.has(d.name))&&a.push(p)})}return l}const cB=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],lB=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],pB=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Py(n){return cB.indexOf(n.op)>=0}function dB(n){return lB.indexOf(n.op)>=0}function hB(n){return pB.indexOf(n.op)>=0}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bo{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new bo(e.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const r=e.map(a=>a.name).sort(),s=t.map(a=>a.name).sort();return r.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(e,t){const r=Xd(e,t,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:a,syncInputs:o}=r;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(s.length>0){const i=t.map(l=>l.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${i}] from the provided inputs [${u}]. Missing the following inputs: [${s}]`)}return uB(this.graph,this.weightMap,r)}execute(e,t){e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const s=r.map(p=>this.graph.nodes[Kt(p)[0]]),a=t.map(p=>Kt(p)[0]);let o=a.map(p=>this.graph.nodes[p]);this.resetIntermediateTensors(),o.length===0&&(o=this._outputs);const i=this.getCompilationKey(s,o);let u=this.compiledMap.get(i);u==null&&(u=this.compile(e,o),this.compiledMap.set(i,u));const l={},c={};return Be(()=>{const p=new Kd(this.weightMap,l,c,this.functionExecutorMap),d=Object.assign({},this.weightMap);Object.keys(e).forEach(m=>{const[g,y]=Kt(m),x=[];x[y]=e[m],d[g]=x});const h=this.getFrozenTensorIds(d),f={};for(let m=0;m<u.length;m++){const g=u[m];if(!d[g.name]){const y=qd(g,d,p,this._resourceManager);if(ys(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);d[g.name]=y,this.checkTensorForDisposal(g.name,g,d,p,h,a,f)}}return this.parent==null&&p.dispose(h),t.map(m=>Lt(m,d,p))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(t)}checkTensorForDisposal(e,t,r,s,a,o,i){t.category==="control"||o.indexOf(e)!==-1||(r[e].forEach(u=>{u!=null&&(i[u.id]=(i[u.id]||0)+t.children.length)}),t.inputs.forEach(u=>{if(u.category!=="control"){const l=YL(u.name,r,s);l!=null&&l.forEach(c=>{if(c&&!c.kept&&!a.has(c.id)){const p=i[c.id];if(p===1){if(!this.keepTensorForDebug)c.dispose();else{const[d,h]=Fn(t.name,s);this.intermediateTensors[d]?this.intermediateTensors[d][h]=c:(this.intermediateTensors[d]=[],this.intermediateTensors[d][h]=c)}delete i[c.id]}else p!=null&&i[c.id]--}})}}))}executeAsync(e,t){return se(this,null,function*(){return this._executeAsync(e,t)})}disposeIntermediateTensors(){this.intermediateTensors&&(Object.keys(this.intermediateTensors).forEach(e=>this.intermediateTensors[e].forEach(t=>t.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){this.tensorsMap&&Object.keys(this.tensorsMap).forEach(e=>{this.tensorsMap[e].forEach(r=>{r&&!r.kept&&!r.isDisposed&&!this.keepIds.has(r.id)&&r.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach(t=>t.dispose()),delete this.intermediateTensors[e]}_executeAsync(o,i){return se(this,arguments,function*(e,t,r=!1,s={},a={}){r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=L().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){console.warn(d.message)}this.resetIntermediateTensors();const u=new Kd(this.weightMap,s,a,this.functionExecutorMap);this.tensorsMap=yield this.executeWithControlFlow(e,u,t,r);const l=t.map(d=>Lt(d,this.tensorsMap,u)),c=l.map(d=>d.id),p=Object.keys(e).map(d=>e[d].id);return this.keepIds=new Set([...c,...p,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&u.dispose(this.keepIds),l})}executeFunctionAsync(e,t,r){return se(this,null,function*(){const s=e.reduce((a,o,i)=>(a[this.inputs[i].name]=o,a),{});return this._executeAsync(s,this.outputNodes,!0,t,r)})}executeWithControlFlow(e,t,r,s){return se(this,null,function*(){const a=Object.keys(e),o=a.map(w=>this.graph.nodes[Kt(w)[0]]),i=r.map(w=>Kt(w)[0]);let u=i.map(w=>this.graph.nodes[w]);u.length===0&&(u=this._outputs);const{usedNodes:l,missingInputs:c,dynamicNode:p,syncInputs:d}=Xd(e,u,this.weightMap,this._initNodes),h=[...o,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(w=>{const[v,$]=Kt(w),C=[];C[$]=e[w],f[v]=C});const m={},g=this.getFrozenTensorIds(f),y={};for(;h.length>0;){const w=this.processStack(o,h,t,f,y,g,i,m,l);yield Promise.all(w)}p==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const x=u.filter(w=>!Py(w)&&!Lt(w.name,f,t)).map(w=>w.name);if(x.length>0){let w="";throw p!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${a}]. Consider providing the following inputs: [${c}]. ${w}`)}return f})}processStack(e,t,r,s,a,o,i,u,l){const c=[];for(;t.length>0;){const p=t.pop();r.currentContext=p.contexts;let d="";if(p.node.op==="Enter"&&b("isConstant",p.node,s,r)&&([d]=Fn(p.node.name,r)),s[p.node.name]==null){const h=qd(p.node,s,r,this._resourceManager);d||([d]=Fn(p.node.name,r));const f=r.currentContext;ys(h)?c.push(h.then(m=>(s[d]=m,r.currentContext=f,this.checkTensorForDisposal(d,p.node,s,r,o,i,u),this.processChildNodes(p.node,t,r,s,a,l),m))):(s[d]=h,this.checkTensorForDisposal(d,p.node,s,r,o,i,u),this.processChildNodes(p.node,t,r,s,a,l))}else this.processChildNodes(p.node,t,r,s,a,l)}return c}processChildNodes(e,t,r,s,a,o){e.children.forEach(i=>{const[u]=Fn(i.name,r);a[u]||!o.has(i.name)||(i.op==="Merge"?i.inputNames.some(l=>!!Lt(l,s,r))&&(a[u]=!0,t.push({contexts:r.currentContext,node:i})):i.inputNames.every(l=>!!Lt(l,s,r))&&(a[u]=!0,t.push({contexts:r.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const r=e[t],[s]=Kt(t),a=this.graph.nodes[s];if(a.attrParams.shape&&a.attrParams.shape.value){const o=a.attrParams.shape.value,i=o.length===r.shape.length&&r.shape.every((u,l)=>o[l]===-1||o[l]===u);I(i,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&I(r.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){const t={};for(const r in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[r]!=null){const s=this._signature.inputs[r];t[s.name]=e[r]}else t[r]=e[r];return t}checkInputs(e){const t=Object.keys(e).filter(r=>{const[s]=Kt(r);return this.graph.nodes[s]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{const[r]=Kt(t);if(!this.graph.nodes[r])throw new Error(`The output '${t}' is not found in the graph`)})}}class fB{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mB="?tfjs-format=file",gB="model.json";class yB{constructor(e,t={},r=dm){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=r,t==null&&(this.loadOptions={}),this.resourceManager=new fB}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return ys(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const a=this.artifacts.userDefinedMetadata;a.signature!=null&&(r=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}this.signature=r,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const s=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new bo(zd.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const a=zd.Instance.transformGraph(e.modelInitializer);this.initializer=new bo(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}save(e,t){return se(this,null,function*(){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)})}predict(e,t){const r=this.execute(e,this.outputNodes);if(this.structuredOutputKeys){const s=r instanceof ot?[r]:r,a={};return s.forEach((o,i)=>a[this.structuredOutputKeys[i]]=o),a}return r}normalizeInputs(e){if(!(e instanceof ot)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,r,s)=>(t[r]=e[s],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=this.executor.execute(e,t);return r.length>1?r:r[0]}executeAsync(e,t){return se(this,null,function*(){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=yield this.executor.executeAsync(e,t);return r.length>1?r:r[0]})}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}function jr(r){return se(this,arguments,function*(n,e={},t=dm){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=xB(n));const s=new yB(n,e,t);return yield s.load(),s})}function xB(n){return n.endsWith("/")||(n=n+"/"),`${n}${gB}${mB}`}/**
    * @license
    * Copyright 2022 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var Ly=function(n,e){return(Ly=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var s in r)r.hasOwnProperty(s)&&(t[s]=r[s])})(n,e)};function My(n,e){function t(){this.constructor=n}Ly(n,e),n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var He=function(){return(He=Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++)for(var s in e=arguments[t])Object.prototype.hasOwnProperty.call(e,s)&&(n[s]=e[s]);return n}).apply(this,arguments)};function Oe(n,e,t,r){return new(t||(t=Promise))(function(s,a){function o(l){try{u(r.next(l))}catch(c){a(c)}}function i(l){try{u(r.throw(l))}catch(c){a(c)}}function u(l){var c;l.done?s(l.value):(c=l.value,c instanceof t?c:new t(function(p){p(c)})).then(o,i)}u((r=r.apply(n,e||[])).next())})}function Fe(n,e){var t,r,s,a,o={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return a={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(a[Symbol.iterator]=function(){return this}),a;function i(u){return function(l){return function(c){if(t)throw new TypeError("Generator is already executing.");for(;o;)try{if(t=1,r&&(s=2&c[0]?r.return:c[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,c[1])).done)return s;switch(r=0,s&&(c=[2&c[0],s.value]),c[0]){case 0:case 1:s=c;break;case 4:return o.label++,{value:c[1],done:!1};case 5:o.label++,r=c[1],c=[0];continue;case 7:c=o.ops.pop(),o.trys.pop();continue;default:if(s=o.trys,!((s=s.length>0&&s[s.length-1])||c[0]!==6&&c[0]!==2)){o=0;continue}if(c[0]===3&&(!s||c[1]>s[0]&&c[1]<s[3])){o.label=c[1];break}if(c[0]===6&&o.label<s[1]){o.label=s[1],s=c;break}if(s&&o.label<s[2]){o.label=s[2],o.ops.push(c);break}s[2]&&o.ops.pop(),o.trys.pop();continue}c=e.call(n,o)}catch(p){c=[6,p],r=0}finally{t=s=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([u,l])}}}function Lr(){for(var n=0,e=0,t=arguments.length;e<t;e++)n+=arguments[e].length;var r=Array(n),s=0;for(e=0;e<t;e++)for(var a=arguments[e],o=0,i=a.length;o<i;o++,s++)r[s]=a[o];return r}var Vn=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],ha=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"];function wo(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function By(n){return Oe(this,void 0,void 0,function(){var e,t;return Fe(this,function(r){switch(r.label){case 0:return e=document.createElement("canvas"),n instanceof ot?[4,Ol(n,e)]:[3,2];case 1:return r.sent(),[3,3];case 2:e.width=wo(n.width),e.height=wo(n.height),t=e.getContext("2d"),n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0),r.label=3;case 3:return[2,e]}})})}function Vy(n){return Oe(this,void 0,void 0,function(){var e,t,r,s,a,o;return Fe(this,function(i){switch(i.label){case 0:return n instanceof ot?(e=n.shape.slice(0,2),t=e[0],r=e[1],s=ImageData.bind,[4,Ol(n)]):[3,2];case 1:return[2,new(s.apply(ImageData,[void 0,i.sent(),r,t]))];case 2:return a=document.createElement("canvas"),o=a.getContext("2d"),a.width=wo(n.width),a.height=wo(n.height),o.drawImage(n,0,0),[2,o.getImageData(0,0,a.width,a.height)]}})})}function bB(n){return Oe(this,void 0,void 0,function(){var e,t;return Fe(this,function(r){switch(r.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,By(n)]:[3,2];case 1:return t=r.sent(),[3,3];case 2:t=n,r.label=3;case 3:return e=t,[2,Fl(e,4)]}})})}function Wy(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got "+n);if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got "+n)}var Us={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},wB=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return Oe(this,void 0,void 0,function(){return Fe(this,function(e){return[2,this.mask]})})},n.prototype.toImageData=function(){return Oe(this,void 0,void 0,function(){return Fe(this,function(e){return[2,Vy(this.mask)]})})},n.prototype.toTensor=function(){return Oe(this,void 0,void 0,function(){return Fe(this,function(e){return[2,bB(this.mask)]})})},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n}();function vB(n){return Wy(n),"person"}var SB=function(){function n(e){var t,r=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new qL.Pose({locateFile:function(s,a){return e.solutionPath?e.solutionPath.replace(/\/+$/,"")+"/"+s:a+"/"+s}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;case"full":default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(s){if(r.height=s.image.height,r.width=s.image.width,s.poseLandmarks==null)r.poses=[];else{var a=r.translateOutput(s.poseLandmarks,s.poseWorldLandmarks);s.segmentationMask&&(a.segmentation={maskValueToLabel:vB,mask:new wB(s.segmentationMask)}),r.poses=[a]}})}return n.prototype.translateOutput=function(e,t){var r=this,s={keypoints:e.map(function(a,o){return{x:a.x*r.width,y:a.y*r.height,z:a.z,score:a.visibility,name:ha[o]}})};return t!=null&&(s.keypoints3D=t.map(function(a,o){return{x:a.x,y:a.y,z:a.z,score:a.visibility,name:ha[o]}})),s},n.prototype.estimatePoses=function(e,t,r){return Oe(this,void 0,void 0,function(){var s,a;return Fe(this,function(o){switch(o.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof ot?(a=ImageData.bind,[4,Ol(e)]):[3,2];case 1:return s=new(a.apply(ImageData,[void 0,o.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:s=e,o.label=3;case 3:return e=s,[4,this.poseSolution.send({image:e},r)];case 4:return o.sent(),[2,this.poses]}})})},n.prototype.dispose=function(){this.poseSolution.close()},n.prototype.reset=function(){this.poseSolution.reset()},n.prototype.initialize=function(){return this.poseSolution.initialize()},n}();function $B(n){return Oe(this,void 0,void 0,function(){var e,t;return Fe(this,function(r){switch(r.label){case 0:return e=function(s){if(s==null)return He({},Us);var a=He({},s);return a.runtime="mediapipe",a.enableSegmentation==null&&(a.enableSegmentation=Us.enableSegmentation),a.enableSmoothing==null&&(a.enableSmoothing=Us.enableSmoothing),a.smoothSegmentation==null&&(a.smoothSegmentation=Us.smoothSegmentation),a.modelType==null&&(a.modelType=Us.modelType),a}(n),[4,(t=new SB(e)).initialize()];case 1:return r.sent(),[2,t]}})})}function fa(n){return n instanceof ot?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function Uy(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function _p(n){return n instanceof ot?n:Fl(n)}function zy(n,e,t){return cc(t,"inputResolution"),[1/t.width*n[0][0]*e.width,1/t.height*n[0][1]*e.width,n[0][3]*e.width,1/t.width*n[1][0]*e.height,1/t.height*n[1][1]*e.height,n[1][3]*e.height,0,0]}function cc(n,e){I(n.width!==0,function(){return e+" width cannot be 0."}),I(n.height!==0,function(){return e+" height cannot be 0."})}function au(n,e,t){var r=t.rotationVectorStartKeypointIndex,s=t.rotationVectorEndKeypointIndex,a=n.locationData,o=a.relativeKeypoints[r].x*e.width,i=a.relativeKeypoints[r].y*e.height,u=a.relativeKeypoints[s].x*e.width,l=a.relativeKeypoints[s].y*e.height,c=2*Math.sqrt((u-o)*(u-o)+(l-i)*(l-i)),p=function(d,h,f){var m,g=d.locationData,y=f.rotationVectorStartKeypointIndex,x=f.rotationVectorEndKeypointIndex;m=f.rotationVectorTargetAngle?f.rotationVectorTargetAngle:Math.PI*f.rotationVectorTargetAngleDegree/180;var w=g.relativeKeypoints[y].x*h.width,v=g.relativeKeypoints[y].y*h.height,$=g.relativeKeypoints[x].x*h.width,C=g.relativeKeypoints[x].y*h.height;return Uy(m-Math.atan2(-(C-v),$-w))}(n,e,t);return{xCenter:o/e.width,yCenter:i/e.height,width:c/e.width,height:c/e.height,rotation:p}}function Gy(n){if(n.length!==16)throw new Error("Array length must be 16 but got "+n.length);return[[n[0],n[1],n[2],n[3]],[n[4],n[5],n[6],n[7]],[n[8],n[9],n[10],n[11]],[n[12],n[13],n[14],n[15]]]}function ou(n,e,t,r,s,a,o){return n[e][s]*(n[t][a]*n[r][o]-n[t][o]*n[r][a])}function At(n,e,t){var r=(e+1)%4,s=(e+2)%4,a=(e+3)%4,o=(t+1)%4,i=(t+2)%4,u=(t+3)%4;return ou(n,r,s,a,o,i,u)+ou(n,s,a,r,o,i,u)+ou(n,a,r,s,o,i,u)}function Yd(n,e,t){t===void 0&&(t={ignoreRotation:!1});for(var r=[],s=0,a=n;s<a.length;s++){var o=a[s],i=o.x-.5,u=o.y-.5,l=t.ignoreRotation?0:e.rotation,c=Math.cos(l)*i-Math.sin(l)*u,p=Math.sin(l)*i+Math.cos(l)*u;c=c*e.width+e.xCenter,p=p*e.height+e.yCenter;var d=o.z*e.width,h=He({},o);h.x=c,h.y=p,h.z=d,r.push(h)}return r}function Hy(n,e){var t=function(r,s,a,o){var i=s-r,u=o-a;if(i===0)throw new Error("Original min and max are both "+r+", range cannot be 0.");var l=u/i;return{scale:l,offset:a-r*l}}(0,255,e[0],e[1]);return Be(function(){return Pe(pe(n,t.scale),t.offset)})}function lc(n,e,t){var r,s,a,o,i,u,l,c,p,d,h,f,m,g,y=e.outputTensorSize,x=e.keepAspectRatio,w=e.borderMode,v=e.outputTensorFloatRange,$=fa(n),C=function(F,D){return D?{xCenter:D.xCenter*F.width,yCenter:D.yCenter*F.height,width:D.width*F.width,height:D.height*F.height,rotation:D.rotation}:{xCenter:.5*F.width,yCenter:.5*F.height,width:F.width,height:F.height,rotation:0}}($,t),k=function(F,D,M){if(M===void 0&&(M=!1),!M)return{top:0,left:0,right:0,bottom:0};var U=D.height,j=D.width;cc(D,"targetSize"),cc(F,"roi");var Y,Q,ae=U/j,me=F.height/F.width,le=0,De=0;return ae>me?(Y=F.width,Q=F.width*ae,De=(1-me/ae)/2):(Y=F.height/ae,Q=F.height,le=(1-ae/me)/2),F.width=Y,F.height=Q,{top:De,left:le,right:le,bottom:De}}(C,y,x),R=(r=C,s=$.width,a=$.height,o=!1,i=r.width,u=r.height,l=o?-1:1,c=Math.cos(r.rotation),p=Math.sin(r.rotation),d=r.xCenter,h=r.yCenter,f=1/s,m=1/a,(g=new Array(16))[0]=i*c*l*f,g[1]=-u*p*f,g[2]=0,g[3]=(-.5*i*c*l+.5*u*p+d)*f,g[4]=i*p*l*m,g[5]=u*c*m,g[6]=0,g[7]=(-.5*u*c-.5*i*p*l+h)*m,g[8]=0,g[9]=0,g[10]=i*f,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1,Gy(g));return{imageTensor:Be(function(){var F=_p(n),D=vn(zy(R,$,y),[1,8]),M=w==="zero"?"constant":"nearest",U=Qn.transform(mn(tt(F,"float32")),D,"bilinear",M,0,[y.height,y.width]);return v!=null?Hy(U,v):U}),padding:k,transformationMatrix:R}}function Qd(n,e,t,r){return r===1?.5*(n+e):n+(e-n)*t/(r-1)}function IB(n){return Be(function(){var e=function(s){return Be(function(){return[Ie(s,[0,0,0],[1,-1,1]),Ie(s,[0,0,1],[1,-1,-1])]})}(n),t=e[0],r=e[1];return{boxes:ze(r),logits:ze(t)}})}function jy(n){return n!=null&&n.currentTime!=null}function Zd(n){for(var e={locationData:{relativeKeypoints:[]}},t=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,a=Number.MIN_SAFE_INTEGER,o=0;o<n.length;++o){var i=n[o];t=Math.min(t,i.x),r=Math.max(r,i.x),s=Math.min(s,i.y),a=Math.max(a,i.y),e.locationData.relativeKeypoints.push({x:i.x,y:i.y})}return e.locationData.relativeBoundingBox={xMin:t,yMin:s,xMax:r,yMax:a,width:r-t,height:a-s},e}function TB(n,e,t,r){return Oe(this,void 0,void 0,function(){var s,a,o,i,u;return Fe(this,function(l){switch(l.label){case 0:return n.sort(function(c,p){return Math.max.apply(Math,p.score)-Math.max.apply(Math,c.score)}),s=vn(n.map(function(c){return[c.locationData.relativeBoundingBox.yMin,c.locationData.relativeBoundingBox.xMin,c.locationData.relativeBoundingBox.yMax,c.locationData.relativeBoundingBox.xMax]})),a=Mt(n.map(function(c){return c.score[0]})),[4,Qn.nonMaxSuppressionAsync(s,a,e,t)];case 1:return[4,(o=l.sent()).array()];case 2:return i=l.sent(),u=n.filter(function(c,p){return i.indexOf(p)>-1}),St([s,a,o]),[2,u]}})})}function qy(n,e){return n.map(function(t){var r=He(He({},t),{x:t.x*e.width,y:t.y*e.height});return t.z!=null&&(r.z=t.z*e.width),r})}function CB(n,e,t){return Oe(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c,p,d,h,f,m,g,y,x,w,v,$,C,k,R,F,D;return Fe(this,function(M){switch(M.label){case 0:if(r=ze(e,[0]),s=r.shape,a=s[0],o=s[1],i=s[2],n.length!==i)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+n.length+", heatmap length: "+i);return u=[],[4,r.buffer()];case 1:for(l=M.sent(),c=0;c<n.length;c++)if(p=n[c],d=He({},p),u.push(d),h=Math.trunc(d.x*o),f=Math.trunc(d.y*a),!(h<0||h>=o||f<0||h>=a)){for(m=Math.trunc((t.kernelSize-1)/2),g=Math.max(0,h-m),y=Math.min(o,h+m+1),x=Math.max(0,f-m),w=Math.min(a,f+m+1),v=0,$=0,C=0,k=0,R=x;R<w;++R)for(F=g;F<y;++F)D=l.get(R,F,c),v+=D,k=Math.max(k,D),$+=F*D,C+=R*D;k>=t.minConfidenceToRefine&&v>0&&(d.x=$/o/v,d.y=C/a/v)}return r.dispose(),[2,u]}})})}function Jd(n,e){var t=e.left,r=e.top,s=e.left+e.right,a=e.top+e.bottom;return n.map(function(o){return He(He({},o),{x:(o.x-t)/(1-s),y:(o.y-r)/(1-a),z:o.z/(1-s)})})}function _B(n,e,t){return oo()==="webgl"?function(r,s,a){var o=a.combineWithPreviousRatio.toFixed(2),i={variableNames:["prevMask","newMask"],outputShape:r.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `+o+`);

      setOutput(outputValue);
    }
`},u=E1();return Be(function(){var l=u.compileAndRun(i,[r,s]);return or().makeTensorFromDataId(l.dataId,l.shape,l.dtype)})}(n,e,t):Be(function(){var r=ke(e,.5),s=va(r),a=ke(1,jl(1,pe(s,Pe(5.68842,pe(s,Pe(-.748699,pe(s,Pe(-57.8051,pe(s,Pe(291.309,pe(s,-624.717)))))))))));return Pe(e,pe(ke(n,e),pe(a,t.combineWithPreviousRatio)))})}function kB(n,e,t){return Oe(this,void 0,void 0,function(){var r,s,a,o,i;return Fe(this,function(u){switch(u.label){case 0:return r=n[0],s=n[1],a=function(l,c,p){return Be(function(){var d,h,f,m;p.reverseOutputOrder?(h=ze(Ie(l,[0,p.boxCoordOffset+0],[-1,1])),d=ze(Ie(l,[0,p.boxCoordOffset+1],[-1,1])),m=ze(Ie(l,[0,p.boxCoordOffset+2],[-1,1])),f=ze(Ie(l,[0,p.boxCoordOffset+3],[-1,1]))):(d=ze(Ie(l,[0,p.boxCoordOffset+0],[-1,1])),h=ze(Ie(l,[0,p.boxCoordOffset+1],[-1,1])),f=ze(Ie(l,[0,p.boxCoordOffset+2],[-1,1])),m=ze(Ie(l,[0,p.boxCoordOffset+3],[-1,1]))),h=Pe(pe(Me(h,p.xScale),c.w),c.x),d=Pe(pe(Me(d,p.yScale),c.h),c.y),p.applyExponentialOnBoxSize?(f=pe(Jn(Me(f,p.hScale)),c.h),m=pe(Jn(Me(m,p.wScale)),c.w)):(f=pe(Me(f,p.hScale),c.h),m=pe(Me(m,p.wScale),c.h));var g=ke(d,Me(f,2)),y=ke(h,Me(m,2)),x=Pe(d,Me(f,2)),w=Pe(h,Me(m,2)),v=xt([z(g,[p.numBoxes,1]),z(y,[p.numBoxes,1]),z(x,[p.numBoxes,1]),z(w,[p.numBoxes,1])],1);if(p.numKeypoints)for(var $=0;$<p.numKeypoints;++$){var C=p.keypointCoordOffset+$*p.numValuesPerKeypoint,k=void 0,R=void 0;p.reverseOutputOrder?(k=ze(Ie(l,[0,C],[-1,1])),R=ze(Ie(l,[0,C+1],[-1,1]))):(R=ze(Ie(l,[0,C],[-1,1])),k=ze(Ie(l,[0,C+1],[-1,1])));var F=Pe(pe(Me(k,p.xScale),c.w),c.x),D=Pe(pe(Me(R,p.yScale),c.h),c.y);v=xt([v,z(F,[p.numBoxes,1]),z(D,[p.numBoxes,1])],1)}return v})}(s,e,t),o=Be(function(){var l=r;return t.sigmoidScore?(t.scoreClippingThresh!=null&&(l=Om(r,-t.scoreClippingThresh,t.scoreClippingThresh)),l=Yn(l)):l}),[4,NB(a,o,t)];case 1:return i=u.sent(),St([a,o]),[2,i]}})})}function NB(n,e,t){return Oe(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c,p,d,h,f;return Fe(this,function(m){switch(m.label){case 0:return r=[],[4,n.data()];case 1:return s=m.sent(),[4,e.data()];case 2:for(a=m.sent(),o=0;o<t.numBoxes;++o)if(!(t.minScoreThresh!=null&&a[o]<t.minScoreThresh||(i=o*t.numCoords,u=EB(s[i+0],s[i+1],s[i+2],s[i+3],a[o],t.flipVertically,o),(l=u.locationData.relativeBoundingBox).width<0||l.height<0))){if(t.numKeypoints>0)for((c=u.locationData).relativeKeypoints=[],p=t.numKeypoints*t.numValuesPerKeypoint,d=0;d<p;d+=t.numValuesPerKeypoint)h=i+t.keypointCoordOffset+d,f={x:s[h+0],y:t.flipVertically?1-s[h+1]:s[h+1]},c.relativeKeypoints.push(f);r.push(u)}return[2,r]}})})}function EB(n,e,t,r,s,a,o){return{score:[s],ind:o,locationData:{relativeBoundingBox:{xMin:e,yMin:a?1-t:n,xMax:r,yMax:a?1-n:t,width:r-e,height:t-n}}}}function RB(n,e){return n==="none"?e:function(t){return 1/(1+Math.exp(-t))}(e)}function eh(n,e,t,r){return Oe(this,void 0,void 0,function(){var s,a,o,i,u,l,c,p;return Fe(this,function(d){switch(d.label){case 0:return t=t||e.flipHorizontally||!1,r=r||e.flipVertically||!1,s=n.size,a=s/e.numLandmarks,[4,n.data()];case 1:for(o=d.sent(),i=[],u=0;u<e.numLandmarks;++u)l=u*a,(p={x:0,y:0}).x=t?e.inputImageWidth-o[l]:o[l],a>1&&(p.y=r?e.inputImageHeight-o[l+1]:o[l+1]),a>2&&(p.z=o[l+2]),a>3&&(p.score=RB(e.visibilityActivation,o[l+3])),i.push(p);for(c=0;c<i.length;++c)(p=i[c]).x=p.x/e.inputImageWidth,p.y=p.y/e.inputImageHeight,p.z=p.z/e.inputImageWidth/(e.normalizeZ||1);return[2,i]}})})}function th(n,e,t){var r=n.width,s=n.height,a=n.rotation;if(t.rotation==null&&t.rotationDegree==null||(a=function(c,p){return p.rotation!=null?c+=p.rotation:p.rotationDegree!=null&&(c+=Math.PI*p.rotationDegree/180),Uy(c)}(a,t)),a===0)n.xCenter=n.xCenter+r*t.shiftX,n.yCenter=n.yCenter+s*t.shiftY;else{var o=(e.width*r*t.shiftX*Math.cos(a)-e.height*s*t.shiftY*Math.sin(a))/e.width,i=(e.width*r*t.shiftX*Math.sin(a)+e.height*s*t.shiftY*Math.cos(a))/e.height;n.xCenter=n.xCenter+o,n.yCenter=n.yCenter+i}if(t.squareLong){var u=Math.max(r*e.width,s*e.height);r=u/e.width,s=u/e.height}else if(t.squareShort){var l=Math.min(r*e.width,s*e.height);r=l/e.width,s=l/e.height}return n.width=r*t.scaleX,n.height=s*t.scaleY,n}function AB(n,e){return n.map(function(t){var r=He(He({},t),{x:t.x/e.width,y:t.y/e.height});return t.z!=null&&(t.z=t.z/e.width),r})}var cr=function(){function n(e){this.alpha=e,this.initialized=!1}return n.prototype.apply=function(e,t){var r;return this.initialized?r=t==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(r=e,this.initialized=!0),this.rawValue=e,this.storedValue=r,r},n.prototype.applyWithAlpha=function(e,t,r){return this.alpha=t,this.apply(e,r)},n.prototype.hasLastRawValue=function(){return this.initialized},n.prototype.lastRawValue=function(){return this.rawValue},n.prototype.reset=function(){this.initialized=!1},n}(),iu=function(){function n(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new cr(this.getAlpha(this.minCutOff)),this.dx=new cr(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return n.prototype.apply=function(e,t,r){if(e==null)return e;var s=Math.trunc(t);if(this.lastTimestamp>=s)return e;this.lastTimestamp!==0&&s!==0&&(this.frequency=1/(1e-6*(s-this.lastTimestamp))),this.lastTimestamp=s;var a=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*r*this.frequency:0,o=this.dx.applyWithAlpha(a,this.getAlpha(this.derivateCutOff)),i=this.minCutOff+this.beta*Math.abs(o),u=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(o):null;return this.x.applyWithAlpha(e,this.getAlpha(i),u)},n.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},n}(),pc=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,r){var s=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var a=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return Lr(e);a=1/r}return e.map(function(o,i){var u=He(He({},o),{x:s.xFilters[i].apply(o.x,t,a),y:s.yFilters[i].apply(o.y,t,a)});return o.z!=null&&(u.z=s.zFilters[i].apply(o.z,t,a)),u})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new iu(t.config)}),this.yFilters=e.map(function(r){return new iu(t.config)}),this.zFilters=e.map(function(r){return new iu(t.config)}))},n}(),uu=function(){function n(e){this.config=e,this.window=[],this.lowPassFilter=new cr(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return n.prototype.apply=function(e,t,r){if(e==null)return e;var s,a=Math.trunc(t);if(this.lastTimestamp>=a)return e;if(this.lastTimestamp===-1)s=1;else{for(var o=e*r-this.lastValue*this.lastValueScale,i=a-this.lastTimestamp,u=o,l=i,c=(1+this.window.length)*(1e6/30),p=0,d=this.window;p<d.length;p++){var h=d[p];if(l+h.duration>c)break;u+=h.distance,l+=h.duration}var f=u/(1e-6*l);s=1-1/(1+this.config.velocityScale*Math.abs(f)),this.window.unshift({distance:o,duration:i}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=r,this.lastTimestamp=a,this.lowPassFilter.applyWithAlpha(e,s)},n}(),OB=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,r){var s=this;if(e==null)return this.reset(),null;var a=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return Lr(e);a=1/r}return this.initializeFiltersIfEmpty(e),e.map(function(o,i){var u=He(He({},o),{x:s.xFilters[i].apply(o.x,t,a),y:s.yFilters[i].apply(o.y,t,a)});return o.z!=null&&(u.z=s.zFilters[i].apply(o.z,t,a)),u})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new uu(t.config)}),this.yFilters=e.map(function(r){return new uu(t.config)}),this.zFilters=e.map(function(r){return new uu(t.config)}))},n}(),cu=function(){function n(e){if(e.velocityFilter!=null)this.keypointsFilter=new OB(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+e+".");this.keypointsFilter=new pc(e.oneEuroFilter)}}return n.prototype.apply=function(e,t,r,s,a){if(s===void 0&&(s=!1),e==null)return this.keypointsFilter.reset(),null;var o=a!=null?function(l,c){return(l.width*c.width+l.height*c.height)/2}(a,r):1,i=s?qy(e,r):e,u=this.keypointsFilter.apply(i,t,o);return s?AB(u,r):u},n}(),nh=function(){function n(e){this.alpha=e.alpha}return n.prototype.apply=function(e){var t=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(i){return new cr(t.alpha)}));for(var r=[],s=0;s<e.length;++s){var a=e[s],o=He({},a);o.score=this.visibilityFilters[s].apply(a.score),r.push(o)}return r},n}(),FB={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},os={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},DB={maxPoses:1,flipHorizontal:!1},PB={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},LB=.3,rh={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},MB={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},BB={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},VB={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},WB={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},UB={kernelSize:7,minConfidenceToRefine:.5},sh={alpha:.1},zB={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},GB={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},HB={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},jB={activation:"none"},qB={combineWithPreviousRatio:.7},KB=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return Oe(this,void 0,void 0,function(){return Fe(this,function(e){return[2,By(this.mask)]})})},n.prototype.toImageData=function(){return Oe(this,void 0,void 0,function(){return Fe(this,function(e){return[2,Vy(this.mask)]})})},n.prototype.toTensor=function(){return Oe(this,void 0,void 0,function(){return Fe(this,function(e){return[2,this.mask]})})},n.prototype.getUnderlyingType=function(){return"tensor"},n}();function XB(n){return Wy(n),"person"}var YB=function(){function n(e,t,r,s,a,o){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=r,this.enableSegmentation=s,this.smoothSegmentation=a,this.modelType=o,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(p){p.reduceBoxesInLowestLayer==null&&(p.reduceBoxesInLowestLayer=!1),p.interpolatedScaleAspectRatio==null&&(p.interpolatedScaleAspectRatio=1),p.fixedAnchorSize==null&&(p.fixedAnchorSize=!1);for(var d=[],h=0;h<p.numLayers;){for(var f=[],m=[],g=[],y=[],x=h;x<p.strides.length&&p.strides[x]===p.strides[h];){var w=Qd(p.minScale,p.maxScale,x,p.strides.length);if(x===0&&p.reduceBoxesInLowestLayer)g.push(1),g.push(2),g.push(.5),y.push(.1),y.push(w),y.push(w);else{for(var v=0;v<p.aspectRatios.length;++v)g.push(p.aspectRatios[v]),y.push(w);if(p.interpolatedScaleAspectRatio>0){var $=x===p.strides.length-1?1:Qd(p.minScale,p.maxScale,x+1,p.strides.length);y.push(Math.sqrt(w*$)),g.push(p.interpolatedScaleAspectRatio)}}x++}for(var C=0;C<g.length;++C){var k=Math.sqrt(g[C]);f.push(y[C]/k),m.push(y[C]*k)}var R=0,F=0;if(p.featureMapHeight.length>0)R=p.featureMapHeight[h],F=p.featureMapWidth[h];else{var D=p.strides[h];R=Math.ceil(p.inputSizeHeight/D),F=Math.ceil(p.inputSizeWidth/D)}for(var M=0;M<R;++M)for(var U=0;U<F;++U)for(var j=0;j<f.length;++j){var Y={xCenter:(U+p.anchorOffsetX)/F,yCenter:(M+p.anchorOffsetY)/R,width:0,height:0};p.fixedAnchorSize?(Y.width=1,Y.height=1):(Y.width=m[j],Y.height=f[j]),d.push(Y)}h=x}return d}(FB);var i=Mt(this.anchors.map(function(p){return p.width})),u=Mt(this.anchors.map(function(p){return p.height})),l=Mt(this.anchors.map(function(p){return p.xCenter})),c=Mt(this.anchors.map(function(p){return p.yCenter}));this.anchorTensor={x:l,y:c,w:i,h:u},this.prevFilteredSegmentationMask=this.enableSegmentation?vn([],[0,0]):null}return n.prototype.estimatePoses=function(e,t,r){return Oe(this,void 0,void 0,function(){var s,a,o,i,u,l,c,p,d,h,f,m,g,y,x,w,v,$,C,k,R,F,D;return Fe(this,function(M){switch(M.label){case 0:return s=function(U){var j;if((j=U==null?DB:He({},U)).maxPoses==null&&(j.maxPoses=1),j.maxPoses<=0)throw new Error("Invalid maxPoses "+j.maxPoses+". Should be > 0.");if(j.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return j}(t),e==null?(this.reset(),[2,[]]):(this.maxPoses=s.maxPoses,this.timestamp=r!=null?1e3*r:jy(e)?1e6*e.currentTime:null,a=fa(e),o=Be(function(){return tt(_p(e),"float32")}),(i=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(o)]);case 1:if((u=M.sent()).length===0)return this.reset(),o.dispose(),[2,[]];l=u[0],i=this.poseDetectionToRoi(l,a),M.label=2;case 2:return[4,this.poseLandmarksByRoi(i,o)];case 3:return c=M.sent(),o.dispose(),c==null?(this.reset(),[2,[]]):(p=c.landmarks,d=c.auxiliaryLandmarks,h=c.poseScore,f=c.worldLandmarks,m=c.segmentationMask,g=this.poseLandmarkFiltering(p,d,f,a),y=g.actualLandmarksFiltered,x=g.auxiliaryLandmarksFiltered,w=g.actualWorldLandmarksFiltered,v=this.poseLandmarksToRoi(x,a),this.regionOfInterest=v,$=this.smoothSegmentation&&m!=null?this.poseSegmentationFiltering(m):m,(C=y!=null?qy(y,a):null)!=null&&C.forEach(function(U,j){U.name=ha[j]}),(k=w)!=null&&k.forEach(function(U,j){U.name=ha[j]}),R={score:h,keypoints:C,keypoints3D:k},$!==null&&(F=Be(function(){var U=mn($,2),j=mr(U,[[0,0],[0,0],[0,1]]);return Ym(j,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||St($),D={maskValueToLabel:XB,mask:new KB(F)},R.segmentation=D),[2,[R]])}})})},n.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return t.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=_B(t,e,qB),St(e)),St(t),this.prevFilteredSegmentationMask},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),St([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},n.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(St(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=vn([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},n.prototype.detectPose=function(e){return Oe(this,void 0,void 0,function(){var t,r,s,a,o,i,u,l,c,p;return Fe(this,function(d){switch(d.label){case 0:return t=lc(e,MB),r=t.imageTensor,s=t.padding,a=this.detectorModel.predict(r),o=IB(a),i=o.boxes,[4,kB([u=o.logits,i],this.anchorTensor,PB)];case 1:return(l=d.sent()).length===0?(St([r,a,u,i]),[2,l]):[4,TB(l,this.maxPoses,LB)];case 2:return c=d.sent(),p=function(h,f){h===void 0&&(h=[]);for(var m=f.left,g=f.top,y=f.left+f.right,x=f.top+f.bottom,w=0;w<h.length;w++){var v=h[w],$=v.locationData.relativeBoundingBox,C=($.xMin-m)/(1-y),k=($.yMin-g)/(1-x),R=$.width/(1-y),F=$.height/(1-x);$.xMin=C,$.yMin=k,$.width=R,$.height=F,$.xMax=C+R,$.yMax=k+F;var D=v.locationData.relativeKeypoints;D&&D.forEach(function(M){var U=(M.x-m)/(1-y),j=(M.y-g)/(1-x);M.x=U,M.y=j})}return h}(c,s),St([r,a,u,i]),[2,p]}})})},n.prototype.poseDetectionToRoi=function(e,t){return th(au(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,rh)},n.prototype.poseLandmarksByRoi=function(e,t){return Oe(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c,p,d,h,f,m,g;return Fe(this,function(y){switch(y.label){case 0:if(r=fa(t),s=lc(t,BB,e),a=s.imageTensor,o=s.padding,i=s.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,but got "+this.modelType);return u=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&u.push("activation_segmentation"),l=this.landmarkModel.execute(a,u),[4,this.tensorsToPoseLandmarksAndSegmentation(l)];case 1:return(c=y.sent())==null?(St(l),St(a),[2,null]):(p=c.landmarks,d=c.auxiliaryLandmarks,h=c.poseScore,f=c.worldLandmarks,m=c.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(r,e,o,i,p,d,f,m)]);case 2:return g=y.sent(),St(l),St(a),[2,He({poseScore:h},g)]}})})},n.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,r,s,a,o,i,u){return Oe(this,void 0,void 0,function(){var l,c,p,d,h,f;return Fe(this,function(m){return l=Jd(a,r),c=Jd(o,r),p=Yd(l,t),d=Yd(c,t),h=function(g,y){for(var x=[],w=0,v=g;w<v.length;w++){var $=v[w],C=$.x,k=$.y,R=y.rotation,F=Math.cos(R)*C-Math.sin(R)*k,D=Math.sin(R)*C+Math.cos(R)*k,M=He({},$);M.x=F,M.y=D,x.push(M)}return x}(i,t),f=null,this.enableSegmentation&&(f=Be(function(){var g=u.shape,y=g[0],x=g[1],w=function(C){var k=Gy(new Array(16).fill(0));k[0][0]=At(C,0,0),k[1][0]=-At(C,0,1),k[2][0]=At(C,0,2),k[3][0]=-At(C,0,3),k[0][2]=At(C,2,0),k[1][2]=-At(C,2,1),k[2][2]=At(C,2,2),k[3][2]=-At(C,2,3),k[0][1]=-At(C,1,0),k[1][1]=At(C,1,1),k[2][1]=-At(C,1,2),k[3][1]=At(C,1,3),k[0][3]=-At(C,3,0),k[1][3]=At(C,3,1),k[2][3]=-At(C,3,2),k[3][3]=At(C,3,3);for(var R=C[0][0]*k[0][0]+C[1][0]*k[0][1]+C[2][0]*k[0][2]+C[3][0]*k[0][3],F=0;F<k.length;F++)for(var D=0;D<k.length;D++)k[F][D]/=R;return k}(s),v=vn(zy(w,{width:x,height:y},e),[1,8]),$=[1,y,x,1];return ze(Qn.transform(z(u,$),v,"bilinear","constant",0,[e.height,e.width]),[0,3])}),St(u)),[2,{landmarks:p,auxiliaryLandmarks:d,worldLandmarks:h,segmentationMask:f}]})})},n.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return Oe(this,void 0,void 0,function(){var t,r,s,a,o,i,u,l,c,p,d,h,f;return Fe(this,function(m){switch(m.label){case 0:return t=e[0],r=e[1],s=e[2],a=e[3],o=this.enableSegmentation?e[4]:null,[4,r.data()];case 1:return(i=m.sent()[0])<.5?[2,null]:[4,eh(t,VB)];case 2:return[4,CB(m.sent(),s,UB)];case 3:return u=m.sent(),l=u.slice(0,33),c=u.slice(33,35),[4,eh(a,WB)];case 4:return p=m.sent(),d=p.slice(0,33),h=function(g,y,x){x===void 0&&(x=!0);for(var w=[],v=0;v<g.length;v++){var $=He({},y[v]);x&&($.score=g[v].score),w.push($)}return w}(l,d,!0),f=this.enableSegmentation?function(g,y,x){return Be(function(){var w=ze(g,[0]),v=w.shape[2];if(v===1){var $=w;switch(y.activation){case"none":break;case"sigmoid":$=Yn($);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported ("+y.activation+")")}var C=x?Qn.resizeBilinear($,[x.height,x.width]):$;return ze(C,[2])}throw new Error("Unsupported number of tensor channels "+v)})}(o,jB):null,[2,{landmarks:l,auxiliaryLandmarks:c,poseScore:i,worldLandmarks:h,segmentationMask:f}]}})})},n.prototype.poseLandmarksToRoi=function(e,t){return th(au(Zd(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,rh)},n.prototype.poseLandmarkFiltering=function(e,t,r,s){var a,o,i;if(this.timestamp!=null&&this.enableSmoothing){var u=au(Zd(t),s,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new nh(sh)),a=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new nh(sh)),o=this.visibilitySmoothingFilterAuxiliary.apply(t),i=this.visibilitySmoothingFilterActual.apply(r),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new cu(zB)),a=this.landmarksSmoothingFilterActual.apply(a,this.timestamp,s,!0,u),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new cu(GB)),o=this.landmarksSmoothingFilterAuxiliary.apply(o,this.timestamp,s,!0,u),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new cu(HB)),i=this.worldLandmarksSmoothingFilterActual.apply(r,this.timestamp)}else a=e,o=t,i=r;return{actualLandmarksFiltered:a,auxiliaryLandmarksFiltered:o,actualWorldLandmarksFiltered:i}},n}();function QB(n){return Oe(this,void 0,void 0,function(){var e,t,r,s,a,o;return Fe(this,function(i){switch(i.label){case 0:return e=function(u){var l=He({},u==null?os:u);if(l.enableSmoothing==null&&(l.enableSmoothing=os.enableSmoothing),l.enableSegmentation==null&&(l.enableSegmentation=os.enableSegmentation),l.smoothSegmentation==null&&(l.smoothSegmentation=os.smoothSegmentation),l.modelType==null&&(l.modelType=os.modelType),l.detectorModelUrl==null&&(l.detectorModelUrl=os.detectorModelUrl),l.landmarkModelUrl==null)switch(l.modelType){case"lite":l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return l}(n),t=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([jr(e.detectorModelUrl,{fromTFHub:t}),jr(e.landmarkModelUrl,{fromTFHub:r})])];case 1:return s=i.sent(),a=s[0],o=s[1],[2,new YB(a,o,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var Vr,Ln,Ky=function(){function n(e){(function(t){if(t.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but encountered "+t.maxTracks);if(t.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but encountered "+t.maxAge);if(t.keypointTrackerParams!==void 0){if(t.keypointTrackerParams.keypointConfidenceThreshold<0||t.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+t.keypointTrackerParams.keypointConfidenceThreshold);if(t.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but encountered "+t.keypointTrackerParams.minNumberOfKeypoints);for(var r=0,s=t.keypointTrackerParams.keypointFalloff;r<s.length;r++){var a=s[r];if(a<=0)throw new Error("Must specify each keypoint falloff parameterto be positive but encountered "+a)}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return n.prototype.apply=function(e,t){this.filterOldTracks(t);var r=this.computeSimilarity(e);return this.assignTracks(e,r,t),this.updateTracks(t),e},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},n.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter(function(r){return e-r.lastTimestamp<=t.maxAge})},n.prototype.assignTracks=function(e,t,r){for(var s=Array.from(Array(t[0].length).keys()),a=[],o=0,i=Array.from(Array(e.length).keys());o<i.length;o++){var u=i[o];if(s.length!==0){for(var l=-1,c=-1,p=0,d=s;p<d.length;p++){var h=d[p],f=t[u][h];f>=this.minSimilarity&&f>c&&(l=h,c=f)}if(l>=0){var m=this.tracks[l];m=Object.assign(m,this.createTrack(e[u],r,m.id)),e[u].id=m.id;var g=s.indexOf(l);s.splice(g,1)}else a.push(u)}else a.push(u)}for(var y=0,x=a;y<x.length;y++){u=x[y];var w=this.createTrack(e[u],r);this.tracks.push(w),e[u].id=w.id}},n.prototype.updateTracks=function(e){this.tracks.sort(function(t,r){return r.lastTimestamp-t.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(e,t,r){var s={id:r||this.nextTrackID(),lastTimestamp:t,keypoints:Lr(e.keypoints).map(function(a){return He({},a)})};return e.box!==void 0&&(s.box=He({},e.box)),s},n.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},n.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter(function(r){return!e.includes(r.id)})},n.prototype.reset=function(){this.tracks=[]},n}(),ZB=function(n){function e(t){return n.call(this,t)||this}return My(e,n),e.prototype.computeSimilarity=function(t){var r=this;return t.length===0||this.tracks.length===0?[[]]:t.map(function(s){return r.tracks.map(function(a){return r.iou(s,a)})})},e.prototype.iou=function(t,r){var s=Math.max(t.box.xMin,r.box.xMin),a=Math.max(t.box.yMin,r.box.yMin),o=Math.min(t.box.xMax,r.box.xMax),i=Math.min(t.box.yMax,r.box.yMax);if(s>=o||a>=i)return 0;var u=(o-s)*(i-a);return u/(t.box.width*t.box.height+r.box.width*r.box.height-u)},e}(Ky),JB=function(n){function e(t){var r=n.call(this,t)||this;return r.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,r.keypointFalloff=t.keypointTrackerParams.keypointFalloff,r.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,r}return My(e,n),e.prototype.computeSimilarity=function(t){if(t.length===0||this.tracks.length===0)return[[]];for(var r=[],s=0,a=t;s<a.length;s++){for(var o=a[s],i=[],u=0,l=this.tracks;u<l.length;u++){var c=l[u];i.push(this.oks(o,c))}r.push(i)}return r},e.prototype.oks=function(t,r){for(var s=this.area(r.keypoints)+1e-6,a=0,o=0,i=0;i<t.keypoints.length;++i){var u=t.keypoints[i],l=r.keypoints[i];if(!(u.score<this.keypointThreshold||l.score<this.keypointThreshold)){o+=1;var c=Math.pow(u.x-l.x,2)+Math.pow(u.y-l.y,2),p=2*this.keypointFalloff[i];a+=Math.exp(-1*c/(2*s*Math.pow(p,2)))}}return o<this.minNumKeyoints?0:a/o},e.prototype.area=function(t){var r=this,s=t.filter(function(u){return u.score>r.keypointThreshold}),a=Math.min.apply(Math,Lr([1],s.map(function(u){return u.x}))),o=Math.max.apply(Math,Lr([0],s.map(function(u){return u.x}))),i=Math.min.apply(Math,Lr([1],s.map(function(u){return u.y})));return(o-a)*(Math.max.apply(Math,Lr([0],s.map(function(u){return u.y})))-i)},e}(Ky);function eV(n){switch(n){case Ln.BlazePose:return ha.reduce(function(e,t,r){return e[t]=r,e},{});case Ln.PoseNet:case Ln.MoveNet:return Vn.reduce(function(e,t,r){return e[t]=r,e},{});default:throw new Error("Model "+n+" is not supported.")}}(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(Vr||(Vr={})),function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"}(Ln||(Ln={}));var ah=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],Xy={modelType:"SinglePose.Lightning",enableSmoothing:!0},oh={},ih={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},lu={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},uh={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function tV(n,e,t,r){for(var s={},a=0,o=Vn;a<o.length;a++){var i=o[a];s[i]=[e[t[i]].y*r.height,e[t[i]].x*r.width]}if(function(x,w){return(x[w.left_hip].score>.2||x[w.right_hip].score>.2)&&(x[w.left_shoulder].score>.2||x[w.right_shoulder].score>.2)}(e,t)){var u=(s.left_hip[0]+s.right_hip[0])/2,l=(s.left_hip[1]+s.right_hip[1])/2,c=function(x,w,v,$,C){for(var k=["left_shoulder","right_shoulder","left_hip","right_hip"],R=0,F=0,D=0;D<k.length;D++)(Q=Math.abs($-v[k[D]][0]))>R&&(R=Q),(ae=Math.abs(C-v[k[D]][1]))>F&&(F=ae);for(var M=0,U=0,j=0,Y=Object.keys(v);j<Y.length;j++){var Q,ae,me=Y[j];x[w[me]].score<.2||((Q=Math.abs($-v[me][0]))>M&&(M=Q),(ae=Math.abs(C-v[me][1]))>U&&(U=ae))}return[R,F,M,U]}(e,t,s,u,l),p=c[0],d=c[1],h=c[2],f=c[3],m=Math.max(1.9*d,1.9*p,1.2*h,1.2*f),g=[u-(m=Math.min(m,Math.max(l,r.width-l,u,r.height-u))),l-m];if(m>Math.max(r.width,r.height)/2)return dc(n==null,r);var y=2*m;return{yMin:g[0]/r.height,xMin:g[1]/r.width,yMax:(g[0]+y)/r.height,xMax:(g[1]+y)/r.width,height:(g[0]+y)/r.height-g[0]/r.height,width:(g[1]+y)/r.width-g[1]/r.width}}return dc(n==null,r)}function dc(n,e){var t,r,s,a;return n?e.width>e.height?(t=1,r=e.height/e.width,s=0,a=(e.width/2-e.height/2)/e.width):(t=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,a=0):e.width>e.height?(t=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,a=0):(t=1,r=e.height/e.width,s=0,a=(e.width/2-e.height/2)/e.width),{yMin:s,xMin:a,yMax:s+t,xMax:a+r,height:t,width:r}}function nV(n){var e,t=n==null?Xy:He({},n);if(t.modelType==null)t.modelType="SinglePose.Lightning";else if(ah.indexOf(t.modelType)<0)throw new Error("Invalid architecture "+t.modelType+". Should be one of "+ah);if(t.enableSmoothing==null&&(t.enableSmoothing=!0),t.minPoseScore!=null&&(t.minPoseScore<0||t.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(t.multiPoseMaxDimension!=null&&(t.multiPoseMaxDimension%32!=0||t.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(t.modelType==="MultiPose.Lightning"&&t.enableTracking==null&&(t.enableTracking=!0),t.modelType==="MultiPose.Lightning"&&t.enableTracking===!0)if(t.trackerType==null&&(t.trackerType=Vr.BoundingBox),t.trackerType===Vr.Keypoint)t.trackerConfig!=null?t.trackerConfig=function(r){var s=ch(lu,r);return s.keypointTrackerParams=He({},lu.keypointTrackerParams),r.keypointTrackerParams!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold=r.keypointTrackerParams.keypointConfidenceThreshold),r.keypointTrackerParams.keypointFalloff!=null&&(s.keypointTrackerParams.keypointFalloff=r.keypointTrackerParams.keypointFalloff),r.keypointTrackerParams.minNumberOfKeypoints!=null&&(s.keypointTrackerParams.minNumberOfKeypoints=r.keypointTrackerParams.minNumberOfKeypoints)),s}(t.trackerConfig):t.trackerConfig=lu;else{if(t.trackerType!==Vr.BoundingBox)throw new Error("Tracker type not supported by MoveNet");t.trackerConfig!=null?t.trackerConfig=(e=t.trackerConfig,ch(uh,e)):t.trackerConfig=uh}return t}function ch(n,e){var t={maxTracks:n.maxTracks,maxAge:n.maxAge,minSimilarity:n.minSimilarity};return e.maxTracks!=null&&(t.maxTracks=e.maxTracks),e.maxAge!=null&&(t.maxAge=e.maxAge),e.minSimilarity!=null&&(t.minSimilarity=e.minSimilarity),t}var rV=function(){function n(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=eV(Ln.MoveNet),t.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):t.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=t.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new pc(ih),this.cropRegionFilterYMin=new cr(.9),this.cropRegionFilterXMin=new cr(.9),this.cropRegionFilterYMax=new cr(.9),this.cropRegionFilterXMax=new cr(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===Vr.Keypoint?this.tracker=new JB(t.trackerConfig):t.trackerType===Vr.BoundingBox&&(this.tracker=new ZB(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return n.prototype.runSinglePersonPoseModel=function(e){return Oe(this,void 0,void 0,function(){var t,r,s,a,o;return Fe(this,function(i){switch(i.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==4||t.shape[0]!==1||t.shape[1]!==1||t.shape[2]!==17||t.shape[3]!==3)throw t.dispose(),new Error("Unexpected output shape from model: ["+t.shape+"]");return oo()==="webgpu"?[3,1]:(r=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:r=i.sent(),i.label=3;case 3:for(t.dispose(),s={keypoints:[],score:0},a=0,o=0;o<17;++o)s.keypoints[o]={y:r[3*o],x:r[3*o+1],score:r[3*o+2]},s.keypoints[o].score>.2&&(++a,s.score+=s.keypoints[o].score);return a>0&&(s.score/=a),[2,s]}})})},n.prototype.runMultiPersonPoseModel=function(e){return Oe(this,void 0,void 0,function(){var t,r,s,a,o,i,u,l;return Fe(this,function(c){switch(c.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==3||t.shape[0]!==1||t.shape[2]!==56)throw t.dispose(),new Error("Unexpected output shape from model: ["+t.shape+"]");return oo()==="webgpu"?[3,1]:(r=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:r=c.sent(),c.label=3;case 3:for(t.dispose(),s=[],a=r.length/56,o=0;o<a;++o)for(s[o]={keypoints:[]},i=56*o+51,s[o].box={yMin:r[i],xMin:r[i+1],yMax:r[i+2],xMax:r[i+3],width:r[i+3]-r[i+1],height:r[i+2]-r[i]},u=56*o+55,s[o].score=r[u],s[o].keypoints=[],l=0;l<17;++l)s[o].keypoints[l]={y:r[56*o+3*l],x:r[56*o+3*l+1],score:r[56*o+3*l+2]};return[2,s]}})})},n.prototype.estimatePoses=function(e,t,r){return t===void 0&&(t=oh),Oe(this,void 0,void 0,function(){var s,a,o,i,u,l;return Fe(this,function(c){switch(c.label){case 0:return t=function(p){return p==null?oh:He({},p)}(t),e==null?(this.reset(),[2,[]]):(r==null?jy(e)&&(r=1e6*e.currentTime):r*=1e3,s=_p(e),a=fa(s),o=mn(s,0),e instanceof ot||s.dispose(),i=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(o,a,r)]);case 1:return i=c.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(o,a,r)];case 3:i=c.sent(),c.label=4;case 4:for(u=0;u<i.length;++u)for(l=0;l<i[u].keypoints.length;++l)i[u].keypoints[l].name=Vn[l],i[u].keypoints[l].y*=a.height,i[u].keypoints[l].x*=a.width;return[2,i]}})})},n.prototype.estimateSinglePose=function(e,t,r){return Oe(this,void 0,void 0,function(){var s,a,o,i,u=this;return Fe(this,function(l){switch(l.label){case 0:return this.cropRegion||(this.cropRegion=dc(this.cropRegion==null,t)),s=Be(function(){var c=vn([[u.cropRegion.yMin,u.cropRegion.xMin,u.cropRegion.yMax,u.cropRegion.xMax]]),p=fr([1],"int32"),d=[u.modelInputResolution.height,u.modelInputResolution.width];return tt(Qn.cropAndResize(e,c,p,d,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(s)];case 1:if(a=l.sent(),s.dispose(),a.score<this.minPoseScore)return this.reset(),[2,[]];for(o=0;o<a.keypoints.length;++o)a.keypoints[o].y=this.cropRegion.yMin+a.keypoints[o].y*this.cropRegion.height,a.keypoints[o].x=this.cropRegion.xMin+a.keypoints[o].x*this.cropRegion.width;return r!=null&&this.enableSmoothing&&(a.keypoints=this.keypointFilter.apply(a.keypoints,r,1)),i=tV(this.cropRegion,a.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(i),[2,[a]]}})})},n.prototype.estimateMultiplePoses=function(e,t,r){return Oe(this,void 0,void 0,function(){var s,a,o,i,u,l,c,p,d,h,f,m=this;return Fe(this,function(g){switch(g.label){case 0:return t.width>t.height?(a=this.multiPoseMaxDimension,o=Math.round(this.multiPoseMaxDimension*t.height/t.width),s=Qn.resizeBilinear(e,[o,a]),u=a,l=32*Math.ceil(o/32),i=mr(s,[[0,0],[0,l-o],[0,0],[0,0]])):(a=Math.round(this.multiPoseMaxDimension*t.width/t.height),o=this.multiPoseMaxDimension,s=Qn.resizeBilinear(e,[o,a]),u=32*Math.ceil(a/32),l=o,i=mr(s,[[0,0],[0,0],[0,u-a],[0,0]])),s.dispose(),e.dispose(),c=tt(i,"int32"),i.dispose(),[4,this.runMultiPersonPoseModel(c)];case 1:for(p=g.sent(),c.dispose(),p=p.filter(function(y){return y.score>=m.minPoseScore}),h=0;h<p.length;++h)for(d=0;d<p[h].keypoints.length;++d)p[h].keypoints[d].y*=l/o,p[h].keypoints[d].x*=u/a;if(this.enableTracking&&(this.tracker.apply(p,r),this.enableSmoothing)){for(h=0;h<p.length;++h)this.keypointFilterMap.has(p[h].id)||this.keypointFilterMap.set(p[h].id,new pc(ih)),p[h].keypoints=this.keypointFilterMap.get(p[h].id).apply(p[h].keypoints,r,1);f=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(y,x){f.has(x)||m.keypointFilterMap.delete(x)})}return[2,p]}})})},n.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),r=this.cropRegionFilterXMin.apply(e.xMin),s=this.cropRegionFilterYMax.apply(e.yMax),a=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:r,yMax:s,xMax:a,height:s-t,width:a-r}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},n.prototype.dispose=function(){this.moveNetModel.dispose()},n.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},n.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},n}();function sV(n){return n===void 0&&(n=Xy),Oe(this,void 0,void 0,function(){var e,t,r,s;return Fe(this,function(a){switch(a.label){case 0:return e=nV(n),r=!0,e.modelUrl?(r=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,jr(e.modelUrl,{fromTFHub:r})]):[3,2];case 1:return t=a.sent(),[3,4];case 2:return s=void 0,e.modelType==="SinglePose.Lightning"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(s="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,jr(s,{fromTFHub:r})];case 3:t=a.sent(),a.label=4;case 4:return oo()==="webgl"&&L().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new rV(t,e)]}})})}var lh={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},ph=["MobileNetV1","ResNet50"],dh={MobileNetV1:[8,16],ResNet50:[16]},aV=[8,16,32],hh={MobileNetV1:[.5,.75,1],ResNet50:[1]},fh=[1,2,4],oV={maxPoses:1,flipHorizontal:!1},iV={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},uV=[-123.15,-115.9,-103.06];function pu(n){return Math.floor(n/2)}var cV=function(){function n(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return n.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(e){for(;e>0&&this.less(pu(e),e);)this.exchange(e,pu(e)),e=pu(e)},n.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},n.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},n.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},n.prototype.exchange=function(e,t){var r=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=r},n}();function lV(n,e,t,r,s,a){for(var o=a.shape,i=o[0],u=o[1],l=!0,c=Math.max(t-s,0),p=Math.min(t+s+1,i),d=c;d<p;++d){for(var h=Math.max(r-s,0),f=Math.min(r+s+1,u),m=h;m<f;++m)if(a.get(d,m,n)>e){l=!1;break}if(!l)break}return l}function pV(n){return Oe(this,void 0,void 0,function(){return Fe(this,function(e){return[2,Promise.all(n.map(function(t){return t.buffer()}))]})})}function Yy(n,e,t,r){return{y:r.get(n,e,t),x:r.get(n,e,t+17)}}function Qy(n,e,t){var r=Yy(n.heatmapY,n.heatmapX,n.id,t),s=r.y,a=r.x;return{x:n.heatmapX*e+a,y:n.heatmapY*e+s}}function Zy(n,e,t,r){var s=t.x,a=t.y;return n.some(function(o){var i,u,l,c,p,d,h=o.keypoints;return i=a,u=s,l=h[r].y,c=h[r].x,(p=l-i)*p+(d=c-u)*d<=e})}var mh=Vn.reduce(function(n,e,t){return n[e]=t,n},{}),Jy=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(n){var e=n[0],t=n[1];return[mh[e],mh[t]]}),du=Jy.map(function(n){return n[1]}),gh=Jy.map(function(n){return n[0]});function yh(n,e,t){return n<e?e:n>t?t:n}function hu(n,e,t,r){return{y:yh(Math.round(n.y/e),0,t-1),x:yh(Math.round(n.x/e),0,r-1)}}function xh(n,e){return{x:n.x+e.x,y:n.y+e.y}}function bh(n,e,t,r,s,a,o,i){i===void 0&&(i=2);for(var u=r.shape,l=u[0],c=u[1],p={y:e.y,x:e.x},d=xh(p,function(x,w,v){var $=v.shape[2]/2;return{y:v.get(w.y,w.x,x),x:v.get(w.y,w.x,$+x)}}(n,hu(p,a,l,c),o)),h=0;h<i;h++){var f=hu(d,a,l,c),m=Yy(f.y,f.x,t,s);d=xh({x:f.x*a,y:f.y*a},{x:m.x,y:m.y})}var g=hu(d,a,l,c),y=r.get(g.y,g.x,t);return{y:d.y,x:d.x,name:Vn[t],score:y}}function dV(n,e,t,r,s,a){var o=e.shape[2],i=du.length,u=new Array(o),l=n.part,c=n.score,p=Qy(l,r,t);u[l.id]={score:c,name:Vn[l.id],y:p.y,x:p.x};for(var d=i-1;d>=0;--d){var h=du[d],f=gh[d];u[h]&&!u[f]&&(u[f]=bh(d,u[h],f,e,t,r,a))}for(d=0;d<i;++d)h=gh[d],f=du[d],u[h]&&!u[f]&&(u[f]=bh(d,u[h],f,e,t,r,s));return u}function hV(n,e,t){return t.reduce(function(r,s,a){var o=s.y,i=s.x,u=s.score;return Zy(n,e,{y:o,x:i},a)||(r+=u),r},0)/t.length}function fV(n,e,t,r,s,a,o,i){return o===void 0&&(o=.5),i===void 0&&(i=20),Oe(this,void 0,void 0,function(){var u,l,c,p,d,h,f,m,g,y,x,w;return Fe(this,function(v){switch(v.label){case 0:return[4,pV([n,e,t,r])];case 1:for(u=v.sent(),l=u[0],c=u[1],p=u[2],d=u[3],h=[],f=function($,C,k){for(var R=k.shape,F=R[0],D=R[1],M=R[2],U=new cV(F*D*M,function(me){return me.score}),j=0;j<F;++j)for(var Y=0;Y<D;++Y)for(var Q=0;Q<M;++Q){var ae=k.get(j,Y,Q);ae<$||lV(Q,ae,j,Y,C,k)&&U.enqueue({score:ae,part:{heatmapY:j,heatmapX:Y,id:Q}})}return U}(o,1,l),m=i*i;h.length<a&&!f.empty();)g=f.dequeue(),y=Qy(g.part,s,c),Zy(h,m,y,g.part.id)||(x=dV(g,l,c,s,p,d),w=hV(h,m,x),h.push({keypoints:x,score:w}));return[2,h]}})})}function mV(n){var e=n.shape,t=e[0],r=e[1],s=e[2];return Be(function(){var a,o,i=z(n,[t*r,s]),u=km(i,0),l=mn(Me(u,Re(r,"int32")),1),c=mn((a=u,o=r,Be(function(){var p=Me(a,Re(o,"int32"));return ke(a,pe(p,Re(o,"int32")))})),1);return xt([l,c],1)})}function gV(n,e,t){return Be(function(){var r=function(s,a){for(var o=[],i=0;i<Vn.length;i++){var u=s.get(i,0).valueOf(),l=s.get(i,1).valueOf(),c=yV(u,l,i,a),p=c.x,d=c.y;o.push(d),o.push(p)}return vn(o,[Vn.length,2])}(n,t);return Pe(tt(pe(n.toTensor(),Re(e,"int32")),"float32"),r)})}function yV(n,e,t,r){return{y:r.get(n,e,t),x:r.get(n,e,t+Vn.length)}}function xV(n,e,t){return Oe(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c,p,d;return Fe(this,function(h){switch(h.label){case 0:return r=0,s=mV(n),[4,Promise.all([n.buffer(),e.buffer(),s.buffer()])];case 1:return a=h.sent(),o=a[0],i=a[1],u=a[2],[4,(l=gV(u,t,i)).buffer()];case 2:return c=h.sent(),p=Array.from(function(f,m){for(var g=m.shape[0],y=new Float32Array(g),x=0;x<g;x++){var w=m.get(x,0),v=m.get(x,1);y[x]=f.get(w,v,x)}return y}(o,u)),d=p.map(function(f,m){return r+=f,{y:c.get(m,0),x:c.get(m,1),score:f,name:Vn[m]}}),s.dispose(),l.dispose(),[2,{keypoints:d,score:r/d.length}]}})})}function wh(n,e){return(n-1)%e==0}var vh="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",Sh="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function $h(n,e){return function(t,r){return(t-1)%r==0}(n,e)?n:Math.floor(n/e)*e+1}var Ih=function(){function n(e,t){this.posenetModel=e;var r=this.posenetModel.inputs[0].shape;I(r[1]===-1&&r[2]===-1,function(){return"Input shape ["+r[1]+", "+r[2]+"] must both be equal to or -1"});var s,a,o=(s=t.inputResolution,a=t.outputStride,{height:$h(s.height,a),width:$h(s.width,a)});(function(i){I(aV.indexOf(i)>=0,function(){return"outputStride of "+i+" is invalid. It must be either 8 or 16."})})(t.outputStride),function(i,u){I(wh(i.height,u),function(){return"height of "+i.height+" is invalid for output stride "+u+"."}),I(wh(i.width,u),function(){return"width of "+i.width+" is invalid for output stride "+u+"."})}(o,t.outputStride),this.inputResolution=o,this.outputStride=t.outputStride,this.architecture=t.architecture}return n.prototype.estimatePoses=function(e,t){return t===void 0&&(t=oV),Oe(this,void 0,void 0,function(){var r,s,a,o,i,u,l,c,p,d,h,f,m,g,y;return Fe(this,function(x){switch(x.label){case 0:return r=function(w){var v=w;if(v.maxPoses==null&&(v.maxPoses=1),v.maxPoses<=0)throw new Error("Invalid maxPoses "+v.maxPoses+". Should be > 0.");if(v.maxPoses>1){if((v=He(He({},iV),v)).scoreThreshold<0||v.scoreThreshold>1)throw new Error("Invalid scoreThreshold "+v.scoreThreshold+". Should be in range [0.0, 1.0]");if(v.nmsRadius<=0)throw new Error("Invalid nmsRadius "+v.nmsRadius+".")}return v}(t),e==null?[2,[]]:(this.maxPoses=r.maxPoses,s=lc(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),a=s.imageTensor,o=s.padding,i=this.architecture==="ResNet50"?Pe(a,uV):Hy(a,[-1,1]),u=this.posenetModel.predict(i),this.architecture==="ResNet50"?(l=ze(u[2],[0]),c=ze(u[3],[0]),p=ze(u[0],[0]),d=ze(u[1],[0])):(l=ze(u[0],[0]),c=ze(u[1],[0]),p=ze(u[2],[0]),d=ze(u[3],[0])),h=Yn(c),this.maxPoses!==1?[3,2]:[4,xV(h,l,this.outputStride)]);case 1:return m=x.sent(),f=[m],[3,4];case 2:return[4,fV(h,l,p,d,this.outputStride,this.maxPoses,r.scoreThreshold,r.nmsRadius)];case 3:f=x.sent(),x.label=4;case 4:return g=fa(e),y=function(w,v,$,C){var k=v.height,R=v.width,F=k/($.height*(1-C.top-C.bottom)),D=R/($.width*(1-C.left-C.right)),M=-C.top*$.height,U=-C.left*$.width;if(D===1&&F===1&&M===0&&U===0)return w;for(var j=0,Y=w;j<Y.length;j++)for(var Q=0,ae=Y[j].keypoints;Q<ae.length;Q++){var me=ae[Q];me.x=(me.x+U)*D,me.y=(me.y+M)*F}return w}(f,g,this.inputResolution,o),r.flipHorizontal&&(y=function(w,v){for(var $=0,C=w;$<C.length;$++)for(var k=0,R=C[$].keypoints;k<R.length;k++){var F=R[k];F.x=v.width-1-F.x}return w}(y,g)),a.dispose(),i.dispose(),St(u),l.dispose(),c.dispose(),p.dispose(),d.dispose(),h.dispose(),[2,y]}})})},n.prototype.dispose=function(){this.posenetModel.dispose()},n.prototype.reset=function(){},n}();function bV(n){return n===void 0&&(n=lh),Oe(this,void 0,void 0,function(){var e,t,r,s,a;return Fe(this,function(o){switch(o.label){case 0:return(e=function(c){var p=c||lh;if(p.architecture==null&&(p.architecture="MobileNetV1"),ph.indexOf(p.architecture)<0)throw new Error("Invalid architecture "+p.architecture+". Should be one of "+ph);if(p.inputResolution==null&&(p.inputResolution={height:257,width:257}),p.outputStride==null&&(p.outputStride=16),dh[p.architecture].indexOf(p.outputStride)<0)throw new Error("Invalid outputStride "+p.outputStride+". Should be one of "+dh[p.architecture]+" for architecture "+p.architecture+".");if(p.multiplier==null&&(p.multiplier=1),hh[p.architecture].indexOf(p.multiplier)<0)throw new Error("Invalid multiplier "+p.multiplier+". Should be one of "+hh[p.architecture]+" for architecture "+p.architecture+".");if(p.quantBytes==null&&(p.quantBytes=4),fh.indexOf(p.quantBytes)<0)throw new Error("Invalid quantBytes "+p.quantBytes+". Should be one of "+fh+" for architecture "+p.architecture+".");if(p.architecture==="MobileNetV1"&&p.outputStride===32&&p.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return p}(n)).architecture!=="ResNet50"?[3,2]:(i=e.outputStride,u=e.quantBytes,l="model-stride"+i+".json",t=u===4?Sh+"float/"+l:Sh+"quant"+u+"/"+l,[4,jr(e.modelUrl||t)]);case 1:return r=o.sent(),[2,new Ih(r,e)];case 2:return s=function(c,p,d){var h={1:"100",.75:"075",.5:"050"},f="model-stride"+c+".json";return d===4?vh+"float/"+h[p]+"/"+f:vh+"quant"+d+"/"+h[p]+"/"+f}(e.outputStride,e.multiplier,e.quantBytes),[4,jr(e.modelUrl||s)];case 3:return a=o.sent(),[2,new Ih(a,e)]}var i,u,l})})}function wV(n,e){return Oe(this,void 0,void 0,function(){var t,r;return Fe(this,function(s){switch(n){case Ln.PoseNet:return[2,bV(e)];case Ln.BlazePose:if(r=void 0,(t=e)!=null){if(t.runtime==="tfjs")return[2,QB(e)];if(t.runtime==="mediapipe")return[2,$B(e)];r=t.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+r);case Ln.MoveNet:return[2,sV(e)];default:throw new Error(n+" is not a supported model name.")}})})}var vV={modelType:{SINGLEPOSE_LIGHTNING:"SinglePose.Lightning",SINGLEPOSE_THUNDER:"SinglePose.Thunder",MULTIPOSE_LIGHTNING:"MultiPose.Lightning"}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ut;(function(n){n[n.float32=0]="float32",n[n.int32=1]="int32",n[n.bool=2]="bool",n[n.string=3]="string",n[n.complex64=4]="complex64"})(ut||(ut={}));var ma;(function(n){n[n.linear=0]="linear",n[n.relu=1]="relu",n[n.relu6=2]="relu6",n[n.prelu=3]="prelu",n[n.leakyrelu=4]="leakyrelu",n[n.sigmoid=5]="sigmoid",n[n.elu=6]="elu"})(ma||(ma={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ex;function SV(n){ex=n.wasm.cwrap(Zs,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function $V(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:a,bias:o,preluActivationWeights:i}=e;if(s.dtype!=="float32"||a.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");const{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=r,d=t.dataIdMap.get(s.dataId).id,h=t.dataIdMap.get(a.dataId).id;let f=0;if(o!=null){const R=t.dataIdMap.get(o.dataId);if(R.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${R.shape.length}.`);f=R.id}const m=i==null?0:t.dataIdMap.get(i.dataId).id,g=ma[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);const y=u?s.shape[2]:s.shape[1],x=l?a.shape[1]:a.shape[2],w=Ne(s.shape.slice(0,-2),a.shape.slice(0,-2)),v=t.makeOutput([...w,y,x],s.dtype),$=t.dataIdMap.get(v.dataId).id,C=new Uint8Array(new Int32Array(s.shape).buffer),k=new Uint8Array(new Int32Array(a.shape).buffer);return ex(d,C,s.shape.length,h,k,a.shape.length,u,l,g,f,m,p||0,$),v}const IV={kernelName:Zs,backendName:"wasm",setupFunc:SV,kernelFunc:$V};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bt(n,e){let t;function r(a){t=a.wasm.cwrap(n,null,["number","number","number"])}function s(a){const{backend:o,inputs:{x:i}}=a,u=o.dataIdMap.get(i.dataId).id,l=o.makeOutput(i.shape,e||i.dtype),c=o.dataIdMap.get(l.dataId).id;return V(l.shape)===0||t(u,ut[i.dtype],c),l}return{kernelName:n,backendName:"wasm",setupFunc:r,kernelFunc:s}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TV=bt(Ic);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _t(n,e,t){let r;function s(o){r=o.wasm.cwrap(n,null,["number","array","number","number","array","number","number","number"])}function a(o){const{backend:i,inputs:u}=o,{a:l,b:c}=u,p=i.dataIdMap.get(l.dataId).id,d=i.dataIdMap.get(c.dataId).id,h=t!=null?t:l.dtype,f=Ne(l.shape,c.shape),m=i.makeOutput(f,h);if(V(f)===0)return m;const g=new Uint8Array(new Int32Array(l.shape).buffer),y=new Uint8Array(new Int32Array(c.shape).buffer),x=i.dataIdMap.get(m.dataId).id;return(()=>r(p,g,l.shape.length,d,y,c.shape.length,ut[l.dtype],x))(),m}return{kernelName:n,backendName:"wasm",setupFunc:s,kernelFunc:a}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CV=_t(To);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tx;function _V(n){tx=n.wasm.cwrap(Co,null,["array","number","number","number"])}function kV(n){const{inputs:e,backend:t}=n,r=t.makeOutput(e[0].shape,e[0].dtype);if(V(r.shape)===0)return r;const s=e.map(i=>t.dataIdMap.get(i.dataId).id),a=new Uint8Array(new Int32Array(s).buffer),o=t.dataIdMap.get(r.dataId).id;return tx(a,s.length,ut[r.dtype],o),r}const NV={kernelName:Co,backendName:"wasm",setupFunc:_V,kernelFunc:kV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mi(n){const{inputs:{x:e},backend:t}=n,r=t.makeOutput(e.shape,e.dtype),s=t.typedArrayFromHeap(e);return t.typedArrayFromHeap(r).set(s),r}const EV={kernelName:Go,backendName:"wasm",kernelFunc:Mi};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nx;function RV(n){nx=n.wasm.cwrap(ps,null,["number","array","number","number","number","array","number"])}function gr(n){const{inputs:e,backend:t,attrs:r}=n,[s,a]=OV(e.x.shape,r.perm);let o=!0;for(let f=0;f<a.length;f++)a[f]!==f&&(o=!1);const i=AV(e.x.shape,r.perm),u={dataId:e.x.dataId,shape:s,dtype:e.x.dtype};if(o){const f=Mi({inputs:e,backend:t});return f.shape=i,f}const l=t.makeOutput(i,u.dtype),c=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(l.dataId).id,d=new Uint8Array(new Int32Array(a).buffer),h=new Uint8Array(new Int32Array(u.shape).buffer);return nx(c,h,u.shape.length,ut[u.dtype],p,d,a.length),l}function AV(n,e){const t=new Array(n.length);for(let r=0;r<t.length;r++)t[r]=n[e[r]];return t}function OV(n,e){const t=[],r=[];for(let s=0;s<n.length;++s)n[s]!==1&&t.push(n[s]),n[e[s]]!==1&&r.push(e[s]);for(let s=0;s<r.length;++s){let a=-1;for(let o=0;o<r.length;++o)r[o]>=s&&(a===-1||r[a]>r[o])&&(a=o);r[a]=s}return[t,r]}const FV={kernelName:ps,backendName:"wasm",kernelFunc:gr,setupFunc:RV};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $r(n,e,t){const r=n.shape,s=n.shape.length,a=ct(e,r);let o=a;const i=Ht(o,s);let u=null,l=!1;if(i!=null){const c=new Array(s);for(let h=0;h<c.length;h++)c[h]=r[i[h]];o=Tt(o.length,s),u=gr({inputs:{x:n},attrs:{perm:i},backend:t});const p=t.dataIdMap.get(n.dataId).id;t.dataIdMap.get(u.dataId).id!==p&&(l=!0)}return{transposed:u,originalAxes:a,axes:o,inputWasTransposed:l}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rx;function DV(n){rx=n.wasm.cwrap(_o,null,["number, number, number"])}function PV(n){const{backend:e,inputs:t,attrs:r}=n,{axis:s,keepDims:a}=r,{x:o}=t;let u=e.dataIdMap.get(o.dataId).id,l=o;const{transposed:c,axes:p,originalAxes:d,inputWasTransposed:h}=$r(o,s,e);if(h){const w=e.dataIdMap.get(c.dataId).id;l=c,u=w}const f=l.shape.length;gt("all",p,f);const[m,g]=kt(l.shape,p),y=V(g),x=e.makeOutput(m,o.dtype);if(V(l.shape)!==0){const w=e.dataIdMap.get(x.dataId).id;rx(u,y,w)}if(h&&e.disposeData(c.dataId),a){const w=mt(x.shape,d);x.shape=w}return x}const LV={kernelName:_o,backendName:"wasm",setupFunc:DV,kernelFunc:PV};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sx;function MV(n){sx=n.wasm.cwrap(ko,null,["number, number, number"])}function BV(n){const{backend:e,inputs:t,attrs:r}=n,{axis:s,keepDims:a}=r,{x:o}=t;let u=e.dataIdMap.get(o.dataId).id,l=o;const{transposed:c,axes:p,originalAxes:d,inputWasTransposed:h}=$r(o,s,e);if(h){const w=e.dataIdMap.get(c.dataId).id;l=c,u=w}const f=l.shape.length;gt("any",p,f);const[m,g]=kt(l.shape,p),y=V(g),x=e.makeOutput(m,o.dtype);if(V(l.shape)!==0){const w=e.dataIdMap.get(x.dataId).id;sx(u,y,w)}if(h&&e.disposeData(c.dataId),a){const w=mt(x.shape,d);x.shape=w}return x}const VV={kernelName:ko,backendName:"wasm",setupFunc:MV,kernelFunc:BV};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ax;function WV(n){ax=n.wasm.cwrap(No,null,["number","number","number","number","number"])}function UV(n){const{backend:e,inputs:t,attrs:r}=n,{axis:s}=r,{x:a}=t,o=e.dataIdMap.get(a.dataId).id;let i=o,u=a;const{transposed:l,axes:c,inputWasTransposed:p}=$r(a,s,e);if(p){const y=e.dataIdMap.get(l.dataId).id;y!==o&&(u=l,i=y)}const d=u.shape.slice(0,-1),h=e.makeOutput(d,"int32"),f=e.dataIdMap.get(h.dataId).id,m=V(h.shape),g=u.shape[c[0]];return ax(i,ut[u.dtype],m,g,f),p&&e.disposeData(l.dataId),h}const zV={kernelName:No,backendName:"wasm",kernelFunc:UV,setupFunc:WV};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ox;function GV(n){ox=n.wasm.cwrap(Eo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function HV(n){const{inputs:e,attrs:t,backend:r}=n,s=e.x,a=r.dataIdMap.get(s.dataId).id,{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=t,c=nr(s.shape,o,i,1,u,l),p=c.filterHeight,d=c.filterWidth,h=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,y=c.strideHeight,x=c.strideWidth,w=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);const v=r.makeOutput(c.outShape,"float32"),$=r.dataIdMap.get(v.dataId).id;return ox(a,s.shape[0],s.shape[1],s.shape[2],p,d,h,f,m,g,y,x,w,$),v}const jV={kernelName:Eo,backendName:"wasm",setupFunc:GV,kernelFunc:HV};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gt(n){const{inputs:e,attrs:t}=n,{x:r}=e,{shape:s}=t,a=V(r.shape),o=Eh(s,a);return I(a===V(o),()=>`new shape: ${o}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`),n.backend.incRef(r.dataId),{dataId:r.dataId,shape:o,dtype:r.dtype}}const qV={kernelName:rl,backendName:"wasm",kernelFunc:Gt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ix;function KV(n){ix=n.wasm.cwrap(Ro,null,["number","array","number","number","array","number","number","number","number"])}function XV(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:a}=e,{transposeA:o,transposeB:i}=r;if(s.dtype!=="float32"||a.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");const u=s.shape.length,l=a.shape.length,c=o?s.shape[u-2]:s.shape[u-1],p=i?a.shape[l-1]:a.shape[l-2],d=o?s.shape[u-1]:s.shape[u-2],h=i?a.shape[l-2]:a.shape[l-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=V(f),y=V(m),w=Ne(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([d,h]);I(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${o} and transposeB=${i} must match.`);const v=o?[g,c,d]:[g,d,c],$=i?[y,h,p]:[y,p,h],C=Gt({inputs:{x:s},backend:t,attrs:{shape:v}}),k=Gt({inputs:{x:a},backend:t,attrs:{shape:$}}),R=t.dataIdMap.get(C.dataId).id,F=t.dataIdMap.get(k.dataId).id,D=o?C.shape[2]:C.shape[1],M=i?k.shape[1]:k.shape[2],U=Math.max(g,y),j=t.makeOutput([U,D,M],C.dtype),Y=t.dataIdMap.get(j.dataId).id,Q=new Uint8Array(new Int32Array(C.shape).buffer),ae=new Uint8Array(new Int32Array(k.shape).buffer);return ix(R,Q,C.shape.length,F,ae,k.shape.length,o,i,Y),t.disposeData(C.dataId),t.disposeData(k.dataId),j.shape=w,j}const YV={kernelName:Ro,backendName:"wasm",setupFunc:KV,kernelFunc:XV};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qr(n){const{inputs:{x:e},attrs:{begin:t,size:r},backend:s}=n,[a,o]=Ll(e,t,r),i=wi(e.shape,a,o),u=s.readSync(e.dataId),l=s.makeOutput(o,e.dtype),c=Ve(e.shape),p=s.dataIdMap.get(l.dataId);if(i){const f=vi(a,c);return e.dtype==="string"?p.stringBytes=u.slice(f,f+V(o)):s.typedArrayFromHeap(l).set(u.subarray(f,f+V(o))),l}if(e.dtype==="string"){const f=Ku(u,a,o,e.shape,e.dtype);return p.stringBytes=f,l}const d=s.typedArrayFromHeap(l),h=e.shape.length;if(h===2)QV(u,c[0],d,a,o);else if(h===3)ZV(u,c[0],c[1],d,a,o);else if(h===4)JV(u,c[0],c[1],c[2],d,a,o);else{const f=Ku(u,a,o,e.shape,e.dtype);d.set(f)}return l}function QV(n,e,t,r,s){let a=0;const o=r[0],i=r[1],u=o+s[0];for(let l=o;l<u;l++){const c=l*e+i;t.set(n.subarray(c,c+s[1]),a),a+=s[1]}}function ZV(n,e,t,r,s,a){let o=0;const i=s[0],u=s[1],l=s[2],c=i+a[0],p=u+a[1];for(let d=i;d<c;d++)for(let h=u;h<p;h++){const f=d*e+h*t+l;r.set(n.subarray(f,f+a[2]),o),o+=a[2]}}function JV(n,e,t,r,s,a,o){let i=0;const u=a[0],l=a[1],c=a[2],p=u+o[0],d=l+o[1],h=c+o[2],f=a[3];for(let m=u;m<p;m++)for(let g=l;g<d;g++)for(let y=c;y<h;y++){const x=m*e+g*t+y*r+f;s.set(n.subarray(x,x+o[3]),i),i+=o[3]}}const e4={kernelName:ul,backendName:"wasm",kernelFunc:qr};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t4(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:a,crops:o}=r,i=a.reduce((y,x)=>y*x),u=Sa(s.shape,a,i),l=$a(u.length,a.length),c=Ia(s.shape,a,i),p=np(o,a.length),d=rp(c,o,a.length),h=Gt({inputs:{x:s},backend:t,attrs:{shape:u}}),f=gr({inputs:{x:h},backend:t,attrs:{perm:l}}),m=Gt({inputs:{x:f},backend:t,attrs:{shape:c}}),g=qr({inputs:{x:m},backend:t,attrs:{begin:p,size:d}});return t.disposeData(h.dataId),t.disposeData(f.dataId),t.disposeData(h.dataId),g}const n4={kernelName:Tc,backendName:"wasm",kernelFunc:t4};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ds(n){const{inputs:{x:e},attrs:{dtype:t},backend:r}=n,s=r.makeOutput(e.shape,t),a=r.typedArrayFromHeap(e);return r.typedArrayFromHeap(s).set(a),s}const r4={kernelName:Ao,backendName:"wasm",kernelFunc:Ds};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s4=bt(Cc);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ux;function a4(n){ux=n.wasm.cwrap(Oo,null,["number","number","number","number"])}function o4(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{clipValueMin:a,clipValueMax:o}=r,i=t.dataIdMap.get(s.dataId).id,u=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(u.dataId).id;return ux(i,a,o,l),u}const i4={kernelName:Oo,backendName:"wasm",setupFunc:a4,kernelFunc:o4};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cx(n){const{inputs:e,backend:t}=n,r=ct(n.attrs.axis,e[0].shape)[0],s=e.map(h=>h.shape);Jl(s,r);let a=Pn(e.map(h=>h.shape),r);const o=e.filter(h=>V(h.shape)>0);if(o.length===1)return Mi({inputs:{x:o[0]},backend:t});const i=t.makeOutput(a,e[0].dtype);if(V(a)===0)return i;if(o[0].dtype==="string"){const h=o.map(w=>{const $=[-1,V(w.shape.slice(r))];return Gt({inputs:{x:w},backend:t,attrs:{shape:$}})}),f=h.map(w=>({vals:t.readSync(w.dataId),shape:w.shape}));a=Pn(h.map(w=>w.shape),1);const m=h[0].shape[0]===1,g=Hg(f,a,e[0].dtype,m),y=Pn(o.map(w=>w.shape),r);i.shape=y;const x=t.dataIdMap.get(i.dataId);return x.stringBytes=yp(g),h.forEach(w=>t.disposeData(w.dataId)),i}const u=V(o[0].shape.slice(0,r));let l=0;const c=o.map(h=>{const f=V(h.shape.slice(r));return l+=f,f}),p=o.map(h=>t.typedArrayFromHeap(h)),d=t.typedArrayFromHeap(i);for(let h=0;h<u;h++){let f=h*l;for(let m=0;m<p.length;m++){const g=c[m],y=h*g,x=p[m].subarray(y,y+g);d.set(x,f),f+=g}}return i}const u4={kernelName:_c,backendName:"wasm",kernelFunc:cx};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lx;function c4(n){lx=n.wasm.cwrap(Fo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function l4(n){const{inputs:e,attrs:t,backend:r}=n,{x:s,filter:a}=e,o=r.dataIdMap.get(s.dataId).id,i=r.dataIdMap.get(a.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:p,dataFormat:d}=t,h=wr(d),f=It(s.shape,a.shape,u,l,c,p,!1,h),m=f.filterHeight,g=f.filterWidth,y=f.padInfo.top,x=f.padInfo.right,w=f.padInfo.bottom,v=f.padInfo.left,$=f.dilationHeight,C=f.dilationWidth,k=f.strideHeight,R=f.strideWidth,F=f.inChannels,D=f.outChannels,M=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);const U=r.makeOutput(f.outShape,"float32"),j=r.dataIdMap.get(U.dataId).id;return lx(o,s.shape[0],s.shape[1],s.shape[2],i,m,g,y,x,w,v,M,$,C,k,R,F,D,j),U}const p4={kernelName:Fo,backendName:"wasm",setupFunc:c4,kernelFunc:l4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let px;function d4(n){px=n.wasm.cwrap(Do,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function h4(n){const{backend:e,inputs:t,attrs:r}=n,{dy:s,filter:a}=t,{strides:o,pad:i,dataFormat:u,dimRoundingMode:l,inputShape:c}=r,p=1,d=wr(u),h=It(c,a.shape,o,p,i,l,!1,d),{batchSize:f,filterHeight:m,filterWidth:g,inChannels:y,inHeight:x,inWidth:w,outChannels:v,outHeight:$,outWidth:C,strideHeight:k,strideWidth:R}=h,F=m-1-h.padInfo.top,D=g-1-h.padInfo.left,M=h.dataFormat==="channelsLast",U=Ve(h.inShape),j=Ve(s.shape),[Y,Q,ae]=Ve(a.shape),me=U[0],le=M?U[1]:U[2],De=M?U[2]:1,Xe=M?1:U[1],lt=j[0],wt=M?j[1]:j[2],Je=M?j[2]:1,Nn=M?1:j[1],jt=e.makeOutput(h.inShape,"float32"),En=e.dataIdMap.get(jt.dataId).id,Ir=e.dataIdMap.get(s.dataId).id,nt=e.dataIdMap.get(a.dataId).id;return px(Ir,nt,f,m,g,x,w,y,$,C,v,k,R,F,D,Y,Q,ae,me,le,De,Xe,lt,wt,Je,Nn,En),jt}const f4={kernelName:Do,backendName:"wasm",setupFunc:d4,kernelFunc:h4};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m4=bt(kc);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g4=bt(Nc);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var hc;(function(n){n[n.bilinear=0]="bilinear",n[n.nearest=1]="nearest"})(hc||(hc={}));let dx;function y4(n){dx=n.wasm.cwrap(Mo,null,["number","number","number","number","array","number","number","number","number","number"])}function x4(n){const{backend:e,inputs:t,attrs:r}=n,{method:s,extrapolationValue:a,cropSize:o}=r,{image:i,boxes:u,boxInd:l}=t,c=u.shape[0],[p,d]=o,h=[c,p,d,i.shape[3]];let f=e.dataIdMap.get(i.dataId),m;i.dtype!=="float32"&&(m=Ds({backend:e,inputs:{x:i},attrs:{dtype:"float32"}}),f=e.dataIdMap.get(m.dataId));const g=f.id,y=e.dataIdMap.get(u.dataId).id,x=e.dataIdMap.get(l.dataId).id,w=e.makeOutput(h,"float32"),v=e.dataIdMap.get(w.dataId).id,$=new Uint8Array(new Int32Array(i.shape).buffer);return dx(g,y,x,c,$,p,d,hc[s],a,v),m!=null&&e.disposeData(m.dataId),w}const b4={kernelName:Mo,backendName:"wasm",setupFunc:y4,kernelFunc:x4};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hx;function w4(n){hx=n.wasm.cwrap(Po,null,["number","number","number","number","number","number"])}function v4(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:a,exclusive:o,reverse:i}=r,u=s.shape.length;I(s.dtype==="float32"||s.dtype==="int32",()=>`cumprod does not support ${s.dtype} tensors in the WASM backend`);const l=Ht([a],u);let c=s;l!==null&&(c=gr({inputs:{x:s},attrs:{perm:l},backend:t}));const p=Tt(1,u)[0];gt("cumprod",[p],u);const d=t.makeOutput(c.shape,c.dtype),h=c.shape[p],f=t.dataIdMap.get(c.dataId).id,m=t.dataIdMap.get(d.dataId).id;hx(f,o?1:0,i?1:0,h,m,ut[s.dtype]);let g=d;if(l!==null){const y=wa(l);g=gr({inputs:{x:d},attrs:{perm:y},backend:t}),t.disposeData(c.dataId),t.disposeData(d.dataId)}return g}const S4={kernelName:Po,backendName:"wasm",setupFunc:w4,kernelFunc:v4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fx;function $4(n){fx=n.wasm.cwrap(Lo,null,["number","number","number","number","number","number"])}function I4(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:a,exclusive:o,reverse:i}=r,u=s.shape.length;I(s.dtype==="float32"||s.dtype==="int32",()=>`cumsum does not support ${s.dtype} tensors in the WASM backend`);const l=Ht([a],u);let c=s;l!==null&&(c=gr({inputs:{x:s},attrs:{perm:l},backend:t}));const p=Tt(1,u)[0];gt("cumsum",[p],u);const d=t.makeOutput(c.shape,c.dtype),h=c.shape[p],f=t.dataIdMap.get(c.dataId).id,m=t.dataIdMap.get(d.dataId).id;fx(f,o?1:0,i?1:0,h,m,ut[s.dtype]);let g=d;if(l!==null){const y=wa(l);g=gr({inputs:{x:d},attrs:{perm:y},backend:t}),t.disposeData(c.dataId),t.disposeData(d.dataId)}return g}const T4={kernelName:Lo,backendName:"wasm",setupFunc:$4,kernelFunc:I4};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mx;function C4(n){mx=n.wasm.cwrap(Bo,null,["number","number","number","array","number","array","array","number","number"])}function _4(n){const{backend:e,inputs:t,attrs:r}=n,{x:s}=t,{blockSize:a,dataFormat:o}=r,i=s.shape[0],u=o==="NHWC"?s.shape[1]:s.shape[2],l=o==="NHWC"?s.shape[2]:s.shape[3],c=o==="NHWC"?s.shape[3]:s.shape[1],p=u*a,d=l*a,h=c/(a*a),f=o==="NHWC"?[i,p,d,h]:[i,h,p,d],m=e.makeOutput(f,"float32"),y=e.dataIdMap.get(s.dataId).id,x=new Uint8Array(new Int32Array(Ve(s.shape)).buffer),w=new Uint8Array(new Int32Array(f).buffer),v=new Uint8Array(new Int32Array(Ve(f)).buffer),$=e.dataIdMap.get(m.dataId).id;return mx(y,a,o==="NHWC"?1:0,x,s.shape.length-1,w,v,f.length,$),m}const k4={kernelName:Bo,backendName:"wasm",setupFunc:C4,kernelFunc:_4};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gx;function N4(n){gx=n.wasm.cwrap(Vo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function E4(n){const{inputs:e,attrs:t,backend:r}=n,{x:s,filter:a}=e,o=r.dataIdMap.get(s.dataId).id,i=r.dataIdMap.get(a.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:p}=t,d=l==null?[1,1]:l,h=It(s.shape,a.shape,u,d,c,p,!0),f=h.filterHeight,m=h.filterWidth,g=h.padInfo.top,y=h.padInfo.right,x=h.padInfo.bottom,w=h.padInfo.left,v=h.dilationHeight,$=h.dilationWidth,C=h.strideHeight,k=h.strideWidth,R=h.inChannels,F=h.outChannels,D=h.padInfo.type==="SAME"?1:0;if(h.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);const M=r.makeOutput(h.outShape,"float32"),U=r.dataIdMap.get(M.dataId).id;return gx(o,s.shape[0],s.shape[1],s.shape[2],i,f,m,g,y,x,w,D,v,$,C,k,R,F,U),M}const R4={kernelName:Vo,backendName:"wasm",setupFunc:N4,kernelFunc:E4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A4=bt(Rc);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O4=!1,F4=_t(Ac,O4,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D4=bt(Oc,"float32");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fc(n){const{inputs:e,attrs:t,backend:r}=n,{input:s}=e,{dim:a}=t,o=s.shape.length,i=s.shape.slice();let u=a;return a<0&&(I(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+a+1),i.splice(u,0,1),Gt({inputs:{x:s},backend:r,attrs:{shape:i}})}const P4={kernelName:Fc,backendName:"wasm",kernelFunc:fc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yx(n){const{attrs:{shape:e,value:t,dtype:r},backend:s}=n,a=s.makeOutput(e,r);return s.typedArrayFromHeap(a).fill(t),a}const L4={kernelName:Dc,backendName:"wasm",kernelFunc:yx};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xx;function M4(n){xx=n.wasm.cwrap(Wo,null,["number","number","number","number","number","number"])}function B4(n){const{inputs:e,backend:t}=n,{image:r}=e,s=t.makeOutput(r.shape,r.dtype),a=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(s.dataId).id,[i,u,l,c]=r.shape;return xx(a,i,u,l,c,o),s}const V4={kernelName:Wo,backendName:"wasm",kernelFunc:B4,setupFunc:M4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W4=bt(Pc);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U4=_t(Lc);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let bx;function z4(n){bx=n.wasm.cwrap(Uo,null,["number","number","number","number","number","number","number"])}function G4(n){const{backend:e,inputs:t,attrs:r}=n,{varianceEpsilon:s}=r,{x:a,mean:o,variance:i,offset:u,scale:l}=t,c=e.dataIdMap.get(a.dataId).id,p=e.dataIdMap.get(o.dataId).id,d=e.dataIdMap.get(i.dataId).id,h=u!=null?e.dataIdMap.get(u.dataId).id:0,f=l!=null?e.dataIdMap.get(l.dataId).id:0,m=e.makeOutput(a.shape,a.dtype);if(V(a.shape)===0)return m;const g=e.dataIdMap.get(m.dataId).id;return bx(c,p,d,h,f,s,g),m}const H4={kernelName:Uo,backendName:"wasm",setupFunc:z4,kernelFunc:G4};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let wx;function j4(n){wx=n.wasm.cwrap(Js,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function q4(n){const{inputs:e,attrs:t,backend:r}=n,{x:s,filter:a,bias:o,preluActivationWeights:i}=e,{strides:u,pad:l,dilations:c,dataFormat:p,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=t,m=It(s.shape,a.shape,u,c,l,d),g=ma[h];if(g==null)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);const y=r.dataIdMap.get(s.dataId).id,x=r.dataIdMap.get(a.dataId).id,w=m.outChannels;let v=0;if(o!=null){const Je=r.dataIdMap.get(o.dataId);if(Je.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${Je.shape.length}.`);if(Je.shape[0]!==w)throw new Error(`FusedConv2D bias shape (${Je.shape}) does not match the number of output channels (${w})`);v=Je.id}const $=m.filterHeight,C=m.filterWidth,k=m.padInfo.top,R=m.padInfo.right,F=m.padInfo.bottom,D=m.padInfo.left,M=m.dilationHeight,U=m.dilationWidth,j=m.strideHeight,Y=m.strideWidth,Q=m.inChannels,ae=m.padInfo.type==="SAME"?1:0,me=m.batchSize,le=m.inHeight,De=m.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);const Xe=r.makeOutput(m.outShape,"float32"),lt=r.dataIdMap.get(Xe.dataId).id,wt=i==null?0:r.dataIdMap.get(i.dataId).id;return wx(y,me,le,De,x,$,C,v,k,R,F,D,ae,M,U,j,Y,Q,w,g,wt,f||0,lt),Xe}const K4={kernelName:Js,backendName:"wasm",setupFunc:j4,kernelFunc:q4};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vx;function X4(n){vx=n.wasm.cwrap(ea,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Y4(n){const{inputs:e,attrs:t,backend:r}=n,{x:s,filter:a,bias:o,preluActivationWeights:i}=e,{strides:u,pad:l,dilations:c,dataFormat:p,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=t,m=It(s.shape,a.shape,u,c,l,d,!0),g=ma[h];if(g==null)throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);const y=r.dataIdMap.get(s.dataId).id,x=r.dataIdMap.get(a.dataId).id,w=m.outChannels;let v=0;if(o!=null){const Je=r.dataIdMap.get(o.dataId);if(Je.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${Je.shape.length}.`);if(Je.shape[0]!==w)throw new Error(`FusedDepthwiseConv2D bias shape (${Je.shape}) does not match the number of output channels (${w})`);v=Je.id}const $=m.filterHeight,C=m.filterWidth,k=m.padInfo.top,R=m.padInfo.right,F=m.padInfo.bottom,D=m.padInfo.left,M=m.dilationHeight,U=m.dilationWidth,j=m.strideHeight,Y=m.strideWidth,Q=m.inChannels,ae=m.padInfo.type==="SAME"?1:0,me=m.batchSize,le=m.inHeight,De=m.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);const Xe=r.makeOutput(m.outShape,"float32"),lt=r.dataIdMap.get(Xe.dataId).id,wt=i==null?0:r.dataIdMap.get(i.dataId).id;return vx(y,me,le,De,x,$,C,v,k,R,F,D,ae,M,U,j,Y,Q,w,g,wt,f||0,lt),Xe}const Q4={kernelName:ea,backendName:"wasm",setupFunc:X4,kernelFunc:Y4};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Sx;function Z4(n){Sx=n.wasm.cwrap(zo,null,["number","number","number","number","number","number","array","number"])}function J4(n){const{backend:e,inputs:t}=n,{params:r,indices:s}=t,[a,o,i,u]=Dl(r,s),l=e.makeOutput(a,r.dtype);if(o===0)return l;const c=s.shape,p=c[c.length-1],h=e.dataIdMap.get(r.dataId).id,m=e.dataIdMap.get(s.dataId).id,g=new Uint8Array(new Int32Array(u).buffer),y=e.dataIdMap.get(l.dataId).id;return Sx(h,ut[r.dtype],m,o,p,i,g,y),l}const eW={kernelName:zo,backendName:"wasm",setupFunc:Z4,kernelFunc:J4};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $x;function tW(n){$x=n.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function nW(n){const{backend:e,inputs:t,attrs:r}=n,{x:s,indices:a}=t,{axis:o,batchDims:i}=r,u=ct(o,s.shape)[0],l=e.readSync(a.dataId),c=s.shape[u];for(let F=0;F<l.length;++F){const D=l[F];I(D<=c-1&&D>=0,()=>`GatherV2: the index value ${D} is not in [0, ${c-1}]`)}const p=gp(s,a,u,i),d=Gt({inputs:{x:s},attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]},backend:e}),h=V(a.shape),f=Gt({inputs:{x:a},attrs:{shape:[p.batchSize,h/p.batchSize]},backend:e}),m=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],g=e.makeOutput(m,s.dtype);if(V(s.shape)===0)return g;const y=d.shape.length-1,w=e.dataIdMap.get(d.dataId).id,$=e.dataIdMap.get(f.dataId).id,C=e.dataIdMap.get(g.dataId).id,k=new Uint8Array(new Int32Array(Ve(d.shape)).buffer),R=new Uint8Array(new Int32Array(Ve(m)).buffer);return $x(w,ut[s.dtype],k,y,$,p.batchSize,R,C),e.disposeData(d.dataId),e.disposeData(f.dataId),g.shape=p.outputShape,g}const rW={kernelName:Mc,backendName:"wasm",setupFunc:tW,kernelFunc:nW};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sW=!1,aW=_t(Bc,sW,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oW=!1,iW=_t(Vc,oW,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ix;function uW(n){Ix=n.wasm.cwrap(Ho,null,["number","number","number","number"])}function cW(n){const{inputs:{x:e},attrs:{alpha:t},backend:r}=n,s=r.dataIdMap.get(e.dataId).id,a=r.makeOutput(e.shape,"float32");if(V(e.shape)!==0){const o=r.dataIdMap.get(a.dataId).id;Ix(s,ut[e.dtype],t,o)}return a}const lW={kernelName:Ho,backendName:"wasm",setupFunc:uW,kernelFunc:cW};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pW=!1,dW=_t(Wc,pW,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hW=!1,fW=_t(Uc,hW,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mW=bt(zc);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gW=!1,yW=_t(Gc,gW,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xW=bt(Hc);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bW=!1,wW=_t(jc,bW,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vW=!1,SW=_t(Xb,vW,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Tx;function $W(n){Tx=n.wasm.cwrap(jo,null,["number","number","number","number"])}function IW(n){const{backend:e,inputs:t,attrs:r}=n,{reductionIndices:s,keepDims:a}=r,{x:o}=t;let u=e.dataIdMap.get(o.dataId).id,l=o;const{transposed:c,axes:p,originalAxes:d,inputWasTransposed:h}=$r(o,s,e);if(h){const w=e.dataIdMap.get(c.dataId).id;l=c,u=w}const f=l.shape.length;gt("max",p,f);const[m,g]=kt(l.shape,p),y=V(g),x=e.makeOutput(m,o.dtype);if(V(l.shape)!==0){const w=e.dataIdMap.get(x.dataId).id;Tx(u,ut[o.dtype],y,w)}if(h&&e.disposeData(c.dataId),a){const w=mt(x.shape,d);x.shape=w}return x}const TW={kernelName:jo,backendName:"wasm",setupFunc:$W,kernelFunc:IW};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CW=_t(qc);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Cx;function _W(n){Cx=n.wasm.cwrap(qo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function kW(n){const{inputs:e,attrs:t,backend:r}=n,s=e.x,a=r.dataIdMap.get(s.dataId).id;I(s.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${s.dtype}.`);const{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=t,c=nr(s.shape,o,i,1,u,l),p=c.filterHeight,d=c.filterWidth,h=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,y=c.dilationHeight,x=c.dilationWidth,w=c.strideHeight,v=c.strideWidth,$=c.inChannels,C=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);const k=r.makeOutput(c.outShape,"float32"),R=r.dataIdMap.get(k.dataId).id;return Cx(a,s.shape[0],s.shape[1],s.shape[2],p,d,h,f,m,g,y,x,w,v,$,C,R),k}const NW={kernelName:qo,backendName:"wasm",setupFunc:_W,kernelFunc:kW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _x;function EW(n){_x=n.wasm.cwrap(Ko,null,["number, number, number"])}function RW(n){const{backend:e,inputs:t,attrs:r}=n,{axis:s,keepDims:a}=r,{x:o}=t,i=e.dataIdMap.get(o.dataId).id;let u=i,l=o;const{transposed:c,axes:p,originalAxes:d,inputWasTransposed:h}=$r(o,s,e);let f=p;if(h){const v=e.dataIdMap.get(c.dataId).id;v!==i&&(l=c,u=v,f=Tt(f.length,l.shape.length))}gt("mean",f,l.shape.length);const[m,g]=kt(l.shape,f),y=V(g);let x=l;l.dtype!=="float32"&&(x=Ds({backend:e,inputs:{x:l},attrs:{dtype:"float32"}}),u=e.dataIdMap.get(x.dataId).id);const w=e.makeOutput(m,"float32");if(V(l.shape)!==0){const v=e.dataIdMap.get(w.dataId).id;_x(u,y,v)}if(h&&e.disposeData(c.dataId),a){const v=mt(w.shape,d);w.shape=v}return l.dtype!=="float32"&&e.disposeData(x.dataId),w}const AW={kernelName:Ko,backendName:"wasm",setupFunc:EW,kernelFunc:RW};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let kx;function OW(n){kx=n.wasm.cwrap(Xo,null,["number","number","number","number"])}function FW(n){const{backend:e,inputs:t,attrs:r}=n,{axis:s,keepDims:a}=r,{x:o}=t,i=e.dataIdMap.get(o.dataId).id;let u=i,l=o;const{transposed:c,axes:p,originalAxes:d,inputWasTransposed:h}=$r(o,s,e);if(h){const w=e.dataIdMap.get(c.dataId).id;w!==i&&(l=c,u=w)}const f=l.shape.length;gt("min",p,f);const[m,g]=kt(l.shape,p),y=V(g),x=e.makeOutput(m,l.dtype);if(V(l.shape)!==0){const w=e.dataIdMap.get(x.dataId).id;kx(u,ut[o.dtype],y,w)}if(h&&e.disposeData(c.dataId),a){const w=mt(x.shape,d);x.shape=w}return x}const DW={kernelName:Xo,backendName:"wasm",setupFunc:OW,kernelFunc:FW};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PW=_t(Kc);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var mc;(function(n){n[n.reflect=0]="reflect",n[n.symmetric=1]="symmetric"})(mc||(mc={}));let Nx;function LW(n){Nx=n.wasm.cwrap(Yo,null,["number","array","number","number","array","array","number","number"])}function MW(n){const{inputs:{x:e},backend:t,attrs:{paddings:r,mode:s}}=n,a=r.map((f,m)=>f[0]+e.shape[m]+f[1]),o=t.dataIdMap.get(e.dataId).id,i=t.makeOutput(a,e.dtype),u=t.dataIdMap.get(i.dataId).id,l=new Uint8Array(new Int32Array(e.shape).buffer),c=r.map(f=>f[0]),p=r.map(f=>f[1]),d=new Uint8Array(new Int32Array(c).buffer),h=new Uint8Array(new Int32Array(p).buffer);return Nx(o,l,e.shape.length,ut[e.dtype],d,h,mc[s],u),i}const BW={kernelName:Yo,backendName:"wasm",kernelFunc:MW,setupFunc:LW};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VW=_t(Xc);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WW=bt(Yc);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kp(n,e){const t=new Int32Array(n.wasm.HEAPU8.buffer,e,4),r=t[0],s=t[1],a=t[2],o=t[3];return n.wasm._free(e),{pSelectedIndices:r,selectedSize:s,pSelectedScores:a,pValidOutputs:o}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ex;function UW(n){Ex=n.wasm.cwrap(Qo,"number",["number","number","number","number","number"])}function zW(n){const{backend:e,inputs:t,attrs:r}=n,{iouThreshold:s,maxOutputSize:a,scoreThreshold:o}=r,{boxes:i,scores:u}=t,l=e.dataIdMap.get(i.dataId).id,c=e.dataIdMap.get(u.dataId).id,p=Ex(l,c,a,s,o),{pSelectedIndices:d,selectedSize:h,pSelectedScores:f,pValidOutputs:m}=kp(e,p);return e.wasm._free(f),e.wasm._free(m),e.makeOutput([h],"int32",d)}const GW={kernelName:Qo,backendName:"wasm",setupFunc:UW,kernelFunc:zW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Rx;function HW(n){Rx=n.wasm.cwrap(Zo,"number",["number","number","number","number","number","bool"])}function jW(n){const{backend:e,inputs:t,attrs:r}=n,{iouThreshold:s,maxOutputSize:a,scoreThreshold:o,padToMaxOutputSize:i}=r,{boxes:u,scores:l}=t,c=e.dataIdMap.get(u.dataId).id,p=e.dataIdMap.get(l.dataId).id,d=Rx(c,p,a,s,o,i),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=kp(e,d);e.wasm._free(m);const y=e.makeOutput([f],"int32",h),x=e.makeOutput([],"int32",g);return[y,x]}const qW={kernelName:Zo,backendName:"wasm",setupFunc:HW,kernelFunc:jW};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ax;function KW(n){Ax=n.wasm.cwrap(Jo,"number",["number","number","number","number","number","number"])}function XW(n){const{backend:e,inputs:t,attrs:r}=n,{iouThreshold:s,maxOutputSize:a,scoreThreshold:o,softNmsSigma:i}=r,{boxes:u,scores:l}=t,c=e.dataIdMap.get(u.dataId).id,p=e.dataIdMap.get(l.dataId).id,d=Ax(c,p,a,s,o,i),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=kp(e,d);e.wasm._free(g);const y=e.makeOutput([f],"int32",h),x=e.makeOutput([f],"float32",m);return[y,x]}const YW={kernelName:Jo,backendName:"wasm",setupFunc:KW,kernelFunc:XW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QW=!1,ZW=_t(Qc,QW,"bool");/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ox;function JW(n){Ox=n.wasm.cwrap(ei,null,["number","number","number","number","number"])}function eU(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{dtype:a,depth:o,onValue:i,offValue:u}=r,l=t.makeOutput([...s.shape,o],a),c=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(s.dataId).id;return Ox(d,o,i,u,c),l}const tU={kernelName:ei,backendName:"wasm",setupFunc:JW,kernelFunc:eU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nU(n){const{inputs:{x:e},backend:t}=n,r=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(r).fill(1),r}const rU={kernelName:Zc,backendName:"wasm",kernelFunc:nU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sU(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return fc({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const a=e[0].shape,o=e[0].dtype;e.forEach(c=>{Zt(a,c.shape,"All tensors passed to stack must have matching shapes"),I(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],u=e.map(c=>{const p=fc({inputs:{input:c},backend:t,attrs:{dim:s}});return i.push(p),p}),l=cx({inputs:u,backend:t,attrs:{axis:s}});return i.forEach(c=>t.disposeData(c.dataId)),l}const aU={kernelName:Jc,backendName:"wasm",kernelFunc:sU};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Fx;function oU(n){Fx=n.wasm.cwrap(ti,null,["number","array","number","number","array","array","number","number"])}function iU(n){const{inputs:{x:e},backend:t,attrs:{paddings:r,constantValue:s}}=n,a=r.map((m,g)=>m[0]+e.shape[g]+m[1]);if(V(e.shape)===0)return yx({backend:t,attrs:{shape:a,value:s,dtype:e.dtype}});const o=t.dataIdMap.get(e.dataId).id,i=t.makeOutput(a,e.dtype),l=t.dataIdMap.get(i.dataId).id,c=new Uint8Array(new Int32Array(e.shape).buffer),p=r.map(m=>m[0]),d=r.map(m=>m[1]),h=new Uint8Array(new Int32Array(p).buffer),f=new Uint8Array(new Int32Array(d).buffer);return Fx(o,c,e.shape.length,ut[e.dtype],h,f,s,l),i}const Dx={kernelName:ti,backendName:"wasm",kernelFunc:iU,setupFunc:oU};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uU=_t(el);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Px;function cU(n){Px=n.wasm.cwrap(ni,null,["number","number","number"])}function lU(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e,a=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(s.dataId).id;let i=a;const u=r;let l=u;u.dtype!=="float32"&&(l=Ds({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),i=t.dataIdMap.get(l.dataId).id);const c=t.makeOutput(r.shape,"float32"),p=t.dataIdMap.get(c.dataId).id;return Px(i,o,p),u.dtype!=="float32"&&t.disposeData(l.dataId),c}const pU={kernelName:ni,backendName:"wasm",setupFunc:cU,kernelFunc:lU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Lx;function dU(n){Lx=n.wasm.cwrap(ri,null,["number","number","number","number"])}function hU(n){const{backend:e,inputs:t,attrs:r}=n,{axis:s,keepDims:a}=r,{x:o}=t,i=e.dataIdMap.get(o.dataId).id;let u=i,l=o;const{transposed:c,axes:p,originalAxes:d,inputWasTransposed:h}=$r(o,s,e);let f=p;if(h){const w=e.dataIdMap.get(c.dataId).id;w!==i&&(l=c,u=w,f=Tt(f.length,l.shape.length))}gt("prod",f,l.shape.length);const[m,g]=kt(l.shape,f),y=V(g),x=e.makeOutput(m,l.dtype);if(V(l.shape)!==0){const w=e.dataIdMap.get(x.dataId).id;Lx(u,y,ut[x.dtype],w)}if(h&&e.disposeData(c.dataId),a){const w=mt(x.shape,d);x.shape=w}return x}const fU={kernelName:ri,backendName:"wasm",setupFunc:dU,kernelFunc:hU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mU=n=>{const{backend:e,attrs:t}=n,{start:r,stop:s,step:a,dtype:o}=t,i=qg(r,s,a,o),u=e.makeOutput([i.length],o);return e.typedArrayFromHeap(u).set(i),u},gU={kernelName:tl,backendName:"wasm",kernelFunc:mU};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yU=_t(Ec);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xU=bt(nl);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bU=bt(sl);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Mx;function wU(n){Mx=n.wasm.cwrap(ai,null,["number","number","number","number","number","number","number","number","number","number"])}function vU(n){const{backend:e,inputs:t,attrs:r}=n,{images:s}=t,{alignCorners:a,halfPixelCenters:o,size:i}=r,[u,l]=i,[c,p,d,h]=s.shape,f=[c,u,l,h];let m=e.dataIdMap.get(s.dataId),g;m.dtype!=="float32"&&(g=Ds({backend:e,inputs:{x:s},attrs:{dtype:"float32"}}),m=e.dataIdMap.get(g.dataId));const y=m.id,x=e.makeOutput(f,"float32");if(V(s.shape)===0)return x;const w=e.dataIdMap.get(x.dataId).id;return Mx(y,c,p,d,h,u,l,a?1:0,o?1:0,w),g!=null&&e.disposeData(g.dataId),x}const SU={kernelName:ai,backendName:"wasm",setupFunc:wU,kernelFunc:vU};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Bx;function $U(n){Bx=n.wasm.cwrap(si,null,["number","number","number","number","number","number","number","number","number","number"])}function IU(n){const{backend:e,inputs:t,attrs:r}=n,{images:s}=t,{alignCorners:a,halfPixelCenters:o,size:i}=r,[u,l]=i,[c,p,d,h]=s.shape,f=[c,u,l,h],m=e.makeOutput(f,"float32");if(V(s.shape)===0)return m;let g=e.dataIdMap.get(s.dataId),y;g.dtype!=="float32"&&(y=Ds({backend:e,inputs:{x:s},attrs:{dtype:"float32"}}),g=e.dataIdMap.get(y.dataId));const x=g.id,w=e.dataIdMap.get(m.dataId).id;return Bx(x,c,p,d,h,u,l,a?1:0,o?1:0,w),y!=null&&e.disposeData(y.dataId),m}const TU={kernelName:si,backendName:"wasm",setupFunc:$U,kernelFunc:IU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Vx;function CU(n){Vx=n.wasm.cwrap(oi,null,["number","array","number","array","number","number"])}function _U(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:a}=r,o=ct(a,s.shape);if(s.shape.length===0)return Mi({inputs:{x:s},backend:t});const i=t.makeOutput(s.shape,s.dtype),u=t.dataIdMap.get(s.dataId).id,l=t.dataIdMap.get(i.dataId).id,c=new Uint8Array(new Int32Array(o).buffer),p=new Uint8Array(new Int32Array(s.shape).buffer);Vx(u,c,o.length,p,s.shape.length,l);const d=Gt({inputs:{x:i},attrs:{shape:s.shape},backend:t});return t.disposeData(i.dataId),d}const kU={kernelName:oi,backendName:"wasm",kernelFunc:_U,setupFunc:CU};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Wx;function NU(n){Wx=n.wasm.cwrap(mi,null,["number","number","number","number","number","number","number","number","array","number","number"])}function EU(n){const{inputs:e,backend:t,attrs:r}=n,{image:s}=e,{radians:a,fillValue:o,center:i}=r,u=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(s.dataId).id,c=t.dataIdMap.get(u.dataId).id,[p,d,h,f]=s.shape,[m,g]=tp(i,d,h),y=o===0,x=255,w=typeof o=="number"?[o,o,o,y?0:x]:[...o,x],v=new Uint8Array(new Int32Array(w).buffer);return Wx(l,p,d,h,f,a,m,g,v,w.length,c),u}const RU={kernelName:mi,backendName:"wasm",kernelFunc:EU,setupFunc:NU};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AU=bt(al);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OU=bt(ol);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ux;function FU(n){Ux=n.wasm.cwrap(ii,null,["number","number","number","number","number","number","array","number","number"])}function DU(n){const{backend:e,inputs:t,attrs:r}=n,{indices:s,updates:a}=t,{shape:o}=r,i=e.makeOutput(o,a.dtype);if(V(o)===0)return i;const{sliceRank:u,numUpdates:l,sliceSize:c,strides:p,outputSize:d}=bi(a,s,o),f=e.dataIdMap.get(s.dataId).id,g=e.dataIdMap.get(a.dataId).id,y=new Uint8Array(new Int32Array(p).buffer),x=e.dataIdMap.get(i.dataId).id;return Ux(f,g,ut[a.dtype],u,l,c,y,d,x),i}const PU={kernelName:ii,backendName:"wasm",setupFunc:FU,kernelFunc:DU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zx;function LU(n){zx=n.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function MU(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:a}=e,o=t.dataIdMap.get(r.dataId).id,i=t.dataIdMap.get(s.dataId).id,u=t.dataIdMap.get(a.dataId).id,l=t.makeOutput(s.shape,s.dtype),c=t.dataIdMap.get(l.dataId).id,p=r.shape.length,d=s.shape.length,h=p===0||p>1||d===1?1:V(s.shape.slice(1));return zx(o,i,u,h,c),l}const BU={kernelName:il,backendName:"wasm",kernelFunc:MU,setupFunc:LU};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Gx;function VU(n){Gx=n.wasm.cwrap(ll,null,["number","number"])}function WU(n){const{backend:e,inputs:{x:t}}=n,r=e.dataIdMap.get(t.dataId).id,s=e.makeOutput(t.shape,t.dtype),a=e.dataIdMap.get(s.dataId).id;return V(s.shape)===0||Gx(r,a),s}const UU={kernelName:"Sigmoid",backendName:"wasm",setupFunc:VU,kernelFunc:WU};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zU=bt(cl);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Hx;function GU(n){Hx=n.wasm.cwrap(ci,null,["number","number","number","number"])}function HU(n){const{backend:e,inputs:{logits:t},attrs:{dim:r}}=n,s=e.dataIdMap.get(t.dataId).id,a=e.makeOutput(t.shape,t.dtype),o=e.dataIdMap.get(a.dataId).id,i=t.shape[r],u=V(t.shape)/i;return V(a.shape)===0||Hx(s,o,i,u),a}const jU={kernelName:ci,backendName:"wasm",setupFunc:GU,kernelFunc:HU};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qU(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:a,paddings:o}=r,i=V(a),u=[[0,0]];u.push(...o);for(let C=1+a.length;C<s.shape.length;++C)u.push([0,0]);const l=Dx.kernelFunc({inputs:{x:s},backend:t,attrs:{paddings:u,constantValue:0}}),c=Sa(l.shape,a,i,!1),p=$a(c.length,a.length,!1),d=Ia(l.shape,a,i,!1),m=Gt({inputs:{x:l},backend:t,attrs:{shape:c}}),x=gr({inputs:{x:m},backend:t,attrs:{perm:p}}),$=Gt({inputs:{x},backend:t,attrs:{shape:d}});return t.disposeData(l.dataId),t.disposeData(m.dataId),t.disposeData(x.dataId),$}const KU={kernelName:dl,backendName:"wasm",kernelFunc:qU};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let jx;function XU(n){jx=n.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function YU(n){const{backend:e,inputs:t}=n,{indices:r,values:s,denseShape:a,defaultValue:o}=t,i=r.shape[0],u=r.shape[1],l=e.readSync(a.dataId)[0],c=[i+l,u],p=e.dataIdMap.get(r.dataId).id,d=e.dataIdMap.get(s.dataId).id,h=e.dataIdMap.get(o.dataId).id,f=e.makeOutput(c,r.dtype),m=e.dataIdMap.get(f.dataId).id,g=e.makeOutput(c.slice(0,1),s.dtype),y=e.dataIdMap.get(g.dataId).id,x=e.makeOutput([l],"bool"),w=e.dataIdMap.get(x.dataId).id,v=e.makeOutput([i],r.dtype),$=e.dataIdMap.get(v.dataId).id,C=e.makeOutput([4],"int32"),k=e.dataIdMap.get(C.dataId).id,R=jx(p,d,ut[s.dtype],i,l,u,h,m,y,w,$,k),F=e.readSync(C.dataId);let D;switch(F[0]){case 1:{D=ap(F[1]);break}case 2:{D=op(F[1],F[2]);break}case 3:D=ip(F[1],F[2],F[3]);break;default:D=""}if(e.disposeData(C.dataId),D)throw e.disposeData(f.dataId),e.disposeData(g.dataId),e.disposeData(x.dataId),e.disposeData(v.dataId),new Error(D);let M=f,U=g;return R!==c[0]&&(M=qr({inputs:{x:f},attrs:{begin:0,size:[R,u]},backend:e}),U=qr({inputs:{x:g},attrs:{begin:0,size:R},backend:e}),e.disposeData(f.dataId),e.disposeData(g.dataId)),[M,U,x,v]}const QU={kernelName:fl,backendName:"wasm",setupFunc:XU,kernelFunc:YU};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qx;function ZU(n){qx=n.wasm.cwrap(li,null,["number","number","number","number","number","number","number"])}function JU(n){const{backend:e,inputs:t}=n,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const o=e.dataIdMap.get(r.dataId).id,i=e.dataIdMap.get(s.dataId).id,u=e.dataIdMap.get(a.dataId).id,l=r.shape[0],c=V(a.shape),p=e.makeOutput([l,c],r.dtype),d=e.dataIdMap.get(p.dataId).id,h=e.makeOutput([c],a.dtype),f=e.dataIdMap.get(h.dataId).id,m=e.makeOutput([3],"int32"),g=e.dataIdMap.get(m.dataId).id;qx(o,i,u,l,d,f,g);const y=e.readSync(m.dataId);let x;switch(y[0]){case 0:{x=up(y[1],y[2]);break}case 1:{x=cp(y[1],y[2]);break}case 2:x=lp();break;case 3:{const w=Array.from(e.readSync(s.dataId)),v=Array.from(e.readSync(h.dataId));x=pp(w,v);break}case 4:{const w=Array.from(e.readSync(s.dataId)),v=Array.from(e.readSync(h.dataId));x=dp(w,v);break}default:x=""}if(e.disposeData(m.dataId),x)throw e.disposeData(p.dataId),e.disposeData(h.dataId),new Error(x);return[p,h]}const ez={kernelName:li,backendName:"wasm",setupFunc:ZU,kernelFunc:JU};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Kx;function Xx(n){Kx=n.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function Yx(n,e){const{backend:t,inputs:r}=n,{data:s,indices:a,segmentIds:o}=r,i=a.shape[0],u=t.readSync(o.dataId,i-1,i)[0],c=i>0?u+1:0;if(c<0)throw new Error(ia());const p=s.shape.slice();p[0]=c;const d=t.dataIdMap.get(s.dataId).id,h=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(o.dataId).id,m=t.makeOutput(p,s.dtype),g=t.dataIdMap.get(m.dataId).id,y=t.makeOutput([4],"int32"),x=t.dataIdMap.get(y.dataId).id;Kx(d,ut[s.dtype],s.shape[0],h,f,g,x,e,0);const w=t.readSync(y.dataId);let v;switch(w[0]){case 0:{v=ia();break}case 1:{v=hp();break}case 2:v=fp(w[1],w[2]);break;case 3:v=mp(w[1],w[2],w[3]);break;default:v=""}if(t.disposeData(y.dataId),v)throw t.disposeData(m.dataId),new Error(v);return m}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tz(n){return Yx(n,!0)}const nz={kernelName:ml,backendName:"wasm",setupFunc:Xx,kernelFunc:tz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rz(n){return Yx(n,!1)}const sz={kernelName:gl,backendName:"wasm",setupFunc:Xx,kernelFunc:rz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function az(n){const{inputs:e,attrs:t,backend:r}=n,{x:s}=e,{numOrSizeSplits:a,axis:o}=t,i=ct(o,s.shape)[0],u=sp(s,a,i),l=new Array(s.shape.length).fill(0),c=s.shape.slice();return u.map(p=>{const d=[...c];d[i]=p;const h=qr({inputs:{x:s},attrs:{begin:l,size:d},backend:r});return l[i]+=p,h})}const oz={kernelName:hl,backendName:"wasm",kernelFunc:az};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iz=bt(pl);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uz=bt(Ef);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cz=_t(yl);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qx;function lz(n){Qx=n.wasm.cwrap(fi,null,["number","number","number","number"])}function pz(n){const{backend:e,inputs:t,attrs:r}=n,{alpha:s}=r,{x:a}=t,o=e.dataIdMap.get(a.dataId).id,i=e.makeOutput(a.shape,a.dtype),u=e.dataIdMap.get(i.dataId).id;return Qx(o,s,ut[a.dtype],u),i}const dz={kernelName:fi,backendName:"wasm",setupFunc:lz,kernelFunc:pz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Zx;function hz(n){Zx=n.wasm.cwrap(pi,null,["number","array","number","array","array","array","array","array","number","number"])}function fz(n){const{backend:e,inputs:t,attrs:r}=n,{x:s}=t,{begin:a,end:o,strides:i,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:d}=r,{finalShapeSparse:h,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:x,end:w,strides:v}=Ml(s.shape,a,o,i,u,l,c,p,d);let $;if(m)$=Gt({inputs:{x:s},backend:e,attrs:{shape:f}});else if(g||y){I(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const C=Pl(x,w,v),k=qr({inputs:{x:s},backend:e,attrs:{begin:x,size:C}});$=Gt({inputs:{x:k},backend:e,attrs:{shape:f}}),e.disposeData(k.dataId)}else{const C=e.makeOutput(h,"float32"),k=e.dataIdMap.get(s.dataId).id,R=new Uint8Array(new Int32Array(Ve(s.shape)).buffer),F=new Uint8Array(new Int32Array(x).buffer),D=new Uint8Array(new Int32Array(w).buffer),M=new Uint8Array(new Int32Array(v).buffer),U=new Uint8Array(new Int32Array(h).buffer),j=new Uint8Array(new Int32Array(Ve(h)).buffer),Y=e.dataIdMap.get(C.dataId).id;Zx(k,R,s.shape.length,F,D,M,U,j,h.length,Y),$=Gt({inputs:{x:C},backend:e,attrs:{shape:f}}),e.disposeData(C.dataId)}return $}const mz={kernelName:pi,backendName:"wasm",setupFunc:hz,kernelFunc:fz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gz(n){const{backend:e,inputs:t,attrs:r}=n,{data:s,dataSplits:a}=t,{separator:o,nGramWidths:i,leftPad:u,rightPad:l,padWidth:c,preserveShortSequences:p}=r,d=e.readSync(s.dataId),h=e.readSync(a.dataId),[f,m]=Kg(d,h,o,i,u,l,c,p),g=e.makeOutput([f.length],"string"),y=e.dataIdMap.get(g.dataId);y.stringBytes=f;const x=e.makeOutput(a.shape,"int32");return e.typedArrayFromHeap(x).set(m),[g,x]}const yz={kernelName:xl,backendName:"wasm",kernelFunc:gz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xz(n){const{backend:e,inputs:t,attrs:r}=n,{input:s,delimiter:a}=t,{skipEmpty:o}=r,i=e.readSync(s.dataId),u=e.readSync(a.dataId),[l,c,p]=Xg(i,u[0],o),d=c.length,h=e.makeOutput([d,2],"int32");e.typedArrayFromHeap(h).set(l);const m=e.makeOutput([d],"string"),g=e.dataIdMap.get(m.dataId);g.stringBytes=c;const y=e.makeOutput([2],"int32");return e.typedArrayFromHeap(y).set(p),[h,m,y]}const bz={kernelName:bl,backendName:"wasm",kernelFunc:xz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wz(n){const{backend:e,inputs:t,attrs:r}=n,{input:s}=t,{numBuckets:a}=r,o=e.readSync(s.dataId),i=Yg(o,a),u=e.makeOutput(s.shape,"int32");return e.typedArrayFromHeap(u).set(i),u}const vz={kernelName:wl,backendName:"wasm",kernelFunc:wz};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sz=_t(vl);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Jx;function $z(n){Jx=n.wasm.cwrap(ui,null,["number","number","number","number"])}function Iz(n){const{backend:e,inputs:t,attrs:r}=n,{axis:s,keepDims:a}=r,{x:o}=t,i=e.dataIdMap.get(o.dataId).id;let u=i,l=o;const{transposed:c,axes:p,originalAxes:d,inputWasTransposed:h}=$r(o,s,e);let f=p;if(h){const w=e.dataIdMap.get(c.dataId).id;w!==i&&(l=c,u=w,f=Tt(f.length,l.shape.length))}gt("sum",f,l.shape.length);const[m,g]=kt(l.shape,f),y=V(g),x=e.makeOutput(m,l.dtype);if(V(l.shape)!==0){const w=e.dataIdMap.get(x.dataId).id;Jx(u,y,ut[x.dtype],w)}if(h&&e.disposeData(c.dataId),a){const w=mt(x.shape,d);x.shape=w}return x}const Tz={kernelName:ui,backendName:"wasm",setupFunc:$z,kernelFunc:Iz};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cz=bt(Sl);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _z=bt($l);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eb;function kz(n){eb=n.wasm.cwrap(ga,null,["number","array","number","array","number","number"])}function Nz(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,a=t.dataIdMap.get(s.dataId).id,{reps:o}=r,i=new Array(s.shape.length);for(let d=0;d<i.length;d++)i[d]=s.shape[d]*o[d];const u=new Uint8Array(new Int32Array(s.shape).buffer),l=new Uint8Array(new Int32Array(i).buffer),c=t.makeOutput(i,s.dtype),p=t.dataIdMap.get(c.dataId).id;return eb(a,u,s.shape.length,l,i.length,ut[c.dtype],p),c}const Ez={kernelName:ga,backendName:"wasm",setupFunc:kz,kernelFunc:Nz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tb;function Rz(n){tb=n.wasm.cwrap(di,null,["number","array","number","number","number","bool","number","number"])}const Az=({inputs:n,backend:e,attrs:t})=>{const{x:r}=n,{k:s,sorted:a}=t,o=e.dataIdMap.get(r.dataId).id,i=new Uint8Array(new Int32Array(r.shape).buffer),u=r.shape.slice();u[u.length-1]=s;const l=e.makeOutput(u,r.dtype),c=e.dataIdMap.get(l.dataId).id,p=e.makeOutput(u,"int32"),d=e.dataIdMap.get(p.dataId).id;return tb(o,i,r.shape.length,ut[r.dtype],s,a,c,d),[l,p]},Oz={kernelName:di,backendName:"wasm",setupFunc:Rz,kernelFunc:Az};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nb;function Fz(n){nb=n.wasm.cwrap(hi,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function Dz(n){const{backend:e,inputs:t,attrs:r}=n,{image:s,transforms:a}=t,{interpolation:o,fillMode:i,fillValue:u,outputShape:l}=r,[c,p,d,h]=s.shape,[f,m]=l!=null?l:[p,d],g=[c,f,m,h],y=new Uint8Array(new Int32Array(Ve(s.shape)).buffer),x=new Uint8Array(new Int32Array(Ve(g)).buffer),w=e.makeOutput(g,s.dtype),v=e.dataIdMap.get(w.dataId).id,C=e.dataIdMap.get(s.dataId).id,R=e.dataIdMap.get(a.dataId).id,F=o==="nearest"?1:2;let D;switch(i){case"constant":D=1;break;case"reflect":D=2;break;case"wrap":D=3;break;case"nearest":D=4;break;default:D=1;break}return nb(C,R,a.shape[0]>1,c,f,m,h,d,p,y,s.shape.length-1,x,g.length-1,F,D,u,v),w}const Pz={kernelName:hi,backendName:"wasm",setupFunc:Fz,kernelFunc:Dz};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lz(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:a}=r;a<0&&(a+=s.shape.length);const o=s.shape[a],i=s.shape.length,u=new Array(i-1);let l=0;for(let h=0;h<i;h++)h!==a&&(u[l++]=s.shape[h]);const c=new Array(o),p=new Array(i).fill(0),d=s.shape.slice();d[a]=1;for(let h=0;h<c.length;h++)p[a]=h,c[h]=qr({inputs:{x:s},attrs:{begin:p,size:d},backend:t});return c.map(({dataId:h,dtype:f})=>({dataId:h,dtype:f,shape:u}))}const Mz={kernelName:Il,backendName:"wasm",kernelFunc:Lz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bz(n){const{inputs:{x:e},backend:t}=n,r=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(r).fill(0),r}const Vz={kernelName:Tl,backendName:"wasm",kernelFunc:Bz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wz=[IV,TV,CV,NV,LV,VV,zV,jV,YV,n4,r4,s4,i4,u4,p4,f4,m4,g4,b4,S4,T4,k4,R4,A4,F4,D4,P4,L4,V4,W4,U4,H4,K4,Q4,eW,rW,aW,iW,EV,lW,dW,fW,mW,yW,xW,wW,SW,TW,CW,NW,AW,DW,PW,BW,VW,WW,GW,qW,YW,ZW,tU,rU,aU,Dx,uU,pU,fU,gU,yU,xU,bU,qV,SU,TU,kU,RU,AU,OU,PU,BU,UU,zU,e4,jU,KU,QU,ez,nz,sz,oz,iz,uz,cz,dz,mz,yz,bz,vz,Sz,Tz,Cz,_z,Ez,Oz,Pz,FV,Mz,Vz];for(const n of Wz)Of(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gc=L();gc.registerFlag("WASM_HAS_SIMD_SUPPORT",()=>se(void 0,null,function*(){try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch(n){return!1}}));gc.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",()=>se(void 0,null,function*(){if(gc.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(n){return!1}}));var vo={},Uz={get exports(){return vo},set exports(n){vo=n}};(function(n,e){var t=(()=>{var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(s){s=s||{};function a(){return le.buffer!=nt&&tn(le.buffer),Rn}function o(){return le.buffer!=nt&&tn(le.buffer),Wn}function i(){return le.buffer!=nt&&tn(le.buffer),es}function u(){return le.buffer!=nt&&tn(le.buffer),Un}function l(){return le.buffer!=nt&&tn(le.buffer),ts}var c=typeof s!="undefined"?s:{},p,d;c.ready=new Promise(function(N,P){p=N,d=P});var h;typeof process!="undefined"&&process.listeners&&(h={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f=Object.assign({},c),m=(N,P)=>{throw P},g=typeof window=="object",y=typeof importScripts=="function",x=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",w=c.ENVIRONMENT_IS_PTHREAD||!1,v="";function $(N){return c.locateFile?c.locateFile(N,v):v+N}var C,k,R;function F(N){if(N instanceof je)return;Q("exiting due to exception: "+N)}if(x){y?v=On.dirname(v)+"/":v=__dirname+"/";var D,M;typeof kh=="function"&&(D=On,M=On),C=(P,K)=>(P=M.normalize(P),D.readFileSync(P,K?void 0:"utf8")),R=P=>{var K=C(P,!0);return K.buffer||(K=new Uint8Array(K)),K},k=(P,K,ne)=>{P=M.normalize(P),D.readFile(P,function(he,Ee){he?ne(he):K(Ee.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(P){if(!(P instanceof je))throw P}),process.on("unhandledRejection",function(P){throw P}),m=(P,K)=>{if(H())throw process.exitCode=P,K;F(K),process.exit(P)},c.inspect=function(){return"[Emscripten Module object]"};let N;try{N=On}catch(P){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),P}wn.Worker=N.Worker}else(g||y)&&(y?v=self.location.href:typeof document!="undefined"&&document.currentScript&&(v=document.currentScript.src),typeof r!="undefined"&&r&&(v=r),v.indexOf("blob:")!==0?v=v.substr(0,v.replace(/[?#].*/,"").lastIndexOf("/")+1):v="",x||(C=N=>{var P=new XMLHttpRequest;return P.open("GET",N,!1),P.send(null),P.responseText},y&&(R=N=>{var P=new XMLHttpRequest;return P.open("GET",N,!1),P.responseType="arraybuffer",P.send(null),new Uint8Array(P.response)}),k=(N,P,K)=>{var ne=new XMLHttpRequest;ne.open("GET",N,!0),ne.responseType="arraybuffer",ne.onload=()=>{if(ne.status==200||ne.status==0&&ne.response){P(ne.response);return}K()},ne.onerror=K,ne.send(null)}));x&&typeof performance=="undefined"&&(wn.performance=On.performance);var U=console.log.bind(console),j=console.warn.bind(console);x&&(U=N=>D.writeSync(1,N+`
`),j=N=>D.writeSync(2,N+`
`));var Y=c.print||U,Q=c.printErr||j;Object.assign(c,f),f=null,c.arguments&&c.arguments,c.thisProgram&&c.thisProgram,c.quit&&(m=c.quit);var ae;c.wasmBinary&&(ae=c.wasmBinary);var me=c.noExitRuntime||!0;typeof WebAssembly!="object"&&ge("no native wasm support detected");var le,De,Xe=!1,lt;function wt(N,P){N||ge(P)}var Je=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function Nn(N,P,K){for(var ne=P+K,he=P;N[he]&&!(he>=ne);)++he;if(he-P>16&&N.buffer&&Je)return Je.decode(N.buffer instanceof SharedArrayBuffer?N.slice(P,he):N.subarray(P,he));for(var Ee="";P<he;){var be=N[P++];if(!(be&128)){Ee+=String.fromCharCode(be);continue}var we=N[P++]&63;if((be&224)==192){Ee+=String.fromCharCode((be&31)<<6|we);continue}var ft=N[P++]&63;if((be&240)==224?be=(be&15)<<12|we<<6|ft:be=(be&7)<<18|we<<12|ft<<6|N[P++]&63,be<65536)Ee+=String.fromCharCode(be);else{var an=be-65536;Ee+=String.fromCharCode(55296|an>>10,56320|an&1023)}}return Ee}function jt(N,P){return N?Nn(o(),N,P):""}function En(N,P,K,ne){if(!(ne>0))return 0;for(var he=K,Ee=K+ne-1,be=0;be<N.length;++be){var we=N.charCodeAt(be);if(we>=55296&&we<=57343){var ft=N.charCodeAt(++be);we=65536+((we&1023)<<10)|ft&1023}if(we<=127){if(K>=Ee)break;P[K++]=we}else if(we<=2047){if(K+1>=Ee)break;P[K++]=192|we>>6,P[K++]=128|we&63}else if(we<=65535){if(K+2>=Ee)break;P[K++]=224|we>>12,P[K++]=128|we>>6&63,P[K++]=128|we&63}else{if(K+3>=Ee)break;P[K++]=240|we>>18,P[K++]=128|we>>12&63,P[K++]=128|we>>6&63,P[K++]=128|we&63}}return P[K]=0,K-he}function Ir(N,P,K){return En(N,o(),P,K)}var nt,Rn,Wn,es,Un,ts;w&&(nt=c.buffer);function tn(N){nt=N,c.HEAP8=Rn=new Int8Array(N),c.HEAP16=new Int16Array(N),c.HEAP32=es=new Int32Array(N),c.HEAPU8=Wn=new Uint8Array(N),c.HEAPU16=new Uint16Array(N),c.HEAPU32=Un=new Uint32Array(N),c.HEAPF32=new Float32Array(N),c.HEAPF64=ts=new Float64Array(N)}var ar=c.INITIAL_MEMORY||16777216;if(w)le=c.wasmMemory,nt=c.buffer;else if(c.wasmMemory)le=c.wasmMemory;else if(le=new WebAssembly.Memory({initial:ar/65536,maximum:32768,shared:!0}),!(le.buffer instanceof SharedArrayBuffer))throw Q("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),x&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");le&&(nt=le.buffer),ar=nt.byteLength,tn(nt);var T,A=[],_=[],G=[];function H(){return me}function re(){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;)ee(c.preRun.shift());We(A)}function B(){w||We(_)}function q(){if(!w){if(c.postRun)for(typeof c.postRun=="function"&&(c.postRun=[c.postRun]);c.postRun.length;)ye(c.postRun.shift());We(G)}}function ee(N){A.unshift(N)}function ue(N){_.unshift(N)}function ye(N){G.unshift(N)}var _e=0,fe=null;function ve(N){_e++,c.monitorRunDependencies&&c.monitorRunDependencies(_e)}function ie(N){if(_e--,c.monitorRunDependencies&&c.monitorRunDependencies(_e),_e==0&&fe){var P=fe;fe=null,P()}}function ge(N){w?postMessage({cmd:"onAbort",arg:N}):c.onAbort&&c.onAbort(N),N="Aborted("+N+")",Q(N),Xe=!0,lt=1,N+=". Build with -sASSERTIONS for more info.";var P=new WebAssembly.RuntimeError(N);throw d(P),P}var Se="data:application/octet-stream;base64,";function Te(N){return N.startsWith(Se)}function rt(N){return N.startsWith("file://")}var $e;$e="tfjs-backend-wasm-threaded-simd.wasm",Te($e)||($e=$($e));function vt(N){try{if(N==$e&&ae)return new Uint8Array(ae);if(R)return R(N);throw"both async and sync fetching of the wasm failed"}catch(P){ge(P)}}function nn(){if(!ae&&(g||y)){if(typeof fetch=="function"&&!rt($e))return fetch($e,{credentials:"same-origin"}).then(function(N){if(!N.ok)throw"failed to load wasm binary file at '"+$e+"'";return N.arrayBuffer()}).catch(function(){return vt($e)});if(k)return new Promise(function(N,P){k($e,function(K){N(new Uint8Array(K))},P)})}return Promise.resolve().then(function(){return vt($e)})}function An(){var N={env:Fp,wasi_snapshot_preview1:Fp};function P(be,we){var ft=be.exports;if(c.asm=ft,Aa(c.asm._emscripten_tls_init),T=c.asm.__indirect_function_table,ue(c.asm.__wasm_call_ctors),De=we,!w){var an=J.unusedWorkers.length;J.unusedWorkers.forEach(function(Hn){J.loadWasmModuleToWorker(Hn,function(){--an||ie()})})}}w||ve();function K(be){P(be.instance,be.module)}function ne(be){return nn().then(function(we){return WebAssembly.instantiate(we,N)}).then(function(we){return we}).then(be,function(we){Q("failed to asynchronously prepare wasm: "+we),ge(we)})}function he(){return!ae&&typeof WebAssembly.instantiateStreaming=="function"&&!Te($e)&&!rt($e)&&!x&&typeof fetch=="function"?fetch($e,{credentials:"same-origin"}).then(function(be){var we=WebAssembly.instantiateStreaming(be,N);return we.then(K,function(ft){return Q("wasm streaming compile failed: "+ft),Q("falling back to ArrayBuffer instantiation"),ne(K)})}):ne(K)}if(c.instantiateWasm)try{var Ee=c.instantiateWasm(N,P);return Ee}catch(be){Q("Module.instantiateWasm callback failed with error: "+be),d(be)}return he().catch(d),{}}var Tr={};function je(N){this.name="ExitStatus",this.message="Program terminated with exit("+N+")",this.status=N}function Le(N){var P=J.pthreads[N];delete J.pthreads[N],P.terminate(),Ui(N),J.runningWorkers.splice(J.runningWorkers.indexOf(P),1),P.pthread_ptr=0}function Et(N){var P=J.pthreads[N];P.postMessage({cmd:"cancel"})}function et(N){var P=J.pthreads[N];wt(P),J.returnWorkerToPool(P)}function ht(N){var P=J.getNewWorker();if(!P)return 6;J.runningWorkers.push(P),J.pthreads[N.pthread_ptr]=P,P.pthread_ptr=N.pthread_ptr;var K={cmd:"run",start_routine:N.startRoutine,arg:N.arg,pthread_ptr:N.pthread_ptr};return P.runPthread=()=>{K.time=performance.now(),P.postMessage(K,N.transferList)},P.loaded&&(P.runPthread(),delete P.runPthread),0}function rn(N){if(w)return ns(1,1,N);lt=N,H()||(J.terminateAllThreads(),c.onExit&&c.onExit(N),Xe=!0),m(N,new je(N))}function W(N,P){if(lt=N,!P&&w)throw Ce(N),"unwind";rn(N)}var X=W;function de(N){if(N instanceof je||N=="unwind")return lt;m(1,N)}var J={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){w?J.initWorker():J.initMainThread()},initMainThread:function(){for(var N=8;N--;)J.allocateUnusedWorker()},initWorker:function(){me=!1},setExitStatus:function(N){lt=N},terminateAllThreads:function(){for(var N of Object.values(J.pthreads))J.returnWorkerToPool(N);for(var N of J.unusedWorkers)N.terminate();J.unusedWorkers=[]},returnWorkerToPool:function(N){var P=N.pthread_ptr;delete J.pthreads[P],J.unusedWorkers.push(N),J.runningWorkers.splice(J.runningWorkers.indexOf(N),1),N.pthread_ptr=0,Ui(P)},receiveObjectTransfer:function(N){},threadInitTLS:function(){J.tlsInitFunctions.forEach(N=>N())},loadWasmModuleToWorker:function(N,P){N.onmessage=K=>{var ne=K.data,he=ne.cmd;if(N.pthread_ptr&&(J.currentProxiedOperationCallerThread=N.pthread_ptr),ne.targetThread&&ne.targetThread!=Fa()){var Ee=J.pthreads[ne.targetThread];Ee?Ee.postMessage(ne,ne.transferList):Q('Internal error! Worker sent a message "'+he+'" to target pthread '+ne.targetThread+", but that thread no longer exists!"),J.currentProxiedOperationCallerThread=void 0;return}he==="processProxyingQueue"?Vi(ne.queue):he==="spawnThread"?ht(ne):he==="cleanupThread"?et(ne.thread):he==="killThread"?Le(ne.thread):he==="cancelThread"?Et(ne.thread):he==="loaded"?(N.loaded=!0,P&&P(N),N.runPthread&&(N.runPthread(),delete N.runPthread)):he==="print"?Y("Thread "+ne.threadId+": "+ne.text):he==="printErr"?Q("Thread "+ne.threadId+": "+ne.text):he==="alert"?alert("Thread "+ne.threadId+": "+ne.text):ne.target==="setimmediate"?N.postMessage(ne):he==="onAbort"?c.onAbort&&c.onAbort(ne.arg):he&&Q("worker sent an unknown command "+he),J.currentProxiedOperationCallerThread=void 0},N.onerror=K=>{var ne="worker sent an error!";throw Q(ne+" "+K.filename+":"+K.lineno+": "+K.message),K},x&&(N.on("message",function(K){N.onmessage({data:K})}),N.on("error",function(K){N.onerror(K)}),N.on("detachedExit",function(){})),N.postMessage({cmd:"load",urlOrBlob:c.mainScriptUrlOrBlob||r,wasmMemory:le,wasmModule:De})},allocateUnusedWorker:function(){var N=$("tfjs-backend-wasm-threaded-simd.worker.js");J.unusedWorkers.push(new Worker(N))},getNewWorker:function(){return J.unusedWorkers.length==0&&(J.allocateUnusedWorker(),J.loadWasmModuleToWorker(J.unusedWorkers[0])),J.unusedWorkers.pop()}};c.PThread=J;function We(N){for(;N.length>0;)N.shift()(c)}function Ue(N){var P=zi(),K=N();return Da(P),K}function xe(){var N=Fa(),P=i()[N+44>>2],K=i()[N+48>>2],ne=P-K;Bp(P,ne),Da(P)}c.establishStackSpace=xe;function Ce(N){if(w)return ns(2,0,N);try{X(N)}catch(P){de(P)}}var st=[];function sn(N){var P=st[N];return P||(N>=st.length&&(st.length=N+1),st[N]=P=T.get(N)),P}function zn(N,P){var K=sn(N)(P);H()?J.setExitStatus(K):Mp(K)}c.invokeEntryPoint=zn;function Aa(N){J.tlsInitFunctions.push(N)}function Ps(N,P){a().set(N,P)}function Bi(N){Dp(N,!y,1,!g),J.threadInitTLS()}function Rt(N){w?postMessage({cmd:"cleanupThread",thread:N}):et(N)}function Gn(N,P,K,ne){return w?ns(3,1,N,P,K,ne):Ls(N,P,K,ne)}function Ls(N,P,K,ne){if(typeof SharedArrayBuffer=="undefined")return Q("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var he=[],Ee=0;if(w&&(he.length===0||Ee))return Gn(N,P,K,ne);var be={startRoutine:K,pthread_ptr:N,arg:ne,transferList:he};return w?(be.cmd="spawnThread",postMessage(be,he),0):ht(be)}function ub(){return 2097152}var cb=!0;function lb(){return cb}function Vi(N){Atomics.store(i(),N>>2,1),Fa()&&Lp(N),Atomics.compareExchange(i(),N>>2,1,0)}c.executeNotifiedProxyingQueue=Vi;function pb(N,P,K,ne){if(N==P)setTimeout(()=>Vi(ne));else if(w)postMessage({targetThread:N,cmd:"processProxyingQueue",queue:ne});else{var he=J.pthreads[N];if(!he)return;he.postMessage({cmd:"processProxyingQueue",queue:ne})}return 1}function db(N,P,K){return-1}function hb(){ge("")}function Ms(N){Ms.shown||(Ms.shown={}),Ms.shown[N]||(Ms.shown[N]=1,x&&(N="warning: "+N),Q(N))}function fb(){x||y||Ms("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function mb(){return Date.now()}function Np(){return 2147483648}function gb(){return Np()}var Oa;x?Oa=()=>{var N=process.hrtime();return N[0]*1e3+N[1]/1e6}:w?Oa=()=>performance.now()-c.__performance_now_clock_drift:Oa=()=>performance.now();function yb(N,P,K){o().copyWithin(N,P,P+K)}function xb(){return x?On.cpus().length:navigator.hardwareConcurrency}function ns(N,P){var K=arguments.length-2,ne=arguments;return Ue(()=>{for(var he=K,Ee=Pa(he*8),be=Ee>>3,we=0;we<K;we++){var ft=ne[2+we];l()[be+we]=ft}return Pp(N,he,Ee,P)})}var Wi=[];function bb(N,P,K){Wi.length=P;for(var ne=K>>3,he=0;he<P;he++)Wi[he]=l()[ne+he];var Ee=N<0,be=Ee?Tr[-N-1]:_b[N];return be.apply(null,Wi)}function wb(N){try{return le.grow(N-nt.byteLength+65535>>>16),tn(le.buffer),1}catch(P){}}function vb(N){var P=o().length;if(N=N>>>0,N<=P)return!1;var K=Np();if(N>K)return!1;let ne=(ft,an)=>ft+(an-ft%an)%an;for(var he=1;he<=4;he*=2){var Ee=P*(1+.2/he);Ee=Math.min(Ee,N+100663296);var be=Math.min(K,ne(Math.max(N,Ee),65536)),we=wb(be);if(we)return!0}return!1}function Sb(){throw"unwind"}function Ep(N){return w?ns(4,1,N):52}function Rp(N,P,K,ne,he){return w?ns(5,1,N,P,K,ne,he):70}var $b=[null,[],[]];function Ib(N,P){var K=$b[N];P===0||P===10?((N===1?Y:Q)(Nn(K,0)),K.length=0):K.push(P)}function Ap(N,P,K,ne){if(w)return ns(6,1,N,P,K,ne);for(var he=0,Ee=0;Ee<K;Ee++){var be=u()[P>>2],we=u()[P+4>>2];P+=8;for(var ft=0;ft<we;ft++)Ib(N,o()[be+ft]);he+=we}return u()[ne>>2]=he,0}function Op(N){var P=c["_"+N];return P}function Tb(N,P,K,ne,he){var Ee={string:qt=>{var rs=0;if(qt!=null&&qt!==0){var Up=(qt.length<<2)+1;rs=Pa(Up),Ir(qt,rs,Up)}return rs},array:qt=>{var rs=Pa(qt.length);return Ps(qt,rs),rs}};function be(qt){return P==="string"?jt(qt):P==="boolean"?Boolean(qt):qt}var we=Op(N),ft=[],an=0;if(ne)for(var Hn=0;Hn<ne.length;Hn++){var Wp=Ee[K[Hn]];Wp?(an===0&&(an=zi()),ft[Hn]=Wp(ne[Hn])):ft[Hn]=ne[Hn]}var Gi=we.apply(null,ft);function Nb(qt){return an!==0&&Da(an),be(qt)}return Gi=Nb(Gi),Gi}function Cb(N,P,K,ne){K=K||[];var he=K.every(be=>be==="number"||be==="boolean"),Ee=P!=="string";return Ee&&he&&!ne?Op(N):function(){return Tb(N,P,K,arguments)}}J.init();var _b=[null,rn,Ce,Gn,Ep,Rp,Ap],Fp={__emscripten_init_main_thread_js:Bi,__emscripten_thread_cleanup:Rt,__pthread_create_js:Ls,_emscripten_default_pthread_stack_size:ub,_emscripten_get_now_is_monotonic:lb,_emscripten_notify_task_queue:pb,_emscripten_set_offscreencanvas_size:db,abort:hb,emscripten_check_blocking_allowed:fb,emscripten_date_now:mb,emscripten_get_heap_max:gb,emscripten_get_now:Oa,emscripten_memcpy_big:yb,emscripten_num_logical_cores:xb,emscripten_receive_on_main_thread_js:bb,emscripten_resize_heap:vb,emscripten_unwind_to_js_event_loop:Sb,exit:X,fd_close:Ep,fd_seek:Rp,fd_write:Ap,memory:le||c.wasmMemory};An(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.__wasm_call_ctors).apply(null,arguments)},c._init=function(){return(c._init=c.asm.init).apply(null,arguments)},c._init_with_threads_count=function(){return(c._init_with_threads_count=c.asm.init_with_threads_count).apply(null,arguments)},c._get_threads_count=function(){return(c._get_threads_count=c.asm.get_threads_count).apply(null,arguments)},c._register_tensor=function(){return(c._register_tensor=c.asm.register_tensor).apply(null,arguments)},c._dispose_data=function(){return(c._dispose_data=c.asm.dispose_data).apply(null,arguments)},c._dispose=function(){return(c._dispose=c.asm.dispose).apply(null,arguments)},c._Abs=function(){return(c._Abs=c.asm.Abs).apply(null,arguments)},c._Add=function(){return(c._Add=c.asm.Add).apply(null,arguments)},c._AddN=function(){return(c._AddN=c.asm.AddN).apply(null,arguments)},c._All=function(){return(c._All=c.asm.All).apply(null,arguments)},c._Any=function(){return(c._Any=c.asm.Any).apply(null,arguments)},c._ArgMax=function(){return(c._ArgMax=c.asm.ArgMax).apply(null,arguments)},c._AvgPool=function(){return(c._AvgPool=c.asm.AvgPool).apply(null,arguments)},c._BatchMatMul=function(){return(c._BatchMatMul=c.asm.BatchMatMul).apply(null,arguments)},c._Ceil=function(){return(c._Ceil=c.asm.Ceil).apply(null,arguments)},c._ClipByValue=function(){return(c._ClipByValue=c.asm.ClipByValue).apply(null,arguments)},c._Conv2D=function(){return(c._Conv2D=c.asm.Conv2D).apply(null,arguments)},c._Conv2DBackpropInput=function(){return(c._Conv2DBackpropInput=c.asm.Conv2DBackpropInput).apply(null,arguments)},c._Cos=function(){return(c._Cos=c.asm.Cos).apply(null,arguments)},c._Cosh=function(){return(c._Cosh=c.asm.Cosh).apply(null,arguments)},c._CropAndResize=function(){return(c._CropAndResize=c.asm.CropAndResize).apply(null,arguments)},c._Cumprod=function(){return(c._Cumprod=c.asm.Cumprod).apply(null,arguments)},c._Cumsum=function(){return(c._Cumsum=c.asm.Cumsum).apply(null,arguments)},c._DepthToSpace=function(){return(c._DepthToSpace=c.asm.DepthToSpace).apply(null,arguments)},c._DepthwiseConv2dNative=function(){return(c._DepthwiseConv2dNative=c.asm.DepthwiseConv2dNative).apply(null,arguments)},c._Elu=function(){return(c._Elu=c.asm.Elu).apply(null,arguments)},c._Equal=function(){return(c._Equal=c.asm.Equal).apply(null,arguments)},c._Exp=function(){return(c._Exp=c.asm.Exp).apply(null,arguments)},c._FlipLeftRight=function(){return(c._FlipLeftRight=c.asm.FlipLeftRight).apply(null,arguments)},c._Floor=function(){return(c._Floor=c.asm.Floor).apply(null,arguments)},c._FloorDiv=function(){return(c._FloorDiv=c.asm.FloorDiv).apply(null,arguments)},c._FusedBatchNorm=function(){return(c._FusedBatchNorm=c.asm.FusedBatchNorm).apply(null,arguments)},c._FusedConv2D=function(){return(c._FusedConv2D=c.asm.FusedConv2D).apply(null,arguments)},c._FusedDepthwiseConv2D=function(){return(c._FusedDepthwiseConv2D=c.asm.FusedDepthwiseConv2D).apply(null,arguments)},c._Gather=function(){return(c._Gather=c.asm.Gather).apply(null,arguments)},c._GatherNd=function(){return(c._GatherNd=c.asm.GatherNd).apply(null,arguments)},c._Greater=function(){return(c._Greater=c.asm.Greater).apply(null,arguments)},c._GreaterEqual=function(){return(c._GreaterEqual=c.asm.GreaterEqual).apply(null,arguments)},c._LeakyRelu=function(){return(c._LeakyRelu=c.asm.LeakyRelu).apply(null,arguments)},c._Less=function(){return(c._Less=c.asm.Less).apply(null,arguments)},c._LessEqual=function(){return(c._LessEqual=c.asm.LessEqual).apply(null,arguments)},c._Log=function(){return(c._Log=c.asm.Log).apply(null,arguments)},c._LogicalAnd=function(){return(c._LogicalAnd=c.asm.LogicalAnd).apply(null,arguments)},c._LogicalNot=function(){return(c._LogicalNot=c.asm.LogicalNot).apply(null,arguments)},c._LogicalOr=function(){return(c._LogicalOr=c.asm.LogicalOr).apply(null,arguments)},c._LogicalXor=function(){return(c._LogicalXor=c.asm.LogicalXor).apply(null,arguments)},c._Max=function(){return(c._Max=c.asm.Max).apply(null,arguments)},c._MaxPool=function(){return(c._MaxPool=c.asm.MaxPool).apply(null,arguments)},c._Maximum=function(){return(c._Maximum=c.asm.Maximum).apply(null,arguments)},c._Mean=function(){return(c._Mean=c.asm.Mean).apply(null,arguments)},c._Min=function(){return(c._Min=c.asm.Min).apply(null,arguments)},c._Minimum=function(){return(c._Minimum=c.asm.Minimum).apply(null,arguments)},c._MirrorPad=function(){return(c._MirrorPad=c.asm.MirrorPad).apply(null,arguments)},c._Multiply=function(){return(c._Multiply=c.asm.Multiply).apply(null,arguments)},c._Neg=function(){return(c._Neg=c.asm.Neg).apply(null,arguments)},c._NonMaxSuppressionV3=function(){return(c._NonMaxSuppressionV3=c.asm.NonMaxSuppressionV3).apply(null,arguments)},c._NonMaxSuppressionV4=function(){return(c._NonMaxSuppressionV4=c.asm.NonMaxSuppressionV4).apply(null,arguments)},c._NonMaxSuppressionV5=function(){return(c._NonMaxSuppressionV5=c.asm.NonMaxSuppressionV5).apply(null,arguments)},c._NotEqual=function(){return(c._NotEqual=c.asm.NotEqual).apply(null,arguments)},c._OneHot=function(){return(c._OneHot=c.asm.OneHot).apply(null,arguments)},c._PadV2=function(){return(c._PadV2=c.asm.PadV2).apply(null,arguments)},c._Pow=function(){return(c._Pow=c.asm.Pow).apply(null,arguments)},c._Prelu=function(){return(c._Prelu=c.asm.Prelu).apply(null,arguments)},c._Prod=function(){return(c._Prod=c.asm.Prod).apply(null,arguments)},c._RealDiv=function(){return(c._RealDiv=c.asm.RealDiv).apply(null,arguments)},c._Relu=function(){return(c._Relu=c.asm.Relu).apply(null,arguments)},c._Relu6=function(){return(c._Relu6=c.asm.Relu6).apply(null,arguments)},c._ResizeBilinear=function(){return(c._ResizeBilinear=c.asm.ResizeBilinear).apply(null,arguments)},c._ResizeNearestNeighbor=function(){return(c._ResizeNearestNeighbor=c.asm.ResizeNearestNeighbor).apply(null,arguments)},c._Reverse=function(){return(c._Reverse=c.asm.Reverse).apply(null,arguments)},c._RotateWithOffset=function(){return(c._RotateWithOffset=c.asm.RotateWithOffset).apply(null,arguments)},c._Round=function(){return(c._Round=c.asm.Round).apply(null,arguments)},c._Rsqrt=function(){return(c._Rsqrt=c.asm.Rsqrt).apply(null,arguments)},c._ScatterNd=function(){return(c._ScatterNd=c.asm.ScatterNd).apply(null,arguments)},c._SelectV2=function(){return(c._SelectV2=c.asm.SelectV2).apply(null,arguments)},c._Sigmoid=function(){return(c._Sigmoid=c.asm.Sigmoid).apply(null,arguments)},c._Sin=function(){return(c._Sin=c.asm.Sin).apply(null,arguments)},c._Softmax=function(){return(c._Softmax=c.asm.Softmax).apply(null,arguments)},c._SparseFillEmptyRows=function(){return(c._SparseFillEmptyRows=c.asm.SparseFillEmptyRows).apply(null,arguments)},c._SparseReshape=function(){return(c._SparseReshape=c.asm.SparseReshape).apply(null,arguments)},c._SparseSegmentReduction=function(){return(c._SparseSegmentReduction=c.asm.SparseSegmentReduction).apply(null,arguments)},c._Sqrt=function(){return(c._Sqrt=c.asm.Sqrt).apply(null,arguments)},c._Square=function(){return(c._Square=c.asm.Square).apply(null,arguments)},c._SquaredDifference=function(){return(c._SquaredDifference=c.asm.SquaredDifference).apply(null,arguments)},c._Step=function(){return(c._Step=c.asm.Step).apply(null,arguments)},c._StridedSlice=function(){return(c._StridedSlice=c.asm.StridedSlice).apply(null,arguments)},c._Sub=function(){return(c._Sub=c.asm.Sub).apply(null,arguments)},c._Sum=function(){return(c._Sum=c.asm.Sum).apply(null,arguments)},c._Tan=function(){return(c._Tan=c.asm.Tan).apply(null,arguments)},c._Tanh=function(){return(c._Tanh=c.asm.Tanh).apply(null,arguments)},c._Tile=function(){return(c._Tile=c.asm.Tile).apply(null,arguments)},c._TopK=function(){return(c._TopK=c.asm.TopK).apply(null,arguments)},c._Transform=function(){return(c._Transform=c.asm.Transform).apply(null,arguments)},c._Transpose=function(){return(c._Transpose=c.asm.Transpose).apply(null,arguments)},c.__FusedMatMul=function(){return(c.__FusedMatMul=c.asm._FusedMatMul).apply(null,arguments)},c._malloc=function(){return(c._malloc=c.asm.malloc).apply(null,arguments)},c._free=function(){return(c._free=c.asm.free).apply(null,arguments)},c.__emscripten_tls_init=function(){return(c.__emscripten_tls_init=c.asm._emscripten_tls_init).apply(null,arguments)};var Fa=c._pthread_self=function(){return(Fa=c._pthread_self=c.asm.pthread_self).apply(null,arguments)};c.___errno_location=function(){return(c.___errno_location=c.asm.__errno_location).apply(null,arguments)};var Dp=c.__emscripten_thread_init=function(){return(Dp=c.__emscripten_thread_init=c.asm._emscripten_thread_init).apply(null,arguments)};c.__emscripten_thread_crashed=function(){return(c.__emscripten_thread_crashed=c.asm._emscripten_thread_crashed).apply(null,arguments)},c._emscripten_main_thread_process_queued_calls=function(){return(c._emscripten_main_thread_process_queued_calls=c.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},c._emscripten_main_browser_thread_id=function(){return(c._emscripten_main_browser_thread_id=c.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var Pp=c._emscripten_run_in_main_runtime_thread_js=function(){return(Pp=c._emscripten_run_in_main_runtime_thread_js=c.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};c._emscripten_dispatch_to_thread_=function(){return(c._emscripten_dispatch_to_thread_=c.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var Lp=c.__emscripten_proxy_execute_task_queue=function(){return(Lp=c.__emscripten_proxy_execute_task_queue=c.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},Ui=c.__emscripten_thread_free_data=function(){return(Ui=c.__emscripten_thread_free_data=c.asm._emscripten_thread_free_data).apply(null,arguments)},Mp=c.__emscripten_thread_exit=function(){return(Mp=c.__emscripten_thread_exit=c.asm._emscripten_thread_exit).apply(null,arguments)},Bp=c._emscripten_stack_set_limits=function(){return(Bp=c._emscripten_stack_set_limits=c.asm.emscripten_stack_set_limits).apply(null,arguments)},zi=c.stackSave=function(){return(zi=c.stackSave=c.asm.stackSave).apply(null,arguments)},Da=c.stackRestore=function(){return(Da=c.stackRestore=c.asm.stackRestore).apply(null,arguments)},Pa=c.stackAlloc=function(){return(Pa=c.stackAlloc=c.asm.stackAlloc).apply(null,arguments)};c.dynCall_iijjiiii=function(){return(c.dynCall_iijjiiii=c.asm.dynCall_iijjiiii).apply(null,arguments)},c.dynCall_jiji=function(){return(c.dynCall_jiji=c.asm.dynCall_jiji).apply(null,arguments)},c.keepRuntimeAlive=H,c.wasmMemory=le,c.cwrap=Cb,c.ExitStatus=je,c.PThread=J;var La;fe=function N(){La||Vp(),La||(fe=N)};function Vp(N){if(_e>0)return;if(w){p(c),B(),postMessage({cmd:"loaded"});return}if(re(),_e>0)return;function P(){La||(La=!0,c.calledRun=!0,!Xe&&(B(),p(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),q()))}c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),P()},1)):P()}if(c.preInit)for(typeof c.preInit=="function"&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();Vp();var Ma;h&&(Ma={uncaughtException:process.listeners("uncaughtException").filter(function(N){return!h.uncaughtException.indexOf(N)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(N){return!h.unhandledRejection.indexOf(N)>-1})});var Ba;if(typeof WasmBackendModule!="undefined")Ba=WasmBackendModule;else if(typeof s!="undefined")Ba=s;else throw new Error("Could not find wasm module in post.js");if(Ma){var kb=Ba._dispose;Ba._dispose=function(){kb(),Ma.uncaughtException.forEach(function(N){process.removeListener("uncaughtException",N)}),Ma.unhandledRejection.forEach(function(N){process.removeListener("unhandledRejection",N)})}}return s.ready}})();n.exports=t})(Uz);const rb=vo,zz=bc({__proto__:null,default:rb},[vo]);var Gz=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8"))},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance})}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`,So={},Hz={get exports(){return So},set exports(n){So=n}};(function(n,e){var t=(()=>{var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(s){s=s||{};var a=typeof s!="undefined"?s:{},o,i;a.ready=new Promise(function(W,X){o=W,i=X});var u;typeof process!="undefined"&&process.listeners&&(u={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var l=Object.assign({},a),c=typeof window=="object",p=typeof importScripts=="function",d=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",h="";function f(W){return a.locateFile?a.locateFile(W,h):h+W}var m,g,y;if(d){p?h=On.dirname(h)+"/":h=__dirname+"/";var x,w;typeof kh=="function"&&(x=On,w=On),m=(W,X)=>(W=w.normalize(W),x.readFileSync(W,X?void 0:"utf8")),y=W=>{var X=m(W,!0);return X.buffer||(X=new Uint8Array(X)),X},g=(W,X,de)=>{W=w.normalize(W),x.readFile(W,function(J,We){J?de(J):X(We.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(W){if(!(W instanceof H))throw W}),process.on("unhandledRejection",function(W){throw W}),a.inspect=function(){return"[Emscripten Module object]"}}else(c||p)&&(p?h=self.location.href:typeof document!="undefined"&&document.currentScript&&(h=document.currentScript.src),r&&(h=r),h.indexOf("blob:")!==0?h=h.substr(0,h.replace(/[?#].*/,"").lastIndexOf("/")+1):h="",m=W=>{var X=new XMLHttpRequest;return X.open("GET",W,!1),X.send(null),X.responseText},p&&(y=W=>{var X=new XMLHttpRequest;return X.open("GET",W,!1),X.responseType="arraybuffer",X.send(null),new Uint8Array(X.response)}),g=(W,X,de)=>{var J=new XMLHttpRequest;J.open("GET",W,!0),J.responseType="arraybuffer",J.onload=()=>{if(J.status==200||J.status==0&&J.response){X(J.response);return}de()},J.onerror=de,J.send(null)});var v=a.print||console.log.bind(console),$=a.printErr||console.warn.bind(console);Object.assign(a,l),l=null,a.arguments&&a.arguments,a.thisProgram&&a.thisProgram,a.quit&&a.quit;var C;a.wasmBinary&&(C=a.wasmBinary),a.noExitRuntime,typeof WebAssembly!="object"&&Un("no native wasm support detected");var k,R=!1,F=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function D(W,X,de){for(var J=X+de,We=X;W[We]&&!(We>=J);)++We;if(We-X>16&&W.buffer&&F)return F.decode(W.subarray(X,We));for(var Ue="";X<We;){var xe=W[X++];if(!(xe&128)){Ue+=String.fromCharCode(xe);continue}var Ce=W[X++]&63;if((xe&224)==192){Ue+=String.fromCharCode((xe&31)<<6|Ce);continue}var st=W[X++]&63;if((xe&240)==224?xe=(xe&15)<<12|Ce<<6|st:xe=(xe&7)<<18|Ce<<12|st<<6|W[X++]&63,xe<65536)Ue+=String.fromCharCode(xe);else{var sn=xe-65536;Ue+=String.fromCharCode(55296|sn>>10,56320|sn&1023)}}return Ue}function M(W,X){return W?D(ae,W,X):""}function U(W,X,de,J){if(!(J>0))return 0;for(var We=de,Ue=de+J-1,xe=0;xe<W.length;++xe){var Ce=W.charCodeAt(xe);if(Ce>=55296&&Ce<=57343){var st=W.charCodeAt(++xe);Ce=65536+((Ce&1023)<<10)|st&1023}if(Ce<=127){if(de>=Ue)break;X[de++]=Ce}else if(Ce<=2047){if(de+1>=Ue)break;X[de++]=192|Ce>>6,X[de++]=128|Ce&63}else if(Ce<=65535){if(de+2>=Ue)break;X[de++]=224|Ce>>12,X[de++]=128|Ce>>6&63,X[de++]=128|Ce&63}else{if(de+3>=Ue)break;X[de++]=240|Ce>>18,X[de++]=128|Ce>>12&63,X[de++]=128|Ce>>6&63,X[de++]=128|Ce&63}}return X[de]=0,de-We}function j(W,X,de){return U(W,ae,X,de)}var Y,Q,ae,me;function le(W){Y=W,a.HEAP8=Q=new Int8Array(W),a.HEAP16=new Int16Array(W),a.HEAP32=new Int32Array(W),a.HEAPU8=ae=new Uint8Array(W),a.HEAPU16=new Uint16Array(W),a.HEAPU32=me=new Uint32Array(W),a.HEAPF32=new Float32Array(W),a.HEAPF64=new Float64Array(W)}a.INITIAL_MEMORY;var De=[],Xe=[],lt=[];function wt(){if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)jt(a.preRun.shift());re(De)}function Je(){re(Xe)}function Nn(){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;)Ir(a.postRun.shift());re(lt)}function jt(W){De.unshift(W)}function En(W){Xe.unshift(W)}function Ir(W){lt.unshift(W)}var nt=0,Rn=null;function Wn(W){nt++,a.monitorRunDependencies&&a.monitorRunDependencies(nt)}function es(W){if(nt--,a.monitorRunDependencies&&a.monitorRunDependencies(nt),nt==0&&Rn){var X=Rn;Rn=null,X()}}function Un(W){a.onAbort&&a.onAbort(W),W="Aborted("+W+")",$(W),R=!0,W+=". Build with -sASSERTIONS for more info.";var X=new WebAssembly.RuntimeError(W);throw i(X),X}var ts="data:application/octet-stream;base64,";function tn(W){return W.startsWith(ts)}function ar(W){return W.startsWith("file://")}var T;T="tfjs-backend-wasm.wasm",tn(T)||(T=f(T));function A(W){try{if(W==T&&C)return new Uint8Array(C);if(y)return y(W);throw"both async and sync fetching of the wasm failed"}catch(X){Un(X)}}function _(){if(!C&&(c||p)){if(typeof fetch=="function"&&!ar(T))return fetch(T,{credentials:"same-origin"}).then(function(W){if(!W.ok)throw"failed to load wasm binary file at '"+T+"'";return W.arrayBuffer()}).catch(function(){return A(T)});if(g)return new Promise(function(W,X){g(T,function(de){W(new Uint8Array(de))},X)})}return Promise.resolve().then(function(){return A(T)})}function G(){var W={env:nn,wasi_snapshot_preview1:nn};function X(xe,Ce){var st=xe.exports;a.asm=st,k=a.asm.memory,le(k.buffer),a.asm.__indirect_function_table,En(a.asm.__wasm_call_ctors),es()}Wn();function de(xe){X(xe.instance)}function J(xe){return _().then(function(Ce){return WebAssembly.instantiate(Ce,W)}).then(function(Ce){return Ce}).then(xe,function(Ce){$("failed to asynchronously prepare wasm: "+Ce),Un(Ce)})}function We(){return!C&&typeof WebAssembly.instantiateStreaming=="function"&&!tn(T)&&!ar(T)&&!d&&typeof fetch=="function"?fetch(T,{credentials:"same-origin"}).then(function(xe){var Ce=WebAssembly.instantiateStreaming(xe,W);return Ce.then(de,function(st){return $("wasm streaming compile failed: "+st),$("falling back to ArrayBuffer instantiation"),J(de)})}):J(de)}if(a.instantiateWasm)try{var Ue=a.instantiateWasm(W,X);return Ue}catch(xe){$("Module.instantiateWasm callback failed with error: "+xe),i(xe)}return We().catch(i),{}}function H(W){this.name="ExitStatus",this.message="Program terminated with exit("+W+")",this.status=W}function re(W){for(;W.length>0;)W.shift()(a)}function B(W,X){Q.set(W,X)}function q(){Un("")}function ee(){return 2147483648}function ue(){return ee()}function ye(W,X,de){ae.copyWithin(W,X,X+de)}function _e(W){try{return k.grow(W-Y.byteLength+65535>>>16),le(k.buffer),1}catch(X){}}function fe(W){var X=ae.length;W=W>>>0;var de=ee();if(W>de)return!1;let J=(st,sn)=>st+(sn-st%sn)%sn;for(var We=1;We<=4;We*=2){var Ue=X*(1+.2/We);Ue=Math.min(Ue,W+100663296);var xe=Math.min(de,J(Math.max(W,Ue),65536)),Ce=_e(xe);if(Ce)return!0}return!1}function ve(W){return 52}function ie(W,X,de,J,We){return 70}var ge=[null,[],[]];function Se(W,X){var de=ge[W];X===0||X===10?((W===1?v:$)(D(de,0)),de.length=0):de.push(X)}function Te(W,X,de,J){for(var We=0,Ue=0;Ue<de;Ue++){var xe=me[X>>2],Ce=me[X+4>>2];X+=8;for(var st=0;st<Ce;st++)Se(W,ae[xe+st]);We+=Ce}return me[J>>2]=We,0}function rt(W){var X=a["_"+W];return X}function $e(W,X,de,J,We){var Ue={string:Rt=>{var Gn=0;if(Rt!=null&&Rt!==0){var Ls=(Rt.length<<2)+1;Gn=je(Ls),j(Rt,Gn,Ls)}return Gn},array:Rt=>{var Gn=je(Rt.length);return B(Rt,Gn),Gn}};function xe(Rt){return X==="string"?M(Rt):X==="boolean"?Boolean(Rt):Rt}var Ce=rt(W),st=[],sn=0;if(J)for(var zn=0;zn<J.length;zn++){var Aa=Ue[de[zn]];Aa?(sn===0&&(sn=An()),st[zn]=Aa(J[zn])):st[zn]=J[zn]}var Ps=Ce.apply(null,st);function Bi(Rt){return sn!==0&&Tr(sn),xe(Rt)}return Ps=Bi(Ps),Ps}function vt(W,X,de,J){de=de||[];var We=de.every(xe=>xe==="number"||xe==="boolean"),Ue=X!=="string";return Ue&&We&&!J?rt(W):function(){return $e(W,X,de,arguments)}}var nn={abort:q,emscripten_get_heap_max:ue,emscripten_memcpy_big:ye,emscripten_resize_heap:fe,fd_close:ve,fd_seek:ie,fd_write:Te};G(),a.___wasm_call_ctors=function(){return(a.___wasm_call_ctors=a.asm.__wasm_call_ctors).apply(null,arguments)},a._init=function(){return(a._init=a.asm.init).apply(null,arguments)},a._init_with_threads_count=function(){return(a._init_with_threads_count=a.asm.init_with_threads_count).apply(null,arguments)},a._get_threads_count=function(){return(a._get_threads_count=a.asm.get_threads_count).apply(null,arguments)},a._register_tensor=function(){return(a._register_tensor=a.asm.register_tensor).apply(null,arguments)},a._dispose_data=function(){return(a._dispose_data=a.asm.dispose_data).apply(null,arguments)},a._dispose=function(){return(a._dispose=a.asm.dispose).apply(null,arguments)},a._Abs=function(){return(a._Abs=a.asm.Abs).apply(null,arguments)},a._Add=function(){return(a._Add=a.asm.Add).apply(null,arguments)},a._AddN=function(){return(a._AddN=a.asm.AddN).apply(null,arguments)},a._All=function(){return(a._All=a.asm.All).apply(null,arguments)},a._Any=function(){return(a._Any=a.asm.Any).apply(null,arguments)},a._ArgMax=function(){return(a._ArgMax=a.asm.ArgMax).apply(null,arguments)},a._AvgPool=function(){return(a._AvgPool=a.asm.AvgPool).apply(null,arguments)},a._BatchMatMul=function(){return(a._BatchMatMul=a.asm.BatchMatMul).apply(null,arguments)},a._Ceil=function(){return(a._Ceil=a.asm.Ceil).apply(null,arguments)},a._ClipByValue=function(){return(a._ClipByValue=a.asm.ClipByValue).apply(null,arguments)},a._Conv2D=function(){return(a._Conv2D=a.asm.Conv2D).apply(null,arguments)},a._Conv2DBackpropInput=function(){return(a._Conv2DBackpropInput=a.asm.Conv2DBackpropInput).apply(null,arguments)},a._Cos=function(){return(a._Cos=a.asm.Cos).apply(null,arguments)},a._Cosh=function(){return(a._Cosh=a.asm.Cosh).apply(null,arguments)},a._CropAndResize=function(){return(a._CropAndResize=a.asm.CropAndResize).apply(null,arguments)},a._Cumprod=function(){return(a._Cumprod=a.asm.Cumprod).apply(null,arguments)},a._Cumsum=function(){return(a._Cumsum=a.asm.Cumsum).apply(null,arguments)},a._DepthToSpace=function(){return(a._DepthToSpace=a.asm.DepthToSpace).apply(null,arguments)},a._DepthwiseConv2dNative=function(){return(a._DepthwiseConv2dNative=a.asm.DepthwiseConv2dNative).apply(null,arguments)},a._Elu=function(){return(a._Elu=a.asm.Elu).apply(null,arguments)},a._Equal=function(){return(a._Equal=a.asm.Equal).apply(null,arguments)},a._Exp=function(){return(a._Exp=a.asm.Exp).apply(null,arguments)},a._FlipLeftRight=function(){return(a._FlipLeftRight=a.asm.FlipLeftRight).apply(null,arguments)},a._Floor=function(){return(a._Floor=a.asm.Floor).apply(null,arguments)},a._FloorDiv=function(){return(a._FloorDiv=a.asm.FloorDiv).apply(null,arguments)},a._FusedBatchNorm=function(){return(a._FusedBatchNorm=a.asm.FusedBatchNorm).apply(null,arguments)},a._FusedConv2D=function(){return(a._FusedConv2D=a.asm.FusedConv2D).apply(null,arguments)},a._FusedDepthwiseConv2D=function(){return(a._FusedDepthwiseConv2D=a.asm.FusedDepthwiseConv2D).apply(null,arguments)},a._Gather=function(){return(a._Gather=a.asm.Gather).apply(null,arguments)},a._GatherNd=function(){return(a._GatherNd=a.asm.GatherNd).apply(null,arguments)},a._Greater=function(){return(a._Greater=a.asm.Greater).apply(null,arguments)},a._GreaterEqual=function(){return(a._GreaterEqual=a.asm.GreaterEqual).apply(null,arguments)},a._LeakyRelu=function(){return(a._LeakyRelu=a.asm.LeakyRelu).apply(null,arguments)},a._Less=function(){return(a._Less=a.asm.Less).apply(null,arguments)},a._LessEqual=function(){return(a._LessEqual=a.asm.LessEqual).apply(null,arguments)},a._Log=function(){return(a._Log=a.asm.Log).apply(null,arguments)},a._LogicalAnd=function(){return(a._LogicalAnd=a.asm.LogicalAnd).apply(null,arguments)},a._LogicalNot=function(){return(a._LogicalNot=a.asm.LogicalNot).apply(null,arguments)},a._LogicalOr=function(){return(a._LogicalOr=a.asm.LogicalOr).apply(null,arguments)},a._LogicalXor=function(){return(a._LogicalXor=a.asm.LogicalXor).apply(null,arguments)},a._Max=function(){return(a._Max=a.asm.Max).apply(null,arguments)},a._MaxPool=function(){return(a._MaxPool=a.asm.MaxPool).apply(null,arguments)},a._Maximum=function(){return(a._Maximum=a.asm.Maximum).apply(null,arguments)},a._Mean=function(){return(a._Mean=a.asm.Mean).apply(null,arguments)},a._Min=function(){return(a._Min=a.asm.Min).apply(null,arguments)},a._Minimum=function(){return(a._Minimum=a.asm.Minimum).apply(null,arguments)},a._MirrorPad=function(){return(a._MirrorPad=a.asm.MirrorPad).apply(null,arguments)},a._Multiply=function(){return(a._Multiply=a.asm.Multiply).apply(null,arguments)},a._Neg=function(){return(a._Neg=a.asm.Neg).apply(null,arguments)},a._NonMaxSuppressionV3=function(){return(a._NonMaxSuppressionV3=a.asm.NonMaxSuppressionV3).apply(null,arguments)},a._NonMaxSuppressionV4=function(){return(a._NonMaxSuppressionV4=a.asm.NonMaxSuppressionV4).apply(null,arguments)},a._NonMaxSuppressionV5=function(){return(a._NonMaxSuppressionV5=a.asm.NonMaxSuppressionV5).apply(null,arguments)},a._NotEqual=function(){return(a._NotEqual=a.asm.NotEqual).apply(null,arguments)},a._OneHot=function(){return(a._OneHot=a.asm.OneHot).apply(null,arguments)},a._PadV2=function(){return(a._PadV2=a.asm.PadV2).apply(null,arguments)},a._Pow=function(){return(a._Pow=a.asm.Pow).apply(null,arguments)},a._Prelu=function(){return(a._Prelu=a.asm.Prelu).apply(null,arguments)},a._Prod=function(){return(a._Prod=a.asm.Prod).apply(null,arguments)},a._RealDiv=function(){return(a._RealDiv=a.asm.RealDiv).apply(null,arguments)},a._Relu=function(){return(a._Relu=a.asm.Relu).apply(null,arguments)},a._Relu6=function(){return(a._Relu6=a.asm.Relu6).apply(null,arguments)},a._ResizeBilinear=function(){return(a._ResizeBilinear=a.asm.ResizeBilinear).apply(null,arguments)},a._ResizeNearestNeighbor=function(){return(a._ResizeNearestNeighbor=a.asm.ResizeNearestNeighbor).apply(null,arguments)},a._Reverse=function(){return(a._Reverse=a.asm.Reverse).apply(null,arguments)},a._RotateWithOffset=function(){return(a._RotateWithOffset=a.asm.RotateWithOffset).apply(null,arguments)},a._Round=function(){return(a._Round=a.asm.Round).apply(null,arguments)},a._Rsqrt=function(){return(a._Rsqrt=a.asm.Rsqrt).apply(null,arguments)},a._ScatterNd=function(){return(a._ScatterNd=a.asm.ScatterNd).apply(null,arguments)},a._SelectV2=function(){return(a._SelectV2=a.asm.SelectV2).apply(null,arguments)},a._Sigmoid=function(){return(a._Sigmoid=a.asm.Sigmoid).apply(null,arguments)},a._Sin=function(){return(a._Sin=a.asm.Sin).apply(null,arguments)},a._Softmax=function(){return(a._Softmax=a.asm.Softmax).apply(null,arguments)},a._SparseFillEmptyRows=function(){return(a._SparseFillEmptyRows=a.asm.SparseFillEmptyRows).apply(null,arguments)},a._SparseReshape=function(){return(a._SparseReshape=a.asm.SparseReshape).apply(null,arguments)},a._SparseSegmentReduction=function(){return(a._SparseSegmentReduction=a.asm.SparseSegmentReduction).apply(null,arguments)},a._Sqrt=function(){return(a._Sqrt=a.asm.Sqrt).apply(null,arguments)},a._Square=function(){return(a._Square=a.asm.Square).apply(null,arguments)},a._SquaredDifference=function(){return(a._SquaredDifference=a.asm.SquaredDifference).apply(null,arguments)},a._Step=function(){return(a._Step=a.asm.Step).apply(null,arguments)},a._StridedSlice=function(){return(a._StridedSlice=a.asm.StridedSlice).apply(null,arguments)},a._Sub=function(){return(a._Sub=a.asm.Sub).apply(null,arguments)},a._Sum=function(){return(a._Sum=a.asm.Sum).apply(null,arguments)},a._Tan=function(){return(a._Tan=a.asm.Tan).apply(null,arguments)},a._Tanh=function(){return(a._Tanh=a.asm.Tanh).apply(null,arguments)},a._Tile=function(){return(a._Tile=a.asm.Tile).apply(null,arguments)},a._TopK=function(){return(a._TopK=a.asm.TopK).apply(null,arguments)},a._Transform=function(){return(a._Transform=a.asm.Transform).apply(null,arguments)},a._Transpose=function(){return(a._Transpose=a.asm.Transpose).apply(null,arguments)},a.__FusedMatMul=function(){return(a.__FusedMatMul=a.asm._FusedMatMul).apply(null,arguments)},a._malloc=function(){return(a._malloc=a.asm.malloc).apply(null,arguments)},a._free=function(){return(a._free=a.asm.free).apply(null,arguments)},a.___errno_location=function(){return(a.___errno_location=a.asm.__errno_location).apply(null,arguments)};var An=a.stackSave=function(){return(An=a.stackSave=a.asm.stackSave).apply(null,arguments)},Tr=a.stackRestore=function(){return(Tr=a.stackRestore=a.asm.stackRestore).apply(null,arguments)},je=a.stackAlloc=function(){return(je=a.stackAlloc=a.asm.stackAlloc).apply(null,arguments)};a.dynCall_iijjiiii=function(){return(a.dynCall_iijjiiii=a.asm.dynCall_iijjiiii).apply(null,arguments)},a.dynCall_jiji=function(){return(a.dynCall_jiji=a.asm.dynCall_jiji).apply(null,arguments)},a.cwrap=vt;var Le;Rn=function W(){Le||Et(),Le||(Rn=W)};function Et(W){if(nt>0||(wt(),nt>0))return;function X(){Le||(Le=!0,a.calledRun=!0,!R&&(Je(),o(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),Nn()))}a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),X()},1)):X()}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);a.preInit.length>0;)a.preInit.pop()();Et();var et;u&&(et={uncaughtException:process.listeners("uncaughtException").filter(function(W){return!u.uncaughtException.indexOf(W)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(W){return!u.unhandledRejection.indexOf(W)>-1})});var ht;if(typeof s!="undefined")ht=s;else if(typeof WasmBackendModuleThreadedSimd!="undefined")ht=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(et){var rn=ht._dispose;ht._dispose=function(){rn(),et.uncaughtException.forEach(function(W){process.removeListener("uncaughtException",W)}),et.unhandledRejection.forEach(function(W){process.removeListener("unhandledRejection",W)})}}return s.ready}})();n.exports=t})(Hz);const sb=So,jz=bc({__proto__:null,default:sb},[So]);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Th=rb||zz,qz=sb||jz;class Kz extends wc{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(tG),this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new Nh(this,or())}write(e,t,r){const s={id:this.dataIdNextNumber++};return this.move(s,e,t,r,1),s}numDataIds(){return this.dataIdMap.numDataIds()}time(e){return se(this,null,function*(){const t=un();return e(),{kernelMs:un()-t}})}move(e,t,r,s,a){const o=this.dataIdNextNumber++;if(s==="string"){const c=t;this.dataIdMap.set(e,{id:o,stringBytes:c,shape:r,dtype:s,memoryOffset:null,refCount:a});return}const i=V(r),u=i*Qs(s),l=this.wasm._malloc(u);this.dataIdMap.set(e,{id:o,memoryOffset:l,shape:r,dtype:s,refCount:a}),this.wasm.tfjs.registerTensor(o,i,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,u),l)}read(e){return se(this,null,function*(){return this.readSync(e)})}readSync(e,t,r){const{memoryOffset:s,dtype:a,shape:o,stringBytes:i}=this.dataIdMap.get(e);if(a==="string")return(t==null||t===0)&&(r==null||r>=i.length)?i:i.slice(t,r);t=t||0,r=r||V(o);const u=Qs(a),l=this.wasm.HEAPU8.slice(s+t*u,s+r*u);return Qz(l.buffer,a)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){const r=this.dataIdMap.get(e);if(r.refCount--,!t&&r.refCount>0)return!1;this.wasm._free(r.memoryOffset),this.wasm.tfjs.disposeData(r.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){const t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,r){let s;if(r==null)s=this.write(null,e,t);else{const a=this.dataIdNextNumber++;s={id:a},this.dataIdMap.set(s,{id:a,memoryOffset:r,shape:e,dtype:t,refCount:1});const o=V(e);this.wasm.tfjs.registerTensor(a,o,r)}return{dataId:s,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:r}){const s=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(r),o=V(e);switch(t){case"float32":return new Float32Array(s,a,o);case"int32":return new Int32Array(s,a,o);case"bool":return new Uint8Array(s,a,o);default:throw new Error(`Unknown dtype ${t}`)}}}function Xz(n){return(e,t)=>(p0(n,{credentials:"same-origin"}).then(r=>{r.ok||e.env.a(`failed to load wasm binary file at '${n}'`),r.arrayBuffer().then(s=>{WebAssembly.instantiate(s,e).then(a=>{t(a.instance,a.module)})})}),{})}function Ch(n,e,t){let r="tfjs-backend-wasm.wasm";return n&&e?r="tfjs-backend-wasm-threaded-simd.wasm":n&&(r="tfjs-backend-wasm-simd.wasm"),Ys!=null&&Ys[r]!=null?Ys[r]:t+r}function Yz(){return se(this,null,function*(){const[n,e]=yield Promise.all([L().getAsync("WASM_HAS_SIMD_SUPPORT"),L().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((t,r)=>{const s={};s.locateFile=(i,u)=>{if(i.endsWith(".worker.js")){const l=Gz.replace(/\n/g,"\\n"),c=new Blob([l],{type:"application/javascript"});return URL.createObjectURL(c)}return i.endsWith(".wasm")?Ch(n,e,qs!=null?qs:u):u+i},ab&&(s.instantiateWasm=Xz(Ch(n,e,qs!=null?qs:"")));let a=!1;s.onAbort=()=>{if(a||eo)return;eo=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let o;e&&n&&Jz==null?(s.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+Th.toString()],{type:"text/javascript"}),o=Th(s)):o=qz(s),o.then(i=>{a=!0,eo=!1;const u=null;i.tfjs={init:i.cwrap("init",null,[]),initWithThreadsCount:i.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:i.cwrap("get_threads_count","number",[]),registerTensor:i.cwrap("register_tensor",null,["number","number","number"]),disposeData:i.cwrap("dispose_data",u,["number"]),dispose:i.cwrap("dispose",u,[])},t({wasm:i})}).catch(r)})})}function Qz(n,e){switch(e){case"float32":return new Float32Array(n);case"int32":return new Int32Array(n);case"bool":return new Uint8Array(n);default:throw new Error(`Unknown dtype ${e}`)}}const Zz=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"];let Jz=null,qs=null,Ys={},eo=!1,ab=!1;function eG(n,e=!1){if(eo)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof n=="string")qs=n;else{Ys=n;const t=Zz.filter(r=>Ys[r]==null);if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}ab=e}let tG=-1;/** @license See the LICENSE file. */const nG="3.21.0";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rG=2;hm("wasm",()=>se(void 0,null,function*(){const{wasm:n}=yield Yz();return new Kz(n)}),rG);const _h="v1.3.22";let Xa={};const sG="https://yunketang-file.dream-sports.cn/static/tfjs-models-v2/model.json";_1();const mG=()=>new Promise((n,e)=>se(void 0,null,function*(){Xa.modelUrl=null;const t=navigator.userAgent.toLowerCase();(t.includes("dingtalk")||t.includes("quark"))&&(eG(`https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@${nG}/dist/`),yield N1(),yield k1("wasm"));try{Xa=yield jr(`indexeddb://my-model${_h}`),console.log("%c","font-size:12px; background:#2ab992; color:#6efdd6;")}catch(s){console.log("%c,","font-size:12px; background:#2ab992; color:#6efdd6;")}const r={modelType:vV.modelType.SINGLEPOSE_LIGHTNING,modelUrl:Xa.modelUrl||sG,enableTracking:!0};yield wV(Ln.MoveNet,r).then(s=>se(void 0,null,function*(){n(s);try{Xa.modelUrl===null&&(yield s.moveNetModel.save(`indexeddb://my-model${_h}`))}catch(a){}})).catch(s=>{e(s)})})),gG=(n,e,t,r,s)=>new Promise((a,o)=>se(void 0,null,function*(){const i=Math.floor(r),u=Math.floor(s),l=Fl(e,4),c=aG(480,640,i,u),p=yield Be(()=>Qn.resizeBilinear(Ie(l,c.start,c.size),[u,i]));n.estimatePoses(p,{flipHorizontal:!1}).then(d=>{St(),l.dispose(),p.dispose(),a(d)}).catch(d=>{St(),o(d)})}));function aG(n,e,t,r){const s={start:[0,0,0],size:[-1,-1,3]},a=r/t;return a>e/n?(s.start=[0,Math.ceil((n-Math.ceil(e/a))/2),0],s.size=[-1,Math.ceil(e/a),3]):(s.start=[Math.ceil((e-Math.floor(a*n))/2),0,0],s.size=[Math.ceil(a*n),-1,3]),s}const yG=(n,e)=>{Ot(n[0],n[1],e),Ot(n[0],n[2],e),Ot(n[1],n[3],e),Ot(n[2],n[4],e),Ot(n[10],n[8],e),Ot(n[8],n[6],e),Ot(n[6],n[5],e),Ot(n[5],n[7],e),Ot(n[7],n[9],e),Ot(n[6],n[12],e),Ot(n[12],n[11],e),Ot(n[11],n[5],e),Ot(n[12],n[14],e),Ot(n[14],n[16],e),Ot(n[11],n[13],e),Ot(n[13],n[15],e)},Ot=(n,e,t)=>{const r=n.x,s=n.y,a=e.x,o=e.y;t.beginPath(),t.moveTo(r,s),t.lineTo(a,o),t.lineWidth=3,t.strokeStyle="#ffffff",t.stroke(),t.restore()},xG=(n,e)=>{for(let t=0;t<n.length;t++){const r=n[t];oG(r.y,r.x,e)}},oG=(n,e,t)=>{t.beginPath(),t.arc(e,n,4,0,2*Math.PI,!1),t.lineWidth=2,t.strokeStyle="#ffffff",t.fillStyle="red",t.fill(),t.stroke(),t.restore()},iG=window.AudioContext,yc=new iG;let Rr=null,ob=null;function bG(){Rr&&Rr.stop(0)}function uG(){Rr=yc.createBufferSource(),Rr.buffer=ob,Rr.loop=!1,Rr.connect(yc.destination),Rr.start(0)}function cG(n){yc.decodeAudioData(n,function(e){ob=e,uG()},function(){})}function wG(n){const e=new XMLHttpRequest;e.open("GET",n,!0),e.responseType="arraybuffer",e.onload=function(){cG(this.response)},e.send()}const lG=window.AudioContext,xc=new lG;let Ar=null,ib=null;function vG(){Ar&&Ar.stop(0)}function pG(){Ar=xc.createBufferSource(),Ar.buffer=ib,Ar.loop=!1,Ar.connect(xc.destination),Ar.start(0)}function dG(n){xc.decodeAudioData(n,function(e){ib=e,pG()},function(){})}function SG(n){const e=new XMLHttpRequest;e.open("GET",n,!0),e.responseType="arraybuffer",e.onload=function(){dG(this.response)},e.send()}export{vG as a,SG as b,gG as c,xG as d,yG as e,mG as l,bG as s,wG as v};
